<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reference :: AgenticGoKit Docs</title>
    <link>http://localhost:1313/AgenticGoKitDocs/reference/index.html</link>
    <description>AgenticGoKit API Reference Navigation: Documentation Home ‚Üí API Reference&#xA;Complete API documentation for building multi-agent systems&#xA;This section provides comprehensive documentation for all public APIs in AgenticGoKit. The framework is designed with a clean, intuitive interface that makes building complex agent systems straightforward.&#xA;üìö API Overview AgenticGoKit‚Äôs API is organized around several core concepts:&#xA;Agent API - Individual agents that process events and states Orchestration API - Multi-agent coordination and workflow patterns State &amp; Events - Data flow and communication between agents Memory API - Persistent storage, RAG, and knowledge management MCP Integration - Tool integration via Model Context Protocol Configuration API - System configuration and setup üèóÔ∏è Architecture Overview graph TB&#xD;subgraph &#34;Core Interfaces&#34;&#xD;Agent[Agent Interface]&#xD;AgentHandler[AgentHandler Interface]&#xD;Runner[Runner Interface]&#xD;Orchestrator[Orchestrator Interface]&#xD;end&#xD;subgraph &#34;Data Flow&#34;&#xD;Event[Event]&#xD;State[State]&#xD;AgentResult[AgentResult]&#xD;end&#xD;subgraph &#34;Advanced Features&#34;&#xD;Memory[Memory System]&#xD;MCP[MCP Tools]&#xD;Config[Configuration]&#xD;end&#xD;Agent --&gt; AgentHandler&#xD;AgentHandler --&gt; Runner&#xD;Runner --&gt; Orchestrator&#xD;Event --&gt; AgentHandler&#xD;State --&gt; AgentHandler&#xD;AgentHandler --&gt; AgentResult&#xD;Memory --&gt; Agent&#xD;MCP --&gt; Agent&#xD;Config --&gt; Runner&#xD;üöÄ Quick Start Basic Agent Creation package main import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func main() { // Create a simple agent agent := core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { message := event.Data[&#34;message&#34;].(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;response&#34;: fmt.Sprintf(&#34;Processed: %s&#34;, message), }, }, nil }) // Create a runner and register the agent runner := core.NewRunner() runner.RegisterAgent(&#34;processor&#34;, agent) // Process an event event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;message&#34;: &#34;Hello, AgenticGoKit!&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) if err != nil { panic(err) } fmt.Printf(&#34;Response: %s\n&#34;, results[&#34;processor&#34;].Data[&#34;response&#34;]) }&#xD;Multi-Agent Collaboration func collaborativeExample() { // Create multiple agents agents := map[string]core.AgentHandler{ &#34;analyzer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { text := event.Data[&#34;text&#34;].(string) analysis := analyzeText(text) // Your analysis logic return core.AgentResult{ Data: map[string]interface{}{ &#34;analysis&#34;: analysis, &#34;word_count&#34;: len(strings.Fields(text)), }, }, nil }), &#34;summarizer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { text := event.Data[&#34;text&#34;].(string) summary := summarizeText(text) // Your summarization logic return core.AgentResult{ Data: map[string]interface{}{ &#34;summary&#34;: summary, }, }, nil }), } // Create collaborative runner runner := core.CreateCollaborativeRunner(agents, 30*time.Second) // Process with multiple agents event := core.NewEvent(&#34;analyze&#34;, map[string]interface{}{ &#34;text&#34;: &#34;Long document text here...&#34;, }) results, _ := runner.ProcessEvent(context.Background(), event) // Both agents processed the event in parallel fmt.Printf(&#34;Analysis: %v\n&#34;, results[&#34;analyzer&#34;].Data[&#34;analysis&#34;]) fmt.Printf(&#34;Summary: %s\n&#34;, results[&#34;summarizer&#34;].Data[&#34;summary&#34;]) }&#xD;üîß Core Interfaces Agent vs AgentHandler AgenticGoKit provides two main interfaces for creating agents:</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/AgenticGoKitDocs/reference/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>reference</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/readme/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/readme/index.html</guid>
      <description>AgenticGoKit API Reference Navigation: Documentation Home ‚Üí API Reference&#xA;Complete API documentation for building multi-agent systems&#xA;This section provides comprehensive documentation for all public APIs in AgenticGoKit. The framework is designed with a clean, intuitive interface that makes building complex agent systems straightforward.&#xA;üìö API Overview AgenticGoKit‚Äôs API is organized around several core concepts:&#xA;Agent API - Individual agents that process events and states Orchestration API - Multi-agent coordination and workflow patterns State &amp; Events - Data flow and communication between agents Memory API - Persistent storage, RAG, and knowledge management MCP Integration - Tool integration via Model Context Protocol Configuration API - System configuration and setup üèóÔ∏è Architecture Overview graph TB&#xD;subgraph &#34;Core Interfaces&#34;&#xD;Agent[Agent Interface]&#xD;AgentHandler[AgentHandler Interface]&#xD;Runner[Runner Interface]&#xD;Orchestrator[Orchestrator Interface]&#xD;end&#xD;subgraph &#34;Data Flow&#34;&#xD;Event[Event]&#xD;State[State]&#xD;AgentResult[AgentResult]&#xD;end&#xD;subgraph &#34;Advanced Features&#34;&#xD;Memory[Memory System]&#xD;MCP[MCP Tools]&#xD;Config[Configuration]&#xD;end&#xD;Agent --&gt; AgentHandler&#xD;AgentHandler --&gt; Runner&#xD;Runner --&gt; Orchestrator&#xD;Event --&gt; AgentHandler&#xD;State --&gt; AgentHandler&#xD;AgentHandler --&gt; AgentResult&#xD;Memory --&gt; Agent&#xD;MCP --&gt; Agent&#xD;Config --&gt; Runner&#xD;üöÄ Quick Start Basic Agent Creation package main import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func main() { // Create a simple agent agent := core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { message := event.Data[&#34;message&#34;].(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;response&#34;: fmt.Sprintf(&#34;Processed: %s&#34;, message), }, }, nil }) // Create a runner and register the agent runner := core.NewRunner() runner.RegisterAgent(&#34;processor&#34;, agent) // Process an event event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;message&#34;: &#34;Hello, AgenticGoKit!&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) if err != nil { panic(err) } fmt.Printf(&#34;Response: %s\n&#34;, results[&#34;processor&#34;].Data[&#34;response&#34;]) }&#xD;Multi-Agent Collaboration func collaborativeExample() { // Create multiple agents agents := map[string]core.AgentHandler{ &#34;analyzer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { text := event.Data[&#34;text&#34;].(string) analysis := analyzeText(text) // Your analysis logic return core.AgentResult{ Data: map[string]interface{}{ &#34;analysis&#34;: analysis, &#34;word_count&#34;: len(strings.Fields(text)), }, }, nil }), &#34;summarizer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { text := event.Data[&#34;text&#34;].(string) summary := summarizeText(text) // Your summarization logic return core.AgentResult{ Data: map[string]interface{}{ &#34;summary&#34;: summary, }, }, nil }), } // Create collaborative runner runner := core.CreateCollaborativeRunner(agents, 30*time.Second) // Process with multiple agents event := core.NewEvent(&#34;analyze&#34;, map[string]interface{}{ &#34;text&#34;: &#34;Long document text here...&#34;, }) results, _ := runner.ProcessEvent(context.Background(), event) // Both agents processed the event in parallel fmt.Printf(&#34;Analysis: %v\n&#34;, results[&#34;analyzer&#34;].Data[&#34;analysis&#34;]) fmt.Printf(&#34;Summary: %s\n&#34;, results[&#34;summarizer&#34;].Data[&#34;summary&#34;]) }&#xD;üîß Core Interfaces Agent vs AgentHandler AgenticGoKit provides two main interfaces for creating agents:</description>
    </item>
    <item>
      <title>configuration</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/configuration/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/configuration/index.html</guid>
      <description>Configuration API System configuration and setup&#xA;This document covers AgenticGoKit‚Äôs Configuration API, which provides comprehensive configuration management for agents, orchestration, memory systems, and MCP integration. The configuration system uses TOML files and provides validation and defaults.&#xA;üìã Core Configuration Types Main Configuration Structure The main configuration structure loaded from agentflow.toml:&#xA;type Config struct { AgentFlow struct { Name string `toml:&#34;name&#34;` Version string `toml:&#34;version&#34;` Provider string `toml:&#34;provider&#34;` } `toml:&#34;agent_flow&#34;` Logging struct { Level string `toml:&#34;level&#34;` Format string `toml:&#34;format&#34;` } `toml:&#34;logging&#34;` Runtime struct { MaxConcurrentAgents int `toml:&#34;max_concurrent_agents&#34;` TimeoutSeconds int `toml:&#34;timeout_seconds&#34;` } `toml:&#34;runtime&#34;` // Agent memory configuration AgentMemory AgentMemoryConfig `toml:&#34;agent_memory&#34;` // Error routing configuration ErrorRouting struct { Enabled bool `toml:&#34;enabled&#34;` MaxRetries int `toml:&#34;max_retries&#34;` RetryDelayMs int `toml:&#34;retry_delay_ms&#34;` EnableCircuitBreaker bool `toml:&#34;enable_circuit_breaker&#34;` ErrorHandlerName string `toml:&#34;error_handler_name&#34;` CategoryHandlers map[string]string `toml:&#34;category_handlers&#34;` SeverityHandlers map[string]string `toml:&#34;severity_handlers&#34;` CircuitBreaker CircuitBreakerConfigToml `toml:&#34;circuit_breaker&#34;` Retry RetryConfigToml `toml:&#34;retry&#34;` } `toml:&#34;error_routing&#34;` // Provider-specific configurations Providers map[string]map[string]interface{} `toml:&#34;providers&#34;` // MCP configuration MCP MCPConfigToml `toml:&#34;mcp&#34;` // Orchestration configuration Orchestration OrchestrationConfigToml `toml:&#34;orchestration&#34;` }&#xD;Memory Configuration Configuration for memory systems and RAG capabilities:</description>
    </item>
    <item>
      <title>cli</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/cli/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/cli/index.html</guid>
      <description>CLI Reference Complete reference for the AgenticGoKit command-line interface&#xA;This document provides comprehensive reference for AgenticGoKit‚Äôs command-line interface (agentcli), covering all commands, options, and usage patterns.&#xA;üèóÔ∏è Installation and Setup Installation # Install from source go install github.com/kunalkushwaha/agenticgokit/cmd/agentcli@latest # Or download binary from releases curl -L https://github.com/kunalkushwaha/agenticgokit/releases/latest/download/agentcli-${OS}-${ARCH}.tar.gz | tar xz&#xD;üìã Command Structure agentcli [global options] command [command options] [arguments...]&#xD;Global Options Option Short Description Default --config -c Path to configuration file agentflow.toml --verbose -v Enable verbose output false --quiet -q Suppress non-error output false --help -h Show help information --version Show version information üöÄ Available Commands Based on the actual codebase, the following commands are available:</description>
    </item>
    <item>
      <title>mcp</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/mcp/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/mcp/index.html</guid>
      <description>MCP Integration API Tool integration via Model Context Protocol&#xA;This document covers AgenticGoKit‚Äôs MCP (Model Context Protocol) integration API, which enables agents to discover, connect to, and use external tools and services. MCP provides a standardized way to integrate with various tools, from web search to database operations.&#xA;üìã Core Concepts MCP Overview MCP (Model Context Protocol) is a protocol for connecting AI agents with external tools and services. AgenticGoKit provides comprehensive MCP integration with three levels of complexity:</description>
    </item>
    <item>
      <title>agent</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/agent/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/agent/index.html</guid>
      <description>Agent API Building individual agents and agent handlers&#xA;This document covers the Agent API in AgenticGoKit, which provides the foundation for creating individual agents that can process events, maintain state, and participate in multi-agent orchestrations.&#xA;üìã Core Interfaces Agent Interface The basic Agent interface for simple state transformations:&#xA;type Agent interface { // Run processes the input State and returns an output State or an error Run(ctx context.Context, inputState State) (State, error) // Name returns the unique identifier name of the agent Name() string }&#xD;AgentHandler Interface The enhanced AgentHandler interface for event-driven processing:</description>
    </item>
    <item>
      <title>memory</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/memory/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/memory/index.html</guid>
      <description>Memory API Persistent storage, RAG, and knowledge management&#xA;This document covers AgenticGoKit‚Äôs Memory API, which enables agents to store and retrieve information persistently. The Memory system is essential for building agents with long-term memory, knowledge bases, and RAG (Retrieval-Augmented Generation) capabilities.&#xA;üìã Core Concepts Memory Interface The core interface for agent memory systems:&#xA;type Memory interface { // Store stores a memory with optional metadata Store(ctx context.Context, content string, metadata map[string]interface{}) (string, error) // Search finds memories similar to the query Search(ctx context.Context, query string, limit int, minScore float64) ([]MemorySearchResult, error) // Get retrieves a specific memory by ID Get(ctx context.Context, id string) (*MemorySearchResult, error) // Delete removes a memory by ID Delete(ctx context.Context, id string) error }&#xD;üöÄ Basic Usage Creating Memory System // Create memory configuration config := agentflow.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:password@localhost:5432/agentflow&#34;, Dimensions: 1536, Embedding: agentflow.EmbeddingConfig{ Provider: &#34;openai&#34;, APIKey: &#34;your-api-key&#34;, Model: &#34;text-embedding-3-small&#34;, }, } // Initialize memory memory, err := agentflow.NewMemory(config) if err != nil { log.Fatal(err) } defer memory.Close()&#xD;For complete documentation including RAG operations, document ingestion, and all memory providers, see the Agent API reference.</description>
    </item>
    <item>
      <title>orchestration</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/orchestration/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/orchestration/index.html</guid>
      <description>Orchestration API Multi-agent coordination and workflow patterns&#xA;This document covers AgenticGoKit‚Äôs Orchestration API, which enables sophisticated coordination between multiple agents. The orchestration system provides various patterns for agent collaboration, from simple routing to complex hybrid workflows.&#xA;üìã Core Concepts Orchestration Modes AgenticGoKit supports multiple orchestration patterns:&#xA;type OrchestrationMode string const ( // OrchestrationRoute sends each event to a single agent based on routing metadata (default) OrchestrationRoute OrchestrationMode = &#34;route&#34; // OrchestrationCollaborate sends each event to ALL registered agents in parallel OrchestrationCollaborate OrchestrationMode = &#34;collaborate&#34; // OrchestrationSequential processes agents one after another OrchestrationSequential OrchestrationMode = &#34;sequential&#34; // OrchestrationParallel processes agents in parallel (similar to collaborate) OrchestrationParallel OrchestrationMode = &#34;parallel&#34; // OrchestrationLoop repeats processing with a single agent OrchestrationLoop OrchestrationMode = &#34;loop&#34; // OrchestrationMixed combines collaborative and sequential patterns OrchestrationMixed OrchestrationMode = &#34;mixed&#34; )&#xD;üöÄ Basic Usage Route Orchestration (Default) // Create agents agents := map[string]core.AgentHandler{ &#34;greeter&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { name := event.Data[&#34;name&#34;].(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;greeting&#34;: fmt.Sprintf(&#34;Hello, %s!&#34;, name), }, }, nil }), } // Create route runner (default behavior) runner := core.CreateRouteRunner(agents)&#xD;Collaborative Orchestration // Create agents for parallel processing agents := map[string]core.AgentHandler{ &#34;researcher&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { query := event.Data[&#34;query&#34;].(string) // Research logic here return core.AgentResult{ Data: map[string]interface{}{ &#34;research_data&#34;: &#34;research results for &#34; + query, }, }, nil }), &#34;analyzer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { query := event.Data[&#34;query&#34;].(string) // Analysis logic here return core.AgentResult{ Data: map[string]interface{}{ &#34;analysis&#34;: &#34;analysis of &#34; + query, }, }, nil }), &#34;validator&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { query := event.Data[&#34;query&#34;].(string) // Validation logic here return core.AgentResult{ Data: map[string]interface{}{ &#34;validation&#34;: &#34;validation of &#34; + query, }, }, nil }), } // Create collaborative runner - all agents process in parallel runner := core.CreateCollaborativeRunner(agents, 2*time.Minute) // Process event - all agents will run simultaneously event := core.NewEvent(&#34;research&#34;, map[string]interface{}{ &#34;query&#34;: &#34;latest AI developments&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) if err != nil { log.Fatal(err) } // Results contain output from all agents fmt.Printf(&#34;Research: %v\n&#34;, results[&#34;researcher&#34;].Data[&#34;research_data&#34;]) fmt.Printf(&#34;Analysis: %v\n&#34;, results[&#34;analyzer&#34;].Data[&#34;analysis&#34;]) fmt.Printf(&#34;Validation: %v\n&#34;, results[&#34;validator&#34;].Data[&#34;validation&#34;])&#xD;Sequential Orchestration // Create agents for pipeline processing agents := map[string]core.AgentHandler{ &#34;collector&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { query := event.Data[&#34;query&#34;].(string) // Data collection logic collectedData := &#34;collected data for &#34; + query // Pass data to next agent via state state.Set(&#34;collected_data&#34;, collectedData) return core.AgentResult{ Data: map[string]interface{}{ &#34;status&#34;: &#34;data collected&#34;, }, }, nil }), &#34;processor&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Get data from previous agent collectedData, _ := state.Get(&#34;collected_data&#34;) // Process the data processedData := &#34;processed &#34; + collectedData.(string) state.Set(&#34;processed_data&#34;, processedData) return core.AgentResult{ Data: map[string]interface{}{ &#34;status&#34;: &#34;data processed&#34;, }, }, nil }), &#34;formatter&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Get processed data processedData, _ := state.Get(&#34;processed_data&#34;) // Format final output finalOutput := &#34;formatted &#34; + processedData.(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;final_output&#34;: finalOutput, }, }, nil }), } // Create sequential runner with ordered agent names runner := core.CreateSequentialRunner(agents, []string{&#34;collector&#34;, &#34;processor&#34;, &#34;formatter&#34;}) // Process event - agents run one after another event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;query&#34;: &#34;user data&#34;, }) result, err := runner.ProcessEvent(context.Background(), event) if err != nil { log.Fatal(err) } fmt.Printf(&#34;Final output: %v\n&#34;, result.Data[&#34;final_output&#34;])&#xD;Loop Orchestration // Create agent for iterative processing qualityChecker := core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Get current iteration count iteration, _ := state.Get(&#34;iteration&#34;) if iteration == nil { iteration = 0 } iterationCount := iteration.(int) + 1 state.Set(&#34;iteration&#34;, iterationCount) // Get content to check content, ok := event.Data[&#34;content&#34;].(string) if !ok { content, _ = state.Get(&#34;content&#34;).(string) } // Simulate quality checking qualityScore := calculateQuality(content) // Improve content if quality is low if qualityScore &lt; 0.8 &amp;&amp; iterationCount &lt; 5 { improvedContent := improveContent(content) state.Set(&#34;content&#34;, improvedContent) return core.AgentResult{ Data: map[string]interface{}{ &#34;quality_score&#34;: qualityScore, &#34;iteration&#34;: iterationCount, &#34;continue&#34;: true, // Signal to continue loop }, }, nil } // Quality is good enough or max iterations reached return core.AgentResult{ Data: map[string]interface{}{ &#34;quality_score&#34;: qualityScore, &#34;iteration&#34;: iterationCount, &#34;final_content&#34;: content, &#34;continue&#34;: false, // Signal to stop loop }, }, nil }) // Create loop runner runner := core.CreateLoopRunner(qualityChecker, 5) // Max 5 iterations // Process event event := core.NewEvent(&#34;quality_check&#34;, map[string]interface{}{ &#34;content&#34;: &#34;initial content that needs improvement&#34;, }) result, err := runner.ProcessEvent(context.Background(), event) if err != nil { log.Fatal(err) } fmt.Printf(&#34;Final quality score: %v\n&#34;, result.Data[&#34;quality_score&#34;]) fmt.Printf(&#34;Iterations: %v\n&#34;, result.Data[&#34;iteration&#34;]) fmt.Printf(&#34;Final content: %v\n&#34;, result.Data[&#34;final_content&#34;])&#xD;Mixed Orchestration // Create mixed orchestration with both collaborative and sequential phases builder := core.NewOrchestrationBuilder(core.OrchestrationMixed). WithCollaborativeAgents(map[string]core.AgentHandler{ &#34;analyzer&#34;: analyzerAgent, &#34;validator&#34;: validatorAgent, }). WithSequentialAgents(map[string]core.AgentHandler{ &#34;processor&#34;: processorAgent, &#34;reporter&#34;: reporterAgent, }). WithTimeout(5 * time.Minute). WithFailureThreshold(0.8) runner := builder.Build() // The mixed orchestration will: // 1. Run analyzer and validator in parallel (collaborative phase) // 2. Then run processor and reporter in sequence (sequential phase)&#xD;üèóÔ∏è Orchestration Builder OrchestrationBuilder Interface type OrchestrationBuilder interface { WithAgents(agents map[string]AgentHandler) *OrchestrationBuilder WithCollaborativeAgents(agents map[string]AgentHandler) *OrchestrationBuilder WithSequentialAgents(agents map[string]AgentHandler) *OrchestrationBuilder WithTimeout(timeout time.Duration) *OrchestrationBuilder WithMaxIterations(max int) *OrchestrationBuilder WithFailureThreshold(threshold float64) *OrchestrationBuilder WithMaxConcurrency(max int) *OrchestrationBuilder WithRetryPolicy(policy *RetryPolicy) *OrchestrationBuilder Build() Runner GenerateMermaidDiagram() string GenerateMermaidDiagramWithConfig(config MermaidConfig) string }&#xD;Advanced Configuration // Create sophisticated orchestration with all options runner := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents). WithTimeout(2 * time.Minute). WithFailureThreshold(0.8). // 80% of agents must succeed WithMaxConcurrency(5). // Max 5 concurrent agents WithRetryPolicy(&amp;core.RetryPolicy{ MaxRetries: 3, InitialDelay: time.Second, MaxDelay: 30 * time.Second, BackoffFactor: 2.0, }). Build()&#xD;üìä Workflow Visualization Generating Workflow Diagrams // Generate Mermaid diagram for orchestration builder := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents) // Generate basic diagram diagram := builder.GenerateMermaidDiagram() fmt.Println(diagram) // Generate diagram with custom configuration config := core.MermaidConfig{ DiagramType: core.FlowchartDiagram, Title: &#34;Research Workflow&#34;, Direction: &#34;TD&#34;, // Top-Down Theme: &#34;dark&#34;, ShowMetadata: true, ShowAgentTypes: true, CompactMode: false, } customDiagram := builder.GenerateMermaidDiagramWithConfig(config) fmt.Println(customDiagram) // Save diagram to file err := core.SaveDiagramAsMarkdown(&#34;workflow.md&#34;, &#34;Research Workflow&#34;, customDiagram) if err != nil { log.Printf(&#34;Failed to save diagram: %v&#34;, err) }&#xD;Example Generated Diagram ---&#xD;title: Collaborative Research Workflow&#xD;---&#xD;flowchart TD&#xD;INPUT[&#34;üéØ Event Input&#34;]&#xD;RESEARCHER[&#34;ü§ñ Researcher&lt;br/&gt;Type: Research Agent&lt;br/&gt;Timeout: 2m&#34;]&#xD;ANALYZER[&#34;ü§ñ Analyzer&lt;br/&gt;Type: Analysis Agent&lt;br/&gt;Timeout: 2m&#34;]&#xD;VALIDATOR[&#34;ü§ñ Validator&lt;br/&gt;Type: Validation Agent&lt;br/&gt;Timeout: 2m&#34;]&#xD;OUTPUT[&#34;‚úÖ Aggregated Result&#34;]&#xD;INPUT --&gt; RESEARCHER&#xD;INPUT --&gt; ANALYZER&#xD;INPUT --&gt; VALIDATOR&#xD;RESEARCHER --&gt; OUTPUT&#xD;ANALYZER --&gt; OUTPUT&#xD;VALIDATOR --&gt; OUTPUT&#xD;style RESEARCHER fill:#e1f5fe&#xD;style ANALYZER fill:#e8f5e8&#xD;style VALIDATOR fill:#fff3e0&#xD;üîß Runner Interface Core Runner Methods type Runner interface { // ProcessEvent processes a single event through the orchestration ProcessEvent(ctx context.Context, event Event) (map[string]AgentResult, error) // RegisterAgent adds an agent to the orchestration RegisterAgent(name string, handler AgentHandler) error // UnregisterAgent removes an agent from the orchestration UnregisterAgent(name string) error // ListAgents returns all registered agent names ListAgents() []string // GetAgent retrieves a specific agent by name GetAgent(name string) (AgentHandler, bool) // SetOrchestrationMode changes the orchestration pattern SetOrchestrationMode(mode OrchestrationMode) error // GetOrchestrationMode returns the current orchestration pattern GetOrchestrationMode() OrchestrationMode // Stop gracefully shuts down the runner Stop() error }&#xD;Runner Factory Functions // Create runners for specific patterns func CreateRouteRunner(agents map[string]AgentHandler) Runner func CreateCollaborativeRunner(agents map[string]AgentHandler, timeout time.Duration) Runner func CreateSequentialRunner(agents map[string]AgentHandler, order []string) Runner func CreateLoopRunner(agent AgentHandler, maxIterations int) Runner func CreateFaultTolerantRunner(agents map[string]AgentHandler) Runner func CreateLoadBalancedRunner(agents map[string]AgentHandler, maxConcurrency int) Runner&#xD;üîÑ Event Routing Route-Based Processing // Create agents with different capabilities agents := map[string]core.AgentHandler{ &#34;chat&#34;: chatAgent, &#34;search&#34;: searchAgent, &#34;analyze&#34;: analyzeAgent, } // Create route runner runner := core.CreateRouteRunner(agents) // Route to specific agent using metadata chatEvent := core.NewEvent(&#34;user_message&#34;, map[string]interface{}{&#34;message&#34;: &#34;Hello&#34;}, map[string]string{&#34;route&#34;: &#34;chat&#34;}, // Route to chat agent ) searchEvent := core.NewEvent(&#34;search_query&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, map[string]string{&#34;route&#34;: &#34;search&#34;}, // Route to search agent ) // Process events - each goes to specified agent chatResult, _ := runner.ProcessEvent(context.Background(), chatEvent) searchResult, _ := runner.ProcessEvent(context.Background(), searchEvent)&#xD;Dynamic Routing // Create router function func routeEvent(event core.Event) string { data := event.GetData() // Route based on event content if query, ok := data[&#34;query&#34;].(string); ok { if strings.Contains(strings.ToLower(query), &#34;search&#34;) { return &#34;search&#34; } if strings.Contains(strings.ToLower(query), &#34;analyze&#34;) { return &#34;analyze&#34; } } // Default to chat return &#34;chat&#34; } // Use custom routing logic runner := core.CreateRouteRunnerWithRouter(agents, routeEvent)&#xD;üìà Performance and Monitoring Execution Metrics // Enable metrics collection runner := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents). WithMetrics(true). Build() // Process events result, err := runner.ProcessEvent(ctx, event) // Get execution metrics metrics := runner.GetMetrics() fmt.Printf(&#34;Total execution time: %v\n&#34;, metrics.TotalDuration) fmt.Printf(&#34;Agent execution times: %v\n&#34;, metrics.AgentDurations) fmt.Printf(&#34;Success rate: %.2f%%\n&#34;, metrics.SuccessRate*100)&#xD;Health Checks // Check runner health health := runner.HealthCheck(ctx) if !health.Healthy { log.Printf(&#34;Runner unhealthy: %v&#34;, health.Issues) } // Check individual agent health for agentName := range agents { agentHealth := runner.CheckAgentHealth(ctx, agentName) if !agentHealth.Healthy { log.Printf(&#34;Agent %s unhealthy: %v&#34;, agentName, agentHealth.Issues) } }&#xD;üõ°Ô∏è Error Handling and Resilience Retry Policies retryPolicy := &amp;core.RetryPolicy{ MaxRetries: 3, InitialDelay: time.Second, MaxDelay: 30 * time.Second, BackoffFactor: 2.0, RetryableErrors: []error{ context.DeadlineExceeded, &amp;net.OpError{}, }, } runner := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents). WithRetryPolicy(retryPolicy). Build()&#xD;Circuit Breaker // Enable circuit breaker for fault tolerance runner := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents). WithCircuitBreaker(&amp;core.CircuitBreakerConfig{ FailureThreshold: 5, // Open after 5 failures RecoveryTimeout: 30 * time.Second, HalfOpenRequests: 3, // Test with 3 requests when half-open }). Build()&#xD;Graceful Degradation // Configure graceful degradation runner := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(agents). WithFailureThreshold(0.6). // Continue if 60% of agents succeed WithGracefulDegradation(true). Build() // Even if some agents fail, you&#39;ll get partial results result, err := runner.ProcessEvent(ctx, event) if err != nil { // Check if it&#39;s a partial failure if partialErr, ok := err.(*core.PartialFailureError); ok { log.Printf(&#34;Partial failure: %d/%d agents succeeded&#34;, partialErr.SuccessCount, partialErr.TotalCount) // Use partial results usePartialResults(result) } }&#xD;This comprehensive Orchestration API reference covers all aspects of multi-agent coordination in AgenticGoKit, from basic patterns to advanced configuration and monitoring.</description>
    </item>
    <item>
      <title>state-event</title>
      <link>http://localhost:1313/AgenticGoKitDocs/reference/api/state-event/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/reference/api/state-event/index.html</guid>
      <description>State &amp; Event API Reference Complete reference for data flow and communication between agents&#xA;This document provides comprehensive API reference for AgenticGoKit‚Äôs state management and event system, which enables data flow and communication between agents in multi-agent systems.&#xA;üèóÔ∏è Core Interfaces Event Interface The Event interface represents data that flows between agents in the system.&#xA;type Event interface { GetID() string GetData() EventData GetMetadata() map[string]string GetMetadataValue(key string) (string, bool) GetSourceAgentID() string GetTargetAgentID() string }&#xD;Methods GetID GetID() string&#xD;Returns the unique identifier for this event.</description>
    </item>
  </channel>
</rss>