<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>development :: AgenticGoKit Docs</title>
    <link>http://localhost:1313/AgenticGoKitDocs/guides/development/index.html</link>
    <description>Development Guides Guides for developing, testing, and debugging AgenticGoKit applications.&#xA;Available Guides Testing Agents Comprehensive guide to testing multi-agent systems, including unit tests, integration tests, and end-to-end testing strategies.&#xA;When to use: Building reliable agent systems that need thorough testing coverage.&#xA;Debugging Debug agent interactions, trace execution flows, and troubleshoot common issues in multi-agent systems.&#xA;When to use: When agents aren‚Äôt behaving as expected or you need to understand execution flow.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/AgenticGoKitDocs/guides/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>development</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/readme/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/readme/index.html</guid>
      <description>Development Guides Guides for developing, testing, and debugging AgenticGoKit applications.&#xA;Available Guides Testing Agents Comprehensive guide to testing multi-agent systems, including unit tests, integration tests, and end-to-end testing strategies.&#xA;When to use: Building reliable agent systems that need thorough testing coverage.&#xA;Debugging Debug agent interactions, trace execution flows, and troubleshoot common issues in multi-agent systems.&#xA;When to use: When agents aren‚Äôt behaving as expected or you need to understand execution flow.</description>
    </item>
    <item>
      <title>best-practices</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/best-practices/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/best-practices/index.html</guid>
      <description>Best Practices Development best practices for building robust AgenticGoKit applications&#xA;This guide covers essential best practices for developing, deploying, and maintaining AgenticGoKit applications. Follow these guidelines to build reliable, scalable, and maintainable multi-agent systems.&#xA;Agent Design Principles Single Responsibility Principle Each agent should have one clear, well-defined purpose:&#xA;// Good: Focused agent with single responsibility type EmailValidatorAgent struct { name string } func (a *EmailValidatorAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { email := event.Data[&#34;email&#34;].(string) if !isValidEmail(email) { return core.AgentResult{ Data: map[string]interface{}{ &#34;valid&#34;: false, &#34;error&#34;: &#34;Invalid email format&#34;, }, }, nil } return core.AgentResult{ Data: map[string]interface{}{ &#34;valid&#34;: true, &#34;email&#34;: email, }, }, nil } // Bad: Agent trying to do too many things type EmailProcessorAgent struct { // Validates, sends, logs, and analyzes emails - too many responsibilities }&#xD;Stateless Design When Possible Prefer stateless agents for better scalability and testability:</description>
    </item>
    <item>
      <title>debugging</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/debugging/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/debugging/index.html</guid>
      <description>Debugging Agent Interactions Understand and troubleshoot multi-agent workflows effectively&#xA;This guide teaches you how to debug complex agent interactions in AgenticGoKit. You‚Äôll learn to use tracing, logging, and debugging tools to understand what‚Äôs happening in your multi-agent systems and resolve issues quickly.&#xA;Quick Start (5 minutes) 1. Enable Debug Logging Update your agentflow.toml:&#xA;[logging] level = &#34;debug&#34; # Change from &#34;info&#34; to &#34;debug&#34; format = &#34;json&#34; file = &#34;debug.log&#34; # Optional: log to file&#xD;2. Run with Verbose Output # Run your agent with debug output go run . -m &#34;Test message&#34; --verbose # Or set environment variable export AGENTFLOW_LOG_LEVEL=debug go run . -m &#34;Test message&#34;&#xD;3. Use Built-in Tracing # Check if tracing is available agentcli trace --help # View recent traces (if available) agentcli trace --recent&#xD;Understanding Agent Flow Basic Flow Visualization AgenticGoKit processes events through this flow:</description>
    </item>
    <item>
      <title>research-assistant</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/research-assistant/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/research-assistant/index.html</guid>
      <description>Research Assistant Create a multi-agent research system with web search, analysis, and synthesis capabilities&#xA;This guide shows you how to build a comprehensive research assistant that can search the web, analyze information, and provide well-structured research reports using AgenticGoKit‚Äôs multi-agent orchestration.&#xA;What You‚Äôll Build A research assistant system that can:&#xA;Search the web for relevant information Analyze and validate sources Synthesize findings into coherent reports Handle complex multi-step research queries Maintain research context across interactions Prerequisites Basic AgenticGoKit project setup Understanding of multi-agent orchestration MCP tools configured for web search LLM provider configured (OpenAI, Azure, etc.) Quick Start 1. Create Research Assistant Project # Create project with collaborative orchestration agentcli create research-assistant \\ --orchestration-mode collaborative \\ --collaborative-agents \&#34;researcher,analyzer,synthesizer\&#34; \\ --mcp-enabled \\ --mcp-tools \&#34;web_search,summarize\&#34; \\ --visualize cd research-assistant&#xD;2. Configure Environment # Set up API keys export OPENAI_API_KEY=your-openai-key export BRAVE_API_KEY=your-brave-search-key # Optional # Install dependencies go mod tidy&#xD;3. Test the System # Run a research query go run . -m \&#34;Research the latest developments in quantum computing and their potential impact on cryptography\&#34;&#xD;Architecture Overview The research assistant uses a collaborative multi-agent architecture:</description>
    </item>
    <item>
      <title>testing-agents</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/testing-agents/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/testing-agents/index.html</guid>
      <description>Testing Agents Comprehensive testing strategies for multi-agent systems&#xA;This guide covers testing approaches for AgenticGoKit applications, from unit testing individual agents to integration testing complex multi-agent workflows.&#xA;Testing Philosophy AgenticGoKit testing follows these principles:&#xA;Test at multiple levels: Unit, integration, and end-to-end Mock external dependencies: LLM providers, databases, external APIs Test orchestration patterns: Verify agent interactions work correctly Performance testing: Ensure agents meet performance requirements Deterministic testing: Use mocks to ensure reproducible results Quick Start (10 minutes) 1. Basic Agent Unit Test package main import ( &#34;context&#34; &#34;testing&#34; &#34;github.com/stretchr/testify/assert&#34; &#34;github.com/stretchr/testify/require&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func TestGreetingAgent(t *testing.T) { // Create mock LLM provider mockLLM := &amp;MockLLMProvider{ response: &#34;Hello, World! Nice to meet you.&#34;, } // Create agent agent := NewGreetingAgent(&#34;greeter&#34;, mockLLM) // Create test event event := core.NewEvent(&#34;greeting&#34;, map[string]interface{}{ &#34;name&#34;: &#34;World&#34;, }) // Execute agent result, err := agent.Run(context.Background(), event, core.NewState()) // Verify results require.NoError(t, err) assert.Contains(t, result.Data[&#34;response&#34;], &#34;Hello&#34;) assert.Contains(t, result.Data[&#34;response&#34;], &#34;World&#34;) } // Mock LLM Provider for testing type MockLLMProvider struct { response string err error } func (m *MockLLMProvider) Generate(ctx context.Context, prompt string) (string, error) { if m.err != nil { return &#34;&#34;, m.err } return m.response, nil } func (m *MockLLMProvider) Name() string { return &#34;mock&#34; }&#xD;2. Multi-Agent Integration Test func TestMultiAgentWorkflow(t *testing.T) { // Create mock providers mockLLM := &amp;MockLLMProvider{ response: &#34;Processed successfully&#34;, } // Create agents agents := map[string]core.AgentHandler{ &#34;analyzer&#34;: NewAnalyzerAgent(mockLLM), &#34;processor&#34;: NewProcessorAgent(mockLLM), } // Create sequential runner runner := core.CreateSequentialRunner(agents, []string{&#34;analyzer&#34;, &#34;processor&#34;}, 30*time.Second) // Test workflow event := core.NewEvent(&#34;analyze&#34;, map[string]interface{}{ &#34;data&#34;: &#34;test data&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) require.NoError(t, err) assert.Len(t, results, 2) assert.Contains(t, results, &#34;analyzer&#34;) assert.Contains(t, results, &#34;processor&#34;) }&#xD;Unit Testing Patterns Testing Agent Logic func TestDataProcessingAgent(t *testing.T) { tests := []struct { name string input map[string]interface{} expected map[string]interface{} wantErr bool }{ { name: &#34;valid data processing&#34;, input: map[string]interface{}{ &#34;numbers&#34;: []int{1, 2, 3, 4, 5}, }, expected: map[string]interface{}{ &#34;sum&#34;: 15, &#34;average&#34;: 3.0, &#34;count&#34;: 5, }, wantErr: false, }, { name: &#34;empty data&#34;, input: map[string]interface{}{ &#34;numbers&#34;: []int{}, }, expected: nil, wantErr: true, }, { name: &#34;invalid input type&#34;, input: map[string]interface{}{ &#34;numbers&#34;: &#34;not a slice&#34;, }, expected: nil, wantErr: true, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { agent := NewDataProcessingAgent() event := core.NewEvent(&#34;process&#34;, tt.input) result, err := agent.Run(context.Background(), event, core.NewState()) if tt.wantErr { assert.Error(t, err) return } require.NoError(t, err) for key, expectedValue := range tt.expected { assert.Equal(t, expectedValue, result.Data[key]) } }) } }&#xD;Testing State Management func TestAgentStateHandling(t *testing.T) { agent := NewStatefulAgent() // Test state initialization initialState := core.NewState() initialState.Set(&#34;counter&#34;, 0) event := core.NewEvent(&#34;increment&#34;, nil) // First execution result1, err := agent.Run(context.Background(), event, initialState) require.NoError(t, err) assert.Equal(t, 1, result1.Data[&#34;counter&#34;]) // Second execution with updated state result2, err := agent.Run(context.Background(), event, result1.State) require.NoError(t, err) assert.Equal(t, 2, result2.Data[&#34;counter&#34;]) // Verify state persistence assert.Equal(t, 2, result2.State.Get(&#34;counter&#34;)) }&#xD;Testing Error Handling func TestAgentErrorHandling(t *testing.T) { // Test with failing LLM provider failingLLM := &amp;MockLLMProvider{ err: errors.New(&#34;LLM service unavailable&#34;), } agent := NewResilientAgent(failingLLM) event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;input&#34;: &#34;test&#34;, }) result, err := agent.Run(context.Background(), event, core.NewState()) // Agent should handle LLM failure gracefully require.NoError(t, err) assert.Contains(t, result.Data[&#34;response&#34;], &#34;service temporarily unavailable&#34;) assert.True(t, result.Data[&#34;fallback_used&#34;].(bool)) }&#xD;Integration Testing Testing Orchestration Patterns func TestSequentialOrchestration(t *testing.T) { // Create agents that depend on each other agents := map[string]core.AgentHandler{ &#34;step1&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { input := event.Data[&#34;input&#34;].(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;step1_output&#34;: input + &#34;_processed&#34;, }, }, nil }), &#34;step2&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { step1Output := state.Data[&#34;step1_output&#34;].(string) return core.AgentResult{ Data: map[string]interface{}{ &#34;final_output&#34;: step1Output + &#34;_finalized&#34;, }, }, nil }), } runner := core.CreateSequentialRunner(agents, []string{&#34;step1&#34;, &#34;step2&#34;}, 30*time.Second) event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;input&#34;: &#34;test&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) require.NoError(t, err) assert.Equal(t, &#34;test_processed_finalized&#34;, results[&#34;step2&#34;].Data[&#34;final_output&#34;]) } func TestCollaborativeOrchestration(t *testing.T) { // Create agents that work in parallel agents := map[string]core.AgentHandler{ &#34;analyzer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { return core.AgentResult{ Data: map[string]interface{}{ &#34;analysis&#34;: &#34;positive sentiment&#34;, }, }, nil }), &#34;summarizer&#34;: core.AgentHandlerFunc(func(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { return core.AgentResult{ Data: map[string]interface{}{ &#34;summary&#34;: &#34;brief summary&#34;, }, }, nil }), } runner := core.CreateCollaborativeRunner(agents, 30*time.Second) event := core.NewEvent(&#34;analyze&#34;, map[string]interface{}{ &#34;text&#34;: &#34;This is great!&#34;, }) results, err := runner.ProcessEvent(context.Background(), event) require.NoError(t, err) assert.Len(t, results, 2) assert.Equal(t, &#34;positive sentiment&#34;, results[&#34;analyzer&#34;].Data[&#34;analysis&#34;]) assert.Equal(t, &#34;brief summary&#34;, results[&#34;summarizer&#34;].Data[&#34;summary&#34;]) }&#xD;Testing Memory Integration func TestAgentWithMemory(t *testing.T) { // Create in-memory provider for testing memoryConfig := core.AgentMemoryConfig{ Provider: &#34;memory&#34;, Connection: &#34;memory&#34;, Dimensions: 384, Embedding: core.EmbeddingConfig{ Provider: &#34;dummy&#34;, }, } memory, err := core.NewMemory(memoryConfig) require.NoError(t, err) defer memory.Close() // Create memory-enabled agent agent := NewMemoryEnabledAgent(memory) ctx := memory.SetSession(context.Background(), &#34;test-session&#34;) // First interaction - store information event1 := core.NewEvent(&#34;remember&#34;, map[string]interface{}{ &#34;info&#34;: &#34;User likes coffee&#34;, }) result1, err := agent.Run(ctx, event1, core.NewState()) require.NoError(t, err) assert.Contains(t, result1.Data[&#34;response&#34;], &#34;remembered&#34;) // Second interaction - recall information event2 := core.NewEvent(&#34;recall&#34;, map[string]interface{}{ &#34;query&#34;: &#34;What does the user like?&#34;, }) result2, err := agent.Run(ctx, event2, core.NewState()) require.NoError(t, err) assert.Contains(t, result2.Data[&#34;response&#34;], &#34;coffee&#34;) }&#xD;Testing MCP Tool Integration func TestAgentWithMCPTools(t *testing.T) { // Create mock MCP manager mockMCP := &amp;MockMCPManager{ tools: []core.ToolSchema{ { Name: &#34;search&#34;, Description: &#34;Search for information&#34;, }, }, responses: map[string]interface{}{ &#34;search&#34;: map[string]interface{}{ &#34;results&#34;: []string{&#34;Mock search result&#34;}, }, }, } mockLLM := &amp;MockLLMProvider{ response: `I&#39;ll search for that information. &lt;tool_call&gt; {&#34;name&#34;: &#34;search&#34;, &#34;args&#34;: {&#34;query&#34;: &#34;test query&#34;}} &lt;/tool_call&gt; Based on the search results, here&#39;s what I found...`, } agent := NewToolEnabledAgent(mockLLM, mockMCP) event := core.NewEvent(&#34;query&#34;, map[string]interface{}{ &#34;question&#34;: &#34;Search for test information&#34;, }) result, err := agent.Run(context.Background(), event, core.NewState()) require.NoError(t, err) assert.True(t, result.Data[&#34;tools_used&#34;].(bool)) assert.Contains(t, result.Data[&#34;tool_results&#34;], &#34;Mock search result&#34;) } type MockMCPManager struct { tools []core.ToolSchema responses map[string]interface{} } func (m *MockMCPManager) ListTools(ctx context.Context) ([]core.ToolSchema, error) { return m.tools, nil } func (m *MockMCPManager) CallTool(ctx context.Context, name string, args map[string]interface{}) (interface{}, error) { if response, exists := m.responses[name]; exists { return response, nil } return nil, fmt.Errorf(&#34;tool not found: %s&#34;, name) }&#xD;Performance Testing Load Testing func TestAgentPerformance(t *testing.T) { if testing.Short() { t.Skip(&#34;Skipping performance test in short mode&#34;) } agent := NewPerformantAgent() // Test concurrent execution concurrency := 10 iterations := 100 var wg sync.WaitGroup results := make(chan time.Duration, concurrency*iterations) for i := 0; i &lt; concurrency; i++ { wg.Add(1) go func() { defer wg.Done() for j := 0; j &lt; iterations; j++ { start := time.Now() event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;data&#34;: fmt.Sprintf(&#34;test_%d_%d&#34;, i, j), }) _, err := agent.Run(context.Background(), event, core.NewState()) duration := time.Since(start) require.NoError(t, err) results &lt;- duration } }() } wg.Wait() close(results) // Analyze performance var total time.Duration var max time.Duration count := 0 for duration := range results { total += duration if duration &gt; max { max = duration } count++ } average := total / time.Duration(count) t.Logf(&#34;Performance Results:&#34;) t.Logf(&#34; Total requests: %d&#34;, count) t.Logf(&#34; Average duration: %v&#34;, average) t.Logf(&#34; Max duration: %v&#34;, max) t.Logf(&#34; Requests per second: %.2f&#34;, float64(count)/total.Seconds()) // Assert performance requirements assert.Less(t, average, 100*time.Millisecond, &#34;Average response time should be under 100ms&#34;) assert.Less(t, max, 500*time.Millisecond, &#34;Max response time should be under 500ms&#34;) }&#xD;Memory Usage Testing func TestAgentMemoryUsage(t *testing.T) { agent := NewMemoryEfficientAgent() // Measure initial memory var m1 runtime.MemStats runtime.GC() runtime.ReadMemStats(&amp;m1) // Run many iterations for i := 0; i &lt; 1000; i++ { event := core.NewEvent(&#34;process&#34;, map[string]interface{}{ &#34;data&#34;: strings.Repeat(&#34;x&#34;, 1000), // 1KB of data }) _, err := agent.Run(context.Background(), event, core.NewState()) require.NoError(t, err) } // Force garbage collection and measure final memory runtime.GC() var m2 runtime.MemStats runtime.ReadMemStats(&amp;m2) // Calculate memory increase memoryIncrease := m2.Alloc - m1.Alloc t.Logf(&#34;Memory usage:&#34;) t.Logf(&#34; Initial: %d KB&#34;, m1.Alloc/1024) t.Logf(&#34; Final: %d KB&#34;, m2.Alloc/1024) t.Logf(&#34; Increase: %d KB&#34;, memoryIncrease/1024) // Assert reasonable memory usage (adjust threshold as needed) assert.Less(t, memoryIncrease, uint64(10*1024*1024), &#34;Memory increase should be less than 10MB&#34;) }&#xD;End-to-End Testing Complete Workflow Testing func TestCompleteWorkflow(t *testing.T) { // Set up complete system memoryConfig := core.AgentMemoryConfig{ Provider: &#34;memory&#34;, Connection: &#34;memory&#34;, Dimensions: 384, Embedding: core.EmbeddingConfig{ Provider: &#34;dummy&#34;, }, } memory, err := core.NewMemory(memoryConfig) require.NoError(t, err) defer memory.Close() mockLLM := &amp;MockLLMProvider{ response: &#34;I understand your request and will process it accordingly.&#34;, } // Create complete agent system agents := map[string]core.AgentHandler{ &#34;intake&#34;: NewIntakeAgent(mockLLM), &#34;processor&#34;: NewProcessorAgent(mockLLM, memory), &#34;responder&#34;: NewResponderAgent(mockLLM), } runner := core.CreateSequentialRunner(agents, []string{&#34;intake&#34;, &#34;processor&#34;, &#34;responder&#34;}, 60*time.Second) // Test complete user interaction ctx := memory.SetSession(context.Background(), &#34;e2e-test-session&#34;) event := core.NewEvent(&#34;user_request&#34;, map[string]interface{}{ &#34;message&#34;: &#34;I need help with my project&#34;, &#34;user_id&#34;: &#34;test_user&#34;, }) results, err := runner.ProcessEvent(ctx, event) require.NoError(t, err) assert.Len(t, results, 3) // Verify each stage completed successfully assert.Contains(t, results[&#34;intake&#34;].Data, &#34;processed&#34;) assert.Contains(t, results[&#34;processor&#34;].Data, &#34;analyzed&#34;) assert.Contains(t, results[&#34;responder&#34;].Data, &#34;response&#34;) // Verify final response quality finalResponse := results[&#34;responder&#34;].Data[&#34;response&#34;].(string) assert.NotEmpty(t, finalResponse) assert.Greater(t, len(finalResponse), 10) }&#xD;Test Utilities and Helpers Test Data Builders // Event builder for consistent test data type EventBuilder struct { eventType string data map[string]interface{} metadata map[string]interface{} } func NewEventBuilder(eventType string) *EventBuilder { return &amp;EventBuilder{ eventType: eventType, data: make(map[string]interface{}), metadata: make(map[string]interface{}), } } func (eb *EventBuilder) WithData(key string, value interface{}) *EventBuilder { eb.data[key] = value return eb } func (eb *EventBuilder) WithMetadata(key string, value interface{}) *EventBuilder { eb.metadata[key] = value return eb } func (eb *EventBuilder) Build() core.Event { event := core.NewEvent(eb.eventType, eb.data) for k, v := range eb.metadata { event.Metadata[k] = v } return event } // Usage in tests func TestWithEventBuilder(t *testing.T) { event := NewEventBuilder(&#34;process&#34;). WithData(&#34;input&#34;, &#34;test data&#34;). WithData(&#34;priority&#34;, &#34;high&#34;). WithMetadata(&#34;user_id&#34;, &#34;123&#34;). Build() // Use event in test... }&#xD;Agent Test Harness type AgentTestHarness struct { agent core.AgentHandler mockLLM *MockLLMProvider memory core.Memory ctx context.Context } func NewAgentTestHarness(agent core.AgentHandler) *AgentTestHarness { mockLLM := &amp;MockLLMProvider{} memoryConfig := core.AgentMemoryConfig{ Provider: &#34;memory&#34;, Connection: &#34;memory&#34;, Dimensions: 384, Embedding: core.EmbeddingConfig{ Provider: &#34;dummy&#34;, }, } memory, _ := core.NewMemory(memoryConfig) ctx := memory.SetSession(context.Background(), &#34;test-session&#34;) return &amp;AgentTestHarness{ agent: agent, mockLLM: mockLLM, memory: memory, ctx: ctx, } } func (h *AgentTestHarness) SetLLMResponse(response string) { h.mockLLM.response = response } func (h *AgentTestHarness) SetLLMError(err error) { h.mockLLM.err = err } func (h *AgentTestHarness) Execute(event core.Event) (core.AgentResult, error) { return h.agent.Run(h.ctx, event, core.NewState()) } func (h *AgentTestHarness) Cleanup() { if h.memory != nil { h.memory.Close() } } // Usage in tests func TestWithHarness(t *testing.T) { harness := NewAgentTestHarness(NewMyAgent()) defer harness.Cleanup() harness.SetLLMResponse(&#34;Expected response&#34;) event := core.NewEvent(&#34;test&#34;, map[string]interface{}{ &#34;input&#34;: &#34;test data&#34;, }) result, err := harness.Execute(event) require.NoError(t, err) assert.Equal(t, &#34;Expected response&#34;, result.Data[&#34;response&#34;]) }&#xD;Continuous Integration GitHub Actions Test Configuration # .github/workflows/test.yml name: Test on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest services: postgres: image: pgvector/pgvector:pg15 env: POSTGRES_PASSWORD: password POSTGRES_DB: agentflow_test options: &gt;- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 ports: - 5432:5432 steps: - uses: actions/checkout@v3 - name: Set up Go uses: actions/setup-go@v3 with: go-version: 1.21 - name: Install dependencies run: go mod download - name: Run unit tests run: go test -v -short ./... - name: Run integration tests run: go test -v ./... env: TEST_DB_URL: postgres://postgres:password@localhost:5432/agentflow_test?sslmode=disable - name: Run performance tests run: go test -v -run TestPerformance ./... - name: Generate coverage report run: go test -coverprofile=coverage.out ./... - name: Upload coverage to Codecov uses: codecov/codecov-action@v3 with: file: ./coverage.out&#xD;Best Practices Test Organization // Organize tests by functionality func TestAgentCore(t *testing.T) { t.Run(&#34;BasicExecution&#34;, testBasicExecution) t.Run(&#34;ErrorHandling&#34;, testErrorHandling) t.Run(&#34;StateManagement&#34;, testStateManagement) } func TestAgentIntegration(t *testing.T) { t.Run(&#34;WithMemory&#34;, testWithMemory) t.Run(&#34;WithTools&#34;, testWithTools) t.Run(&#34;WithOrchestration&#34;, testWithOrchestration) } func TestAgentPerformance(t *testing.T) { if testing.Short() { t.Skip(&#34;Skipping performance tests in short mode&#34;) } t.Run(&#34;LoadTest&#34;, testLoadTest) t.Run(&#34;MemoryUsage&#34;, testMemoryUsage) t.Run(&#34;Concurrency&#34;, testConcurrency) }&#xD;Test Data Management // Use table-driven tests for multiple scenarios func TestDataProcessing(t *testing.T) { testCases := []struct { name string input interface{} expected interface{} wantErr bool }{ // Test cases here... } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { // Test implementation... }) } } // Use test fixtures for complex data func loadTestFixture(t *testing.T, filename string) map[string]interface{} { data, err := os.ReadFile(filepath.Join(&#34;testdata&#34;, filename)) require.NoError(t, err) var result map[string]interface{} err = json.Unmarshal(data, &amp;result) require.NoError(t, err) return result }&#xD;Next Steps Debugging - Debug agent interactions effectively Best Practices - Development best practices Production Deployment - Production deployment</description>
    </item>
    <item>
      <title>visualization</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/visualization/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/visualization/index.html</guid>
      <description>AgenticGoKit Workflow Visualization Guide Overview AgenticGoKit provides comprehensive workflow visualization capabilities using Mermaid diagrams. You can visualize multi-agent compositions, orchestrations, and complex workflow patterns to better understand and document your agent systems.&#xA;Features 1. Composition Builder Visualization Sequential workflows: Step-by-step agent processing pipelines Parallel processing: Fan-out/fan-in patterns for concurrent execution Loop patterns: Retry and iteration logic with conditions 2. Orchestration Builder Visualization Collaborative orchestration: Broadcast events to multiple agents Routing patterns: Conditional routing based on event types Mixed orchestration modes: Sequential, parallel, and loop orchestrations 3. AgentBuilder Integration Multi-agent composition visualization: Preview compositions before building Pre-build diagram generation: Generate diagrams during agent construction Configuration validation: Visualize settings like timeouts and error strategies 4. Advanced Features Custom diagram configuration: Control direction, themes, and metadata display Pre-built workflow patterns: Map-reduce, pipeline, and other common patterns File export: Save diagrams as .mmd files for documentation Styling and metadata: Professional diagrams with execution details Quick Start Examples Basic Sequential Workflow // Create agents orderAgent := createAgent(&#34;OrderProcessor&#34;) paymentAgent := createAgent(&#34;PaymentProcessor&#34;) shippingAgent := createAgent(&#34;ShippingService&#34;) // Build sequential composition pipeline := core.NewComposition(&#34;order-pipeline&#34;). WithAgents(orderAgent, paymentAgent, shippingAgent). AsSequential(). WithTimeout(2 * time.Minute) // Generate diagram diagram := pipeline.GenerateMermaidDiagram() fmt.Println(diagram)&#xD;Parallel Processing // Create analysis agents sentimentAgent := createAgent(&#34;SentimentAnalyzer&#34;) keywordAgent := createAgent(&#34;KeywordExtractor&#34;) languageAgent := createAgent(&#34;LanguageDetector&#34;) // Build parallel composition analysis := core.NewComposition(&#34;content-analysis&#34;). WithAgents(sentimentAgent, keywordAgent, languageAgent). AsParallel(). WithTimeout(30 * time.Second). WithErrorStrategy(core.ErrorStrategyCollectAll) // Generate custom diagram (left-to-right) config := core.MermaidConfig{ DiagramType: core.MermaidFlowchart, Title: &#34;Content Analysis System&#34;, Direction: &#34;LR&#34;, ShowMetadata: true, ShowAgentTypes: true, } diagram := analysis.GenerateMermaidDiagramWithConfig(config)&#xD;AgentBuilder with Visualization // Build agent with multi-agent composition builder := core.NewAgent(&#34;DataProcessor&#34;). WithParallelAgents(dataAgent, analyticsAgent, reportAgent). WithMultiAgentConfig(core.MultiAgentConfig{ Timeout: 90 * time.Second, MaxConcurrency: 8, ErrorStrategy: core.ErrorStrategyCollectAll, StateStrategy: core.StateStrategyMerge, }) // Check if it can be visualized if builder.CanVisualize() { diagram := builder.GenerateMermaidDiagram() // Save to file os.WriteFile(&#34;workflow.mmd&#34;, []byte(diagram), 0644) } // Build the actual agent agent, err := builder.Build()&#xD;Loop with Conditions qualityAgent := createAgent(&#34;QualityChecker&#34;) // Define stop condition condition := func(state core.State) bool { if score, exists := state.Get(&#34;quality_score&#34;); exists { if qualityScore, ok := score.(float64); ok { return qualityScore &gt;= 0.95 // Stop at 95% quality } } return false } // Build loop composition qualityLoop := core.NewComposition(&#34;quality-monitor&#34;). WithAgents(qualityAgent). AsLoop(10, condition). // Max 10 iterations WithTimeout(5 * time.Minute) diagram := qualityLoop.GenerateMermaidDiagram()&#xD;Orchestration Patterns // Collaborative microservices serviceHandlers := map[string]core.AgentHandler{ &#34;user-service&#34;: core.ConvertAgentToHandler(userAgent), &#34;order-service&#34;: core.ConvertAgentToHandler(orderAgent), &#34;payment-service&#34;: core.ConvertAgentToHandler(paymentAgent), } collaboration := core.NewOrchestrationBuilder(core.OrchestrationCollaborate). WithAgents(serviceHandlers). WithTimeout(1 * time.Minute). WithMaxConcurrency(20) diagram := collaboration.GenerateMermaidDiagram() // API routing routing := core.NewOrchestrationBuilder(core.OrchestrationRoute). WithAgents(serviceHandlers). WithTimeout(30 * time.Second) routingDiagram := routing.GenerateMermaidDiagram()&#xD;Configuration Options MermaidConfig Structure type MermaidConfig struct { DiagramType MermaidDiagramType // flowchart, sequenceDiagram, etc. Title string // Custom diagram title Direction string // &#34;TD&#34;, &#34;LR&#34;, &#34;BT&#34;, &#34;RL&#34; Theme string // &#34;default&#34;, &#34;dark&#34;, &#34;forest&#34; ShowMetadata bool // Include timeout/error info ShowAgentTypes bool // Show agent type details CompactMode bool // Generate compact diagrams }&#xD;Available Directions &#34;TD&#34; or &#34;TB&#34;: Top to Bottom (default) &#34;LR&#34;: Left to Right &#34;BT&#34;: Bottom to Top &#34;RL&#34;: Right to Left Themes &#34;default&#34;: Standard Mermaid theme &#34;dark&#34;: Dark theme for presentations &#34;forest&#34;: Green theme &#34;base&#34;: Minimal theme Workflow Patterns Pre-built Patterns // Map-Reduce pattern agents := []core.Agent{dataAgent, processor1, processor2, reducer} mapReduceDiagram := core.GenerateWorkflowPatternDiagram(&#34;map-reduce&#34;, agents) // Pipeline pattern pipelineAgents := []core.Agent{input, transform, validate, output} pipelineDiagram := core.GenerateWorkflowPatternDiagram(&#34;pipeline&#34;, pipelineAgents)&#xD;File Export and Integration Save Diagrams to Files // Create output directory outputDir := &#34;workflow_diagrams&#34; os.MkdirAll(outputDir, 0755) // Save diagram as Markdown file filename := filepath.Join(outputDir, &#34;my_workflow.md&#34;) err := core.SaveDiagramAsMarkdown(filename, &#34;My Workflow&#34;, diagram) // Save with metadata metadata := map[string]interface{}{ &#34;Pattern&#34;: &#34;Sequential Processing&#34;, &#34;Agents&#34;: 4, &#34;Timeout&#34;: &#34;2 minutes&#34;, &#34;Error Strategy&#34;: &#34;Fail Fast&#34;, } err = core.SaveDiagramWithMetadata(filename, &#34;My Workflow&#34;, &#34;Description of the workflow&#34;, diagram, metadata)&#xD;View Diagrams VS Code/GitHub/GitLab: Open .md files directly - Mermaid diagrams render automatically Online: Copy Mermaid code to Mermaid Live Editor Documentation: Include .md files in project documentation Presentations: Export from Mermaid Live as PNG/SVG Integration in Documentation # My Workflow Here&#39;s how our order processing works: \`\`\`mermaid --- title: Order Processing Pipeline --- flowchart TD INPUT[&#34;üéØ Order Request&#34;] AGENT1[&#34;ü§ñ InventoryChecker&#34;] INPUT --&gt; AGENT1 AGENT2[&#34;ü§ñ PaymentProcessor&#34;] AGENT1 --&gt; AGENT2 AGENT3[&#34;ü§ñ ShippingService&#34;] AGENT2 --&gt; AGENT3 OUTPUT[&#34;‚úÖ Order Complete&#34;] AGENT3 --&gt; OUTPUT \`\`\`&#xD;Best Practices 1. Use Descriptive Agent Names ‚úÖ &#34;OrderProcessor&#34;, &#34;PaymentGateway&#34; ‚ùå &#34;Agent1&#34;, &#34;Worker&#34; 2. Choose Appropriate Directions Sequential workflows: Top-to-bottom (&#34;TD&#34;) Data flows: Left-to-right (&#34;LR&#34;) Process hierarchies: Top-to-bottom (&#34;TD&#34;) 3. Include Metadata for Complex Systems config := core.MermaidConfig{ ShowMetadata: true, // Show timeouts, error strategies ShowAgentTypes: true, // Show agent capabilities }&#xD;Save Diagrams During Development // Always save diagrams for documentation if builder.CanVisualize() { diagram := builder.GenerateMermaidDiagram() filename := fmt.Sprintf(&#34;docs/%s.md&#34;, builder.Name()) core.SaveDiagramAsMarkdown(filename, builder.Name(), diagram) }&#xD;5. Use Custom Titles for Clarity config := core.MermaidConfig{ Title: &#34;E-commerce Order Processing Pipeline v2.1&#34;, }&#xD;Troubleshooting Common Issues Empty Diagram: Check if composition has agents and a mode set</description>
    </item>
    <item>
      <title>web-search-integration</title>
      <link>http://localhost:1313/AgenticGoKitDocs/guides/development/web-search-integration/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/guides/development/web-search-integration/index.html</guid>
      <description>Web Search Integration Give your agents the ability to search the web for real-time information&#xA;This guide shows you how to integrate web search capabilities into your AgenticGoKit agents using MCP (Model Context Protocol) tools. You‚Äôll learn to set up web search, handle results, and optimize for different use cases.&#xA;Prerequisites Basic AgenticGoKit project setup Understanding of MCP tool integration API key for a search service (optional for basic setup) What You‚Äôll Build An agent system that can:</description>
    </item>
  </channel>
</rss>