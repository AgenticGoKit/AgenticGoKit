<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head><script src="/AgenticGoKitDocs/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=AgenticGoKitDocs/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="description" content="Document Ingestion and Knowledge Base Management Overview Document ingestion is a critical component of building comprehensive knowledge bases in AgenticGoKit. This tutorial covers the complete pipeline from raw documents to searchable knowledge, including document processing, chunking strategies, metadata extraction, and optimization techniques.
Effective document ingestion enables agents to access and reason over large collections of structured and unstructured data.
Prerequisites Understanding of Memory Systems Overview Familiarity with Vector Databases Knowledge of document formats (PDF, Markdown, HTML, etc.) Basic understanding of text processing and NLP concepts Document Ingestion Pipeline Architecture Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Raw │───▶│ Document │───▶│ Text ││ Documents │ │ Parser │ │ Extraction │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Vector │◀───│ Embedding │◀───│ Text ││ Storage │ │ Generation │ │ Chunking │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐│ Metadata ││ Extraction │└─────────────────┘Document Types and Processing 1. Supported Document Types // Document types supported by AgenticGoKit const ( DocumentTypePDF DocumentType = &#34;pdf&#34; DocumentTypeText DocumentType = &#34;txt&#34; DocumentTypeMarkdown DocumentType = &#34;md&#34; DocumentTypeWeb DocumentType = &#34;web&#34; DocumentTypeCode DocumentType = &#34;code&#34; DocumentTypeJSON DocumentType = &#34;json&#34; ) // Document structure for ingestion type Document struct { ID string `json:&#34;id&#34;` Title string `json:&#34;title,omitempty&#34;` Content string `json:&#34;content&#34;` Source string `json:&#34;source,omitempty&#34;` // URL, file path, etc. Type DocumentType `json:&#34;type,omitempty&#34;` Metadata map[string]any `json:&#34;metadata,omitempty&#34;` Tags []string `json:&#34;tags,omitempty&#34;` CreatedAt time.Time `json:&#34;created_at&#34;` UpdatedAt time.Time `json:&#34;updated_at,omitempty&#34;` ChunkIndex int `json:&#34;chunk_index,omitempty&#34;` // For chunked documents ChunkTotal int `json:&#34;chunk_total,omitempty&#34;` }2. Basic Document Ingestion package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func ingestBasicDocument(memory core.Memory) error { ctx := context.Background() // Create a document doc := core.Document{ ID: &#34;doc-001&#34;, Title: &#34;Introduction to Machine Learning&#34;, Content: `Machine learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed for every task. It involves algorithms that can identify patterns, make predictions, and improve their performance over time.`, Source: &#34;textbook-chapter-1.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 1, &#34;subject&#34;: &#34;machine-learning&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, &#34;language&#34;: &#34;english&#34;, }, Tags: []string{&#34;ml&#34;, &#34;ai&#34;, &#34;introduction&#34;}, CreatedAt: time.Now(), } // Ingest the document err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest document: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested document: %s\n&#34;, doc.Title) return nil }3. Batch Document Ingestion func ingestMultipleDocuments(memory core.Memory) error { ctx := context.Background() // Prepare multiple documents documents := []core.Document{ { ID: &#34;doc-002&#34;, Title: &#34;Neural Networks Fundamentals&#34;, Content: &#34;Neural networks are computing systems inspired by biological neural networks...&#34;, Source: &#34;textbook-chapter-2.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 2, &#34;subject&#34;: &#34;neural-networks&#34;, &#34;difficulty&#34;: &#34;intermediate&#34;, }, Tags: []string{&#34;neural-networks&#34;, &#34;deep-learning&#34;}, }, { ID: &#34;doc-003&#34;, Title: &#34;Data Preprocessing Techniques&#34;, Content: &#34;Data preprocessing is a crucial step in machine learning pipelines...&#34;, Source: &#34;textbook-chapter-3.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 3, &#34;subject&#34;: &#34;data-preprocessing&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, }, Tags: []string{&#34;data-science&#34;, &#34;preprocessing&#34;}, }, } // Batch ingest documents err := memory.IngestDocuments(ctx, documents) if err != nil { return fmt.Errorf(&#34;failed to ingest documents: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested %d documents\n&#34;, len(documents)) return nil }Text Chunking Strategies 1. Fixed-Size Chunking type FixedSizeChunker struct { ChunkSize int ChunkOverlap int } func NewFixedSizeChunker(chunkSize, overlap int) *FixedSizeChunker { return &amp;FixedSizeChunker{ ChunkSize: chunkSize, ChunkOverlap: overlap, } } func (c *FixedSizeChunker) ChunkText(text string) []string { if len(text) &lt;= c.ChunkSize { return []string{text} } var chunks []string start := 0 for start &lt; len(text) { end := start &#43; c.ChunkSize if end &gt; len(text) { end = len(text) } chunk := text[start:end] chunks = append(chunks, chunk) // Move start position considering overlap start &#43;= c.ChunkSize - c.ChunkOverlap if start &gt;= len(text) { break } } return chunks } // Example usage func chunkLargeDocument(memory core.Memory, largeText string) error { ctx := context.Background() chunker := NewFixedSizeChunker(1000, 200) chunks := chunker.ChunkText(largeText) for i, chunk := range chunks { doc := core.Document{ ID: fmt.Sprintf(&#34;large-doc-chunk-%d&#34;, i), Title: fmt.Sprintf(&#34;Large Document - Chunk %d&#34;, i&#43;1), Content: chunk, Source: &#34;large-document.pdf&#34;, Type: core.DocumentTypePDF, ChunkIndex: i, ChunkTotal: len(chunks), Metadata: map[string]any{ &#34;chunk_method&#34;: &#34;fixed-size&#34;, &#34;chunk_size&#34;: 1000, &#34;chunk_overlap&#34;: 200, }, CreatedAt: time.Now(), } err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest chunk %d: %w&#34;, i, err) } } return nil }2. Semantic Chunking type SemanticChunker struct { MaxChunkSize int MinChunkSize int } func NewSemanticChunker(minSize, maxSize int) *SemanticChunker { return &amp;SemanticChunker{ MinChunkSize: minSize, MaxChunkSize: maxSize, } } func (c *SemanticChunker) ChunkText(text string) []string { // Split by paragraphs first paragraphs := strings.Split(text, &#34;\n\n&#34;) var chunks []string var currentChunk strings.Builder for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed max size if currentChunk.Len() &gt; 0 &amp;&amp; currentChunk.Len()&#43;len(paragraph) &gt; c.MaxChunkSize { // Finalize current chunk if it meets minimum size if currentChunk.Len() &gt;= c.MinChunkSize { chunks = append(chunks, currentChunk.String()) currentChunk.Reset() } } // Add paragraph to current chunk if currentChunk.Len() &gt; 0 { currentChunk.WriteString(&#34;\n\n&#34;) } currentChunk.WriteString(paragraph) } // Add final chunk if it has content if currentChunk.Len() &gt; 0 { chunks = append(chunks, currentChunk.String()) } return chunks }3. Sentence-Based Chunking type SentenceChunker struct { MaxSentences int Overlap int } func NewSentenceChunker(maxSentences, overlap int) *SentenceChunker { return &amp;SentenceChunker{ MaxSentences: maxSentences, Overlap: overlap, } } func (c *SentenceChunker) ChunkText(text string) []string { sentences := c.splitIntoSentences(text) if len(sentences) &lt;= c.MaxSentences { return []string{text} } var chunks []string start := 0 for start &lt; len(sentences) { end := start &#43; c.MaxSentences if end &gt; len(sentences) { end = len(sentences) } chunk := strings.Join(sentences[start:end], &#34; &#34;) chunks = append(chunks, chunk) start &#43;= c.MaxSentences - c.Overlap if start &gt;= len(sentences) { break } } return chunks } func (c *SentenceChunker) splitIntoSentences(text string) []string { // Simple sentence splitting (in production, use a proper NLP library) sentences := strings.FieldsFunc(text, func(r rune) bool { return r == &#39;.&#39; || r == &#39;!&#39; || r == &#39;?&#39; }) // Clean up sentences var cleanSentences []string for _, sentence := range sentences { sentence = strings.TrimSpace(sentence) if len(sentence) &gt; 10 { // Filter out very short fragments cleanSentences = append(cleanSentences, sentence) } } return cleanSentences }Advanced Document Processing 1. Document Processor with Multiple Strategies type DocumentProcessor struct { memory core.Memory chunkers map[string]TextChunker extractors map[core.DocumentType]MetadataExtractor config ProcessorConfig } type TextChunker interface { ChunkText(text string) []string } type MetadataExtractor interface { ExtractMetadata(doc core.Document) (map[string]any, error) } type ProcessorConfig struct { DefaultChunkStrategy string MaxConcurrentDocs int EnableMetadataExtraction bool EnableContentCleaning bool } func NewDocumentProcessor(memory core.Memory, config ProcessorConfig) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, chunkers: make(map[string]TextChunker), extractors: make(map[core.DocumentType]MetadataExtractor), config: config, } // Register default chunkers dp.chunkers[&#34;fixed&#34;] = NewFixedSizeChunker(1000, 200) dp.chunkers[&#34;semantic&#34;] = NewSemanticChunker(500, 1500) dp.chunkers[&#34;sentence&#34;] = NewSentenceChunker(10, 2) // Register metadata extractors dp.extractors[core.DocumentTypePDF] = &amp;PDFMetadataExtractor{} dp.extractors[core.DocumentTypeMarkdown] = &amp;MarkdownMetadataExtractor{} dp.extractors[core.DocumentTypeCode] = &amp;CodeMetadataExtractor{} return dp } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc core.Document, chunkStrategy string) error { // Clean content if enabled if dp.config.EnableContentCleaning { doc.Content = dp.cleanContent(doc.Content) } // Extract metadata if enabled if dp.config.EnableMetadataExtraction { if extractor, exists := dp.extractors[doc.Type]; exists { metadata, err := extractor.ExtractMetadata(doc) if err == nil { // Merge extracted metadata with existing if doc.Metadata == nil { doc.Metadata = make(map[string]any) } for k, v := range metadata { doc.Metadata[k] = v } } } } // Choose chunking strategy if chunkStrategy == &#34;&#34; { chunkStrategy = dp.config.DefaultChunkStrategy } chunker, exists := dp.chunkers[chunkStrategy] if !exists { return fmt.Errorf(&#34;unknown chunking strategy: %s&#34;, chunkStrategy) } // Chunk the document chunks := chunker.ChunkText(doc.Content) // Process chunks if len(chunks) == 1 { // Single chunk - ingest as-is return dp.memory.IngestDocument(ctx, doc) } // Multiple chunks - create separate documents var documents []core.Document for i, chunk := range chunks { chunkDoc := doc // Copy original document chunkDoc.ID = fmt.Sprintf(&#34;%s-chunk-%d&#34;, doc.ID, i) chunkDoc.Content = chunk chunkDoc.ChunkIndex = i chunkDoc.ChunkTotal = len(chunks) // Add chunking metadata if chunkDoc.Metadata == nil { chunkDoc.Metadata = make(map[string]any) } chunkDoc.Metadata[&#34;chunk_strategy&#34;] = chunkStrategy chunkDoc.Metadata[&#34;original_doc_id&#34;] = doc.ID documents = append(documents, chunkDoc) } return dp.memory.IngestDocuments(ctx, documents) } func (dp *DocumentProcessor) cleanContent(content string) string { // Remove excessive whitespace content = regexp.MustCompile(`\s&#43;`).ReplaceAllString(content, &#34; &#34;) // Remove special characters that might interfere with processing content = regexp.MustCompile(`[^\w\s\.,!?;:()\-&#34;&#39;]`).ReplaceAllString(content, &#34;&#34;) // Trim whitespace content = strings.TrimSpace(content) return content }2. Metadata Extractors // PDF Metadata Extractor type PDFMetadataExtractor struct{} func (e *PDFMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract basic statistics metadata[&#34;word_count&#34;] = len(strings.Fields(doc.Content)) metadata[&#34;char_count&#34;] = len(doc.Content) metadata[&#34;paragraph_count&#34;] = len(strings.Split(doc.Content, &#34;\n\n&#34;)) // Extract potential headings (lines that are short and followed by longer content) lines := strings.Split(doc.Content, &#34;\n&#34;) var headings []string for i, line := range lines { line = strings.TrimSpace(line) if len(line) &gt; 0 &amp;&amp; len(line) &lt; 100 &amp;&amp; i&#43;1 &lt; len(lines) { nextLine := strings.TrimSpace(lines[i&#43;1]) if len(nextLine) &gt; len(line)*2 { headings = append(headings, line) } } } metadata[&#34;potential_headings&#34;] = headings // Detect language (simple heuristic) metadata[&#34;detected_language&#34;] = detectLanguage(doc.Content) return metadata, nil } // Markdown Metadata Extractor type MarkdownMetadataExtractor struct{} func (e *MarkdownMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract headings headings := extractMarkdownHeadings(doc.Content) metadata[&#34;headings&#34;] = headings metadata[&#34;heading_count&#34;] = len(headings) // Extract links links := extractMarkdownLinks(doc.Content) metadata[&#34;links&#34;] = links metadata[&#34;link_count&#34;] = len(links) // Extract code blocks codeBlocks := extractMarkdownCodeBlocks(doc.Content) metadata[&#34;code_blocks&#34;] = len(codeBlocks) // Extract front matter if present frontMatter := extractFrontMatter(doc.Content) if frontMatter != nil { metadata[&#34;front_matter&#34;] = frontMatter } return metadata, nil } // Code Metadata Extractor type CodeMetadataExtractor struct{} func (e *CodeMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Detect programming language language := detectProgrammingLanguage(doc.Source, doc.Content) metadata[&#34;programming_language&#34;] = language // Count lines of code lines := strings.Split(doc.Content, &#34;\n&#34;) metadata[&#34;total_lines&#34;] = len(lines) // Count non-empty lines nonEmptyLines := 0 commentLines := 0 for _, line := range lines { line = strings.TrimSpace(line) if line != &#34;&#34; { nonEmptyLines&#43;&#43; if isCommentLine(line, language) { commentLines&#43;&#43; } } } metadata[&#34;code_lines&#34;] = nonEmptyLines metadata[&#34;comment_lines&#34;] = commentLines // Extract functions/methods (basic pattern matching) functions := extractFunctions(doc.Content, language) metadata[&#34;functions&#34;] = functions metadata[&#34;function_count&#34;] = len(functions) return metadata, nil } // Helper functions for metadata extraction func detectLanguage(content string) string { // Simple language detection based on common words englishWords := []string{&#34;the&#34;, &#34;and&#34;, &#34;is&#34;, &#34;in&#34;, &#34;to&#34;, &#34;of&#34;, &#34;a&#34;, &#34;that&#34;, &#34;it&#34;, &#34;with&#34;} words := strings.Fields(strings.ToLower(content)) englishCount := 0 for _, word := range words { for _, englishWord := range englishWords { if word == englishWord { englishCount&#43;&#43; break } } } if float64(englishCount)/float64(len(words)) &gt; 0.1 { return &#34;english&#34; } return &#34;unknown&#34; } func extractMarkdownHeadings(content string) []string { var headings []string lines := strings.Split(content, &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;#&#34;) { headings = append(headings, line) } } return headings } func extractMarkdownLinks(content string) []string { // Simple regex for markdown links [text](url) linkRegex := regexp.MustCompile(`\[([^\]]&#43;)\]\(([^)]&#43;)\)`) matches := linkRegex.FindAllStringSubmatch(content, -1) var links []string for _, match := range matches { if len(match) &gt;= 3 { links = append(links, match[2]) // URL part } } return links } func extractMarkdownCodeBlocks(content string) []string { // Simple extraction of code blocks codeBlockRegex := regexp.MustCompile(&#34;```[\\s\\S]*?```&#34;) matches := codeBlockRegex.FindAllString(content, -1) return matches } func extractFrontMatter(content string) map[string]any { // Extract YAML front matter if !strings.HasPrefix(content, &#34;---&#34;) { return nil } parts := strings.SplitN(content, &#34;---&#34;, 3) if len(parts) &lt; 3 { return nil } // Simple key-value extraction (in production, use a YAML parser) frontMatter := make(map[string]any) lines := strings.Split(parts[1], &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.Contains(line, &#34;:&#34;) { parts := strings.SplitN(line, &#34;:&#34;, 2) if len(parts) == 2 { key := strings.TrimSpace(parts[0]) value := strings.TrimSpace(parts[1]) frontMatter[key] = value } } } return frontMatter } func detectProgrammingLanguage(filename, content string) string { // Detect by file extension ext := strings.ToLower(filepath.Ext(filename)) switch ext { case &#34;.go&#34;: return &#34;go&#34; case &#34;.py&#34;: return &#34;python&#34; case &#34;.js&#34;: return &#34;javascript&#34; case &#34;.ts&#34;: return &#34;typescript&#34; case &#34;.java&#34;: return &#34;java&#34; case &#34;.cpp&#34;, &#34;.cc&#34;, &#34;.cxx&#34;: return &#34;cpp&#34; case &#34;.c&#34;: return &#34;c&#34; case &#34;.rs&#34;: return &#34;rust&#34; } // Detect by content patterns if strings.Contains(content, &#34;package main&#34;) || strings.Contains(content, &#34;func &#34;) { return &#34;go&#34; } if strings.Contains(content, &#34;def &#34;) || strings.Contains(content, &#34;import &#34;) { return &#34;python&#34; } return &#34;unknown&#34; } func isCommentLine(line, language string) bool { switch language { case &#34;go&#34;, &#34;javascript&#34;, &#34;typescript&#34;, &#34;java&#34;, &#34;cpp&#34;, &#34;c&#34;, &#34;rust&#34;: return strings.HasPrefix(line, &#34;//&#34;) || strings.HasPrefix(line, &#34;/*&#34;) case &#34;python&#34;: return strings.HasPrefix(line, &#34;#&#34;) } return false } func extractFunctions(content, language string) []string { var functions []string switch language { case &#34;go&#34;: funcRegex := regexp.MustCompile(`func\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;python&#34;: funcRegex := regexp.MustCompile(`def\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;javascript&#34;, &#34;typescript&#34;: funcRegex := regexp.MustCompile(`function\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } } return functions }Knowledge Base Search and Retrieval 1. Advanced Search with Filters func performAdvancedKnowledgeSearch(memory core.Memory) error { ctx := context.Background() // Search with multiple filters results, err := memory.SearchKnowledge(ctx, &#34;machine learning algorithms&#34;, core.WithLimit(10), core.WithScoreThreshold(0.7), core.WithSources([]string{&#34;textbook-chapter-1.pdf&#34;, &#34;textbook-chapter-2.pdf&#34;}), core.WithDocumentTypes([]core.DocumentType{core.DocumentTypePDF}), core.WithTags([]string{&#34;ml&#34;, &#34;algorithms&#34;}), core.WithDateRange(&amp;core.DateRange{ Start: time.Now().Add(-30 * 24 * time.Hour), End: time.Now(), }), ) if err != nil { return fmt.Errorf(&#34;knowledge search failed: %w&#34;, err) } fmt.Printf(&#34;Found %d relevant knowledge items:\n&#34;, len(results)) for _, result := range results { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, result.Title, result.Score) fmt.Printf(&#34; Source: %s\n&#34;, result.Source) fmt.Printf(&#34; Content: %s...\n&#34;, truncateString(result.Content, 100)) if result.ChunkIndex &gt; 0 { fmt.Printf(&#34; Chunk: %d/%d\n&#34;, result.ChunkIndex&#43;1, result.ChunkTotal) } fmt.Println() } return nil } func truncateString(s string, maxLen int) string { if len(s) &lt;= maxLen { return s } return s[:maxLen] &#43; &#34;...&#34; }2. Hybrid Search (Personal &#43; Knowledge) func performHybridSearch(memory core.Memory) error { ctx := context.Context() // Perform hybrid search combining personal memory and knowledge base result, err := memory.SearchAll(ctx, &#34;neural network implementation&#34;, core.WithLimit(15), core.WithScoreThreshold(0.6), core.WithIncludePersonal(true), core.WithIncludeKnowledge(true), core.WithHybridWeight(0.7), // 70% semantic, 30% keyword ) if err != nil { return fmt.Errorf(&#34;hybrid search failed: %w&#34;, err) } fmt.Printf(&#34;Hybrid Search Results for: %s\n&#34;, result.Query) fmt.Printf(&#34;Total Results: %d (Search Time: %v)\n\n&#34;, result.TotalResults, result.SearchTime) // Display personal memory results if len(result.PersonalMemory) &gt; 0 { fmt.Println(&#34;Personal Memory Results:&#34;) for _, item := range result.PersonalMemory { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, truncateString(item.Content, 80), item.Score) } fmt.Println() } // Display knowledge base results if len(result.Knowledge) &gt; 0 { fmt.Println(&#34;Knowledge Base Results:&#34;) for _, item := range result.Knowledge { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, item.Title, item.Score) fmt.Printf(&#34; Source: %s\n&#34;, item.Source) } } return nil }3. RAG Context Building func buildRAGContext(memory core.Memory, query string) error { ctx := context.Background() // Build comprehensive RAG context ragContext, err := memory.BuildContext(ctx, query, core.WithMaxTokens(4000), core.WithPersonalWeight(0.3), core.WithKnowledgeWeight(0.7), core.WithHistoryLimit(5), core.WithIncludeSources(true), core.WithFormatTemplate(`Context Information: Personal Memory: {{range .PersonalMemory}} - {{.Content}} {{end}} Knowledge Base: {{range .Knowledge}} - {{.Content}} (Source: {{.Source}}) {{end}} Recent Conversation: {{range .ChatHistory}} {{.Role}}: {{.Content}} {{end}} Query: {{.Query}}`), ) if err != nil { return fmt.Errorf(&#34;failed to build RAG context: %w&#34;, err) } fmt.Printf(&#34;RAG Context for: %s\n&#34;, ragContext.Query) fmt.Printf(&#34;Token Count: %d\n&#34;, ragContext.TokenCount) fmt.Printf(&#34;Sources: %v\n&#34;, ragContext.Sources) fmt.Printf(&#34;Context Text:\n%s\n&#34;, ragContext.ContextText) return nil }Production Optimization 1. Batch Processing Pipeline type BatchProcessor struct { memory core.Memory processor *DocumentProcessor concurrency int batchSize int } func NewBatchProcessor(memory core.Memory, concurrency, batchSize int) *BatchProcessor { return &amp;BatchProcessor{ memory: memory, processor: NewDocumentProcessor(memory, ProcessorConfig{ DefaultChunkStrategy: &#34;semantic&#34;, MaxConcurrentDocs: concurrency, EnableMetadataExtraction: true, EnableContentCleaning: true, }), concurrency: concurrency, batchSize: batchSize, } } func (bp *BatchProcessor) ProcessDocuments(ctx context.Context, documents []core.Document) error { // Process documents in batches for i := 0; i &lt; len(documents); i &#43;= bp.batchSize { end := i &#43; bp.batchSize if end &gt; len(documents) { end = len(documents) } batch := documents[i:end] err := bp.processBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to process batch %d-%d: %w&#34;, i, end-1, err) } fmt.Printf(&#34;Processed batch %d-%d (%d documents)\n&#34;, i, end-1, len(batch)) } return nil } func (bp *BatchProcessor) processBatch(ctx context.Context, documents []core.Document) error { // Use worker pool for concurrent processing jobs := make(chan core.Document, len(documents)) results := make(chan error, len(documents)) // Start workers for w := 0; w &lt; bp.concurrency; w&#43;&#43; { go bp.worker(ctx, jobs, results) } // Send jobs for _, doc := range documents { jobs &lt;- doc } close(jobs) // Collect results var errors []error for i := 0; i &lt; len(documents); i&#43;&#43; { if err := &lt;-results; err != nil { errors = append(errors, err) } } if len(errors) &gt; 0 { return fmt.Errorf(&#34;batch processing failed with %d errors: %v&#34;, len(errors), errors[0]) } return nil } func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan core.Document, results chan&lt;- error) { for doc := range jobs { err := bp.processor.ProcessDocument(ctx, doc, &#34;&#34;) results &lt;- err } }2. Performance Monitoring type IngestionMetrics struct { DocumentsProcessed int64 `json:&#34;documents_processed&#34;` ChunksCreated int64 `json:&#34;chunks_created&#34;` ProcessingTime time.Duration `json:&#34;processing_time&#34;` ErrorCount int64 `json:&#34;error_count&#34;` AverageChunkSize float64 `json:&#34;average_chunk_size&#34;` mu sync.RWMutex } func (m *IngestionMetrics) RecordDocument(chunkCount int, processingTime time.Duration, chunkSizes []int) { m.mu.Lock() defer m.mu.Unlock() m.DocumentsProcessed&#43;&#43; m.ChunksCreated &#43;= int64(chunkCount) m.ProcessingTime &#43;= processingTime // Update average chunk size if len(chunkSizes) &gt; 0 { totalSize := 0 for _, size := range chunkSizes { totalSize &#43;= size } avgSize := float64(totalSize) / float64(len(chunkSizes)) // Running average totalChunks := float64(m.ChunksCreated) m.AverageChunkSize = (m.AverageChunkSize*(totalChunks-float64(chunkCount)) &#43; avgSize*float64(chunkCount)) / totalChunks } } func (m *IngestionMetrics) RecordError() { m.mu.Lock() defer m.mu.Unlock() m.ErrorCount&#43;&#43; } func (m *IngestionMetrics) GetStats() IngestionMetrics { m.mu.RLock() defer m.mu.RUnlock() return IngestionMetrics{ DocumentsProcessed: m.DocumentsProcessed, ChunksCreated: m.ChunksCreated, ProcessingTime: m.ProcessingTime, ErrorCount: m.ErrorCount, AverageChunkSize: m.AverageChunkSize, } }Best Practices 1. Document Ingestion Guidelines Chunk Size: Balance between context preservation and retrieval precision Overlap: Use 10-20% overlap to maintain context continuity Metadata: Extract and store rich metadata for better filtering Batch Processing: Process documents in batches for better performance Error Handling: Implement robust error handling and retry mechanisms 2. Performance Optimization Concurrent Processing: Use worker pools for parallel document processing Embedding Caching: Cache embeddings to avoid recomputation Index Optimization: Optimize vector database indexes for your query patterns Memory Management: Monitor memory usage during large batch operations 3. Quality Assurance Content Validation: Validate document content before ingestion Duplicate Detection: Implement deduplication to avoid redundant storage Quality Metrics: Track ingestion quality and search relevance Regular Maintenance: Periodically clean up and optimize the knowledge base Conclusion Document ingestion and knowledge base management are critical for building effective RAG systems. By implementing proper chunking strategies, metadata extraction, and optimization techniques, you can create knowledge bases that provide accurate and relevant information to your agents.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="document-ingestion :: AgenticGoKit Docs">
    <meta name="twitter:description" content="Document Ingestion and Knowledge Base Management Overview Document ingestion is a critical component of building comprehensive knowledge bases in AgenticGoKit. This tutorial covers the complete pipeline from raw documents to searchable knowledge, including document processing, chunking strategies, metadata extraction, and optimization techniques.
Effective document ingestion enables agents to access and reason over large collections of structured and unstructured data.
Prerequisites Understanding of Memory Systems Overview Familiarity with Vector Databases Knowledge of document formats (PDF, Markdown, HTML, etc.) Basic understanding of text processing and NLP concepts Document Ingestion Pipeline Architecture Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Raw │───▶│ Document │───▶│ Text ││ Documents │ │ Parser │ │ Extraction │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Vector │◀───│ Embedding │◀───│ Text ││ Storage │ │ Generation │ │ Chunking │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐│ Metadata ││ Extraction │└─────────────────┘Document Types and Processing 1. Supported Document Types // Document types supported by AgenticGoKit const ( DocumentTypePDF DocumentType = &#34;pdf&#34; DocumentTypeText DocumentType = &#34;txt&#34; DocumentTypeMarkdown DocumentType = &#34;md&#34; DocumentTypeWeb DocumentType = &#34;web&#34; DocumentTypeCode DocumentType = &#34;code&#34; DocumentTypeJSON DocumentType = &#34;json&#34; ) // Document structure for ingestion type Document struct { ID string `json:&#34;id&#34;` Title string `json:&#34;title,omitempty&#34;` Content string `json:&#34;content&#34;` Source string `json:&#34;source,omitempty&#34;` // URL, file path, etc. Type DocumentType `json:&#34;type,omitempty&#34;` Metadata map[string]any `json:&#34;metadata,omitempty&#34;` Tags []string `json:&#34;tags,omitempty&#34;` CreatedAt time.Time `json:&#34;created_at&#34;` UpdatedAt time.Time `json:&#34;updated_at,omitempty&#34;` ChunkIndex int `json:&#34;chunk_index,omitempty&#34;` // For chunked documents ChunkTotal int `json:&#34;chunk_total,omitempty&#34;` }2. Basic Document Ingestion package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func ingestBasicDocument(memory core.Memory) error { ctx := context.Background() // Create a document doc := core.Document{ ID: &#34;doc-001&#34;, Title: &#34;Introduction to Machine Learning&#34;, Content: `Machine learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed for every task. It involves algorithms that can identify patterns, make predictions, and improve their performance over time.`, Source: &#34;textbook-chapter-1.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 1, &#34;subject&#34;: &#34;machine-learning&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, &#34;language&#34;: &#34;english&#34;, }, Tags: []string{&#34;ml&#34;, &#34;ai&#34;, &#34;introduction&#34;}, CreatedAt: time.Now(), } // Ingest the document err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest document: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested document: %s\n&#34;, doc.Title) return nil }3. Batch Document Ingestion func ingestMultipleDocuments(memory core.Memory) error { ctx := context.Background() // Prepare multiple documents documents := []core.Document{ { ID: &#34;doc-002&#34;, Title: &#34;Neural Networks Fundamentals&#34;, Content: &#34;Neural networks are computing systems inspired by biological neural networks...&#34;, Source: &#34;textbook-chapter-2.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 2, &#34;subject&#34;: &#34;neural-networks&#34;, &#34;difficulty&#34;: &#34;intermediate&#34;, }, Tags: []string{&#34;neural-networks&#34;, &#34;deep-learning&#34;}, }, { ID: &#34;doc-003&#34;, Title: &#34;Data Preprocessing Techniques&#34;, Content: &#34;Data preprocessing is a crucial step in machine learning pipelines...&#34;, Source: &#34;textbook-chapter-3.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 3, &#34;subject&#34;: &#34;data-preprocessing&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, }, Tags: []string{&#34;data-science&#34;, &#34;preprocessing&#34;}, }, } // Batch ingest documents err := memory.IngestDocuments(ctx, documents) if err != nil { return fmt.Errorf(&#34;failed to ingest documents: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested %d documents\n&#34;, len(documents)) return nil }Text Chunking Strategies 1. Fixed-Size Chunking type FixedSizeChunker struct { ChunkSize int ChunkOverlap int } func NewFixedSizeChunker(chunkSize, overlap int) *FixedSizeChunker { return &amp;FixedSizeChunker{ ChunkSize: chunkSize, ChunkOverlap: overlap, } } func (c *FixedSizeChunker) ChunkText(text string) []string { if len(text) &lt;= c.ChunkSize { return []string{text} } var chunks []string start := 0 for start &lt; len(text) { end := start &#43; c.ChunkSize if end &gt; len(text) { end = len(text) } chunk := text[start:end] chunks = append(chunks, chunk) // Move start position considering overlap start &#43;= c.ChunkSize - c.ChunkOverlap if start &gt;= len(text) { break } } return chunks } // Example usage func chunkLargeDocument(memory core.Memory, largeText string) error { ctx := context.Background() chunker := NewFixedSizeChunker(1000, 200) chunks := chunker.ChunkText(largeText) for i, chunk := range chunks { doc := core.Document{ ID: fmt.Sprintf(&#34;large-doc-chunk-%d&#34;, i), Title: fmt.Sprintf(&#34;Large Document - Chunk %d&#34;, i&#43;1), Content: chunk, Source: &#34;large-document.pdf&#34;, Type: core.DocumentTypePDF, ChunkIndex: i, ChunkTotal: len(chunks), Metadata: map[string]any{ &#34;chunk_method&#34;: &#34;fixed-size&#34;, &#34;chunk_size&#34;: 1000, &#34;chunk_overlap&#34;: 200, }, CreatedAt: time.Now(), } err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest chunk %d: %w&#34;, i, err) } } return nil }2. Semantic Chunking type SemanticChunker struct { MaxChunkSize int MinChunkSize int } func NewSemanticChunker(minSize, maxSize int) *SemanticChunker { return &amp;SemanticChunker{ MinChunkSize: minSize, MaxChunkSize: maxSize, } } func (c *SemanticChunker) ChunkText(text string) []string { // Split by paragraphs first paragraphs := strings.Split(text, &#34;\n\n&#34;) var chunks []string var currentChunk strings.Builder for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed max size if currentChunk.Len() &gt; 0 &amp;&amp; currentChunk.Len()&#43;len(paragraph) &gt; c.MaxChunkSize { // Finalize current chunk if it meets minimum size if currentChunk.Len() &gt;= c.MinChunkSize { chunks = append(chunks, currentChunk.String()) currentChunk.Reset() } } // Add paragraph to current chunk if currentChunk.Len() &gt; 0 { currentChunk.WriteString(&#34;\n\n&#34;) } currentChunk.WriteString(paragraph) } // Add final chunk if it has content if currentChunk.Len() &gt; 0 { chunks = append(chunks, currentChunk.String()) } return chunks }3. Sentence-Based Chunking type SentenceChunker struct { MaxSentences int Overlap int } func NewSentenceChunker(maxSentences, overlap int) *SentenceChunker { return &amp;SentenceChunker{ MaxSentences: maxSentences, Overlap: overlap, } } func (c *SentenceChunker) ChunkText(text string) []string { sentences := c.splitIntoSentences(text) if len(sentences) &lt;= c.MaxSentences { return []string{text} } var chunks []string start := 0 for start &lt; len(sentences) { end := start &#43; c.MaxSentences if end &gt; len(sentences) { end = len(sentences) } chunk := strings.Join(sentences[start:end], &#34; &#34;) chunks = append(chunks, chunk) start &#43;= c.MaxSentences - c.Overlap if start &gt;= len(sentences) { break } } return chunks } func (c *SentenceChunker) splitIntoSentences(text string) []string { // Simple sentence splitting (in production, use a proper NLP library) sentences := strings.FieldsFunc(text, func(r rune) bool { return r == &#39;.&#39; || r == &#39;!&#39; || r == &#39;?&#39; }) // Clean up sentences var cleanSentences []string for _, sentence := range sentences { sentence = strings.TrimSpace(sentence) if len(sentence) &gt; 10 { // Filter out very short fragments cleanSentences = append(cleanSentences, sentence) } } return cleanSentences }Advanced Document Processing 1. Document Processor with Multiple Strategies type DocumentProcessor struct { memory core.Memory chunkers map[string]TextChunker extractors map[core.DocumentType]MetadataExtractor config ProcessorConfig } type TextChunker interface { ChunkText(text string) []string } type MetadataExtractor interface { ExtractMetadata(doc core.Document) (map[string]any, error) } type ProcessorConfig struct { DefaultChunkStrategy string MaxConcurrentDocs int EnableMetadataExtraction bool EnableContentCleaning bool } func NewDocumentProcessor(memory core.Memory, config ProcessorConfig) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, chunkers: make(map[string]TextChunker), extractors: make(map[core.DocumentType]MetadataExtractor), config: config, } // Register default chunkers dp.chunkers[&#34;fixed&#34;] = NewFixedSizeChunker(1000, 200) dp.chunkers[&#34;semantic&#34;] = NewSemanticChunker(500, 1500) dp.chunkers[&#34;sentence&#34;] = NewSentenceChunker(10, 2) // Register metadata extractors dp.extractors[core.DocumentTypePDF] = &amp;PDFMetadataExtractor{} dp.extractors[core.DocumentTypeMarkdown] = &amp;MarkdownMetadataExtractor{} dp.extractors[core.DocumentTypeCode] = &amp;CodeMetadataExtractor{} return dp } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc core.Document, chunkStrategy string) error { // Clean content if enabled if dp.config.EnableContentCleaning { doc.Content = dp.cleanContent(doc.Content) } // Extract metadata if enabled if dp.config.EnableMetadataExtraction { if extractor, exists := dp.extractors[doc.Type]; exists { metadata, err := extractor.ExtractMetadata(doc) if err == nil { // Merge extracted metadata with existing if doc.Metadata == nil { doc.Metadata = make(map[string]any) } for k, v := range metadata { doc.Metadata[k] = v } } } } // Choose chunking strategy if chunkStrategy == &#34;&#34; { chunkStrategy = dp.config.DefaultChunkStrategy } chunker, exists := dp.chunkers[chunkStrategy] if !exists { return fmt.Errorf(&#34;unknown chunking strategy: %s&#34;, chunkStrategy) } // Chunk the document chunks := chunker.ChunkText(doc.Content) // Process chunks if len(chunks) == 1 { // Single chunk - ingest as-is return dp.memory.IngestDocument(ctx, doc) } // Multiple chunks - create separate documents var documents []core.Document for i, chunk := range chunks { chunkDoc := doc // Copy original document chunkDoc.ID = fmt.Sprintf(&#34;%s-chunk-%d&#34;, doc.ID, i) chunkDoc.Content = chunk chunkDoc.ChunkIndex = i chunkDoc.ChunkTotal = len(chunks) // Add chunking metadata if chunkDoc.Metadata == nil { chunkDoc.Metadata = make(map[string]any) } chunkDoc.Metadata[&#34;chunk_strategy&#34;] = chunkStrategy chunkDoc.Metadata[&#34;original_doc_id&#34;] = doc.ID documents = append(documents, chunkDoc) } return dp.memory.IngestDocuments(ctx, documents) } func (dp *DocumentProcessor) cleanContent(content string) string { // Remove excessive whitespace content = regexp.MustCompile(`\s&#43;`).ReplaceAllString(content, &#34; &#34;) // Remove special characters that might interfere with processing content = regexp.MustCompile(`[^\w\s\.,!?;:()\-&#34;&#39;]`).ReplaceAllString(content, &#34;&#34;) // Trim whitespace content = strings.TrimSpace(content) return content }2. Metadata Extractors // PDF Metadata Extractor type PDFMetadataExtractor struct{} func (e *PDFMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract basic statistics metadata[&#34;word_count&#34;] = len(strings.Fields(doc.Content)) metadata[&#34;char_count&#34;] = len(doc.Content) metadata[&#34;paragraph_count&#34;] = len(strings.Split(doc.Content, &#34;\n\n&#34;)) // Extract potential headings (lines that are short and followed by longer content) lines := strings.Split(doc.Content, &#34;\n&#34;) var headings []string for i, line := range lines { line = strings.TrimSpace(line) if len(line) &gt; 0 &amp;&amp; len(line) &lt; 100 &amp;&amp; i&#43;1 &lt; len(lines) { nextLine := strings.TrimSpace(lines[i&#43;1]) if len(nextLine) &gt; len(line)*2 { headings = append(headings, line) } } } metadata[&#34;potential_headings&#34;] = headings // Detect language (simple heuristic) metadata[&#34;detected_language&#34;] = detectLanguage(doc.Content) return metadata, nil } // Markdown Metadata Extractor type MarkdownMetadataExtractor struct{} func (e *MarkdownMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract headings headings := extractMarkdownHeadings(doc.Content) metadata[&#34;headings&#34;] = headings metadata[&#34;heading_count&#34;] = len(headings) // Extract links links := extractMarkdownLinks(doc.Content) metadata[&#34;links&#34;] = links metadata[&#34;link_count&#34;] = len(links) // Extract code blocks codeBlocks := extractMarkdownCodeBlocks(doc.Content) metadata[&#34;code_blocks&#34;] = len(codeBlocks) // Extract front matter if present frontMatter := extractFrontMatter(doc.Content) if frontMatter != nil { metadata[&#34;front_matter&#34;] = frontMatter } return metadata, nil } // Code Metadata Extractor type CodeMetadataExtractor struct{} func (e *CodeMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Detect programming language language := detectProgrammingLanguage(doc.Source, doc.Content) metadata[&#34;programming_language&#34;] = language // Count lines of code lines := strings.Split(doc.Content, &#34;\n&#34;) metadata[&#34;total_lines&#34;] = len(lines) // Count non-empty lines nonEmptyLines := 0 commentLines := 0 for _, line := range lines { line = strings.TrimSpace(line) if line != &#34;&#34; { nonEmptyLines&#43;&#43; if isCommentLine(line, language) { commentLines&#43;&#43; } } } metadata[&#34;code_lines&#34;] = nonEmptyLines metadata[&#34;comment_lines&#34;] = commentLines // Extract functions/methods (basic pattern matching) functions := extractFunctions(doc.Content, language) metadata[&#34;functions&#34;] = functions metadata[&#34;function_count&#34;] = len(functions) return metadata, nil } // Helper functions for metadata extraction func detectLanguage(content string) string { // Simple language detection based on common words englishWords := []string{&#34;the&#34;, &#34;and&#34;, &#34;is&#34;, &#34;in&#34;, &#34;to&#34;, &#34;of&#34;, &#34;a&#34;, &#34;that&#34;, &#34;it&#34;, &#34;with&#34;} words := strings.Fields(strings.ToLower(content)) englishCount := 0 for _, word := range words { for _, englishWord := range englishWords { if word == englishWord { englishCount&#43;&#43; break } } } if float64(englishCount)/float64(len(words)) &gt; 0.1 { return &#34;english&#34; } return &#34;unknown&#34; } func extractMarkdownHeadings(content string) []string { var headings []string lines := strings.Split(content, &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;#&#34;) { headings = append(headings, line) } } return headings } func extractMarkdownLinks(content string) []string { // Simple regex for markdown links [text](url) linkRegex := regexp.MustCompile(`\[([^\]]&#43;)\]\(([^)]&#43;)\)`) matches := linkRegex.FindAllStringSubmatch(content, -1) var links []string for _, match := range matches { if len(match) &gt;= 3 { links = append(links, match[2]) // URL part } } return links } func extractMarkdownCodeBlocks(content string) []string { // Simple extraction of code blocks codeBlockRegex := regexp.MustCompile(&#34;```[\\s\\S]*?```&#34;) matches := codeBlockRegex.FindAllString(content, -1) return matches } func extractFrontMatter(content string) map[string]any { // Extract YAML front matter if !strings.HasPrefix(content, &#34;---&#34;) { return nil } parts := strings.SplitN(content, &#34;---&#34;, 3) if len(parts) &lt; 3 { return nil } // Simple key-value extraction (in production, use a YAML parser) frontMatter := make(map[string]any) lines := strings.Split(parts[1], &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.Contains(line, &#34;:&#34;) { parts := strings.SplitN(line, &#34;:&#34;, 2) if len(parts) == 2 { key := strings.TrimSpace(parts[0]) value := strings.TrimSpace(parts[1]) frontMatter[key] = value } } } return frontMatter } func detectProgrammingLanguage(filename, content string) string { // Detect by file extension ext := strings.ToLower(filepath.Ext(filename)) switch ext { case &#34;.go&#34;: return &#34;go&#34; case &#34;.py&#34;: return &#34;python&#34; case &#34;.js&#34;: return &#34;javascript&#34; case &#34;.ts&#34;: return &#34;typescript&#34; case &#34;.java&#34;: return &#34;java&#34; case &#34;.cpp&#34;, &#34;.cc&#34;, &#34;.cxx&#34;: return &#34;cpp&#34; case &#34;.c&#34;: return &#34;c&#34; case &#34;.rs&#34;: return &#34;rust&#34; } // Detect by content patterns if strings.Contains(content, &#34;package main&#34;) || strings.Contains(content, &#34;func &#34;) { return &#34;go&#34; } if strings.Contains(content, &#34;def &#34;) || strings.Contains(content, &#34;import &#34;) { return &#34;python&#34; } return &#34;unknown&#34; } func isCommentLine(line, language string) bool { switch language { case &#34;go&#34;, &#34;javascript&#34;, &#34;typescript&#34;, &#34;java&#34;, &#34;cpp&#34;, &#34;c&#34;, &#34;rust&#34;: return strings.HasPrefix(line, &#34;//&#34;) || strings.HasPrefix(line, &#34;/*&#34;) case &#34;python&#34;: return strings.HasPrefix(line, &#34;#&#34;) } return false } func extractFunctions(content, language string) []string { var functions []string switch language { case &#34;go&#34;: funcRegex := regexp.MustCompile(`func\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;python&#34;: funcRegex := regexp.MustCompile(`def\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;javascript&#34;, &#34;typescript&#34;: funcRegex := regexp.MustCompile(`function\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } } return functions }Knowledge Base Search and Retrieval 1. Advanced Search with Filters func performAdvancedKnowledgeSearch(memory core.Memory) error { ctx := context.Background() // Search with multiple filters results, err := memory.SearchKnowledge(ctx, &#34;machine learning algorithms&#34;, core.WithLimit(10), core.WithScoreThreshold(0.7), core.WithSources([]string{&#34;textbook-chapter-1.pdf&#34;, &#34;textbook-chapter-2.pdf&#34;}), core.WithDocumentTypes([]core.DocumentType{core.DocumentTypePDF}), core.WithTags([]string{&#34;ml&#34;, &#34;algorithms&#34;}), core.WithDateRange(&amp;core.DateRange{ Start: time.Now().Add(-30 * 24 * time.Hour), End: time.Now(), }), ) if err != nil { return fmt.Errorf(&#34;knowledge search failed: %w&#34;, err) } fmt.Printf(&#34;Found %d relevant knowledge items:\n&#34;, len(results)) for _, result := range results { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, result.Title, result.Score) fmt.Printf(&#34; Source: %s\n&#34;, result.Source) fmt.Printf(&#34; Content: %s...\n&#34;, truncateString(result.Content, 100)) if result.ChunkIndex &gt; 0 { fmt.Printf(&#34; Chunk: %d/%d\n&#34;, result.ChunkIndex&#43;1, result.ChunkTotal) } fmt.Println() } return nil } func truncateString(s string, maxLen int) string { if len(s) &lt;= maxLen { return s } return s[:maxLen] &#43; &#34;...&#34; }2. Hybrid Search (Personal &#43; Knowledge) func performHybridSearch(memory core.Memory) error { ctx := context.Context() // Perform hybrid search combining personal memory and knowledge base result, err := memory.SearchAll(ctx, &#34;neural network implementation&#34;, core.WithLimit(15), core.WithScoreThreshold(0.6), core.WithIncludePersonal(true), core.WithIncludeKnowledge(true), core.WithHybridWeight(0.7), // 70% semantic, 30% keyword ) if err != nil { return fmt.Errorf(&#34;hybrid search failed: %w&#34;, err) } fmt.Printf(&#34;Hybrid Search Results for: %s\n&#34;, result.Query) fmt.Printf(&#34;Total Results: %d (Search Time: %v)\n\n&#34;, result.TotalResults, result.SearchTime) // Display personal memory results if len(result.PersonalMemory) &gt; 0 { fmt.Println(&#34;Personal Memory Results:&#34;) for _, item := range result.PersonalMemory { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, truncateString(item.Content, 80), item.Score) } fmt.Println() } // Display knowledge base results if len(result.Knowledge) &gt; 0 { fmt.Println(&#34;Knowledge Base Results:&#34;) for _, item := range result.Knowledge { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, item.Title, item.Score) fmt.Printf(&#34; Source: %s\n&#34;, item.Source) } } return nil }3. RAG Context Building func buildRAGContext(memory core.Memory, query string) error { ctx := context.Background() // Build comprehensive RAG context ragContext, err := memory.BuildContext(ctx, query, core.WithMaxTokens(4000), core.WithPersonalWeight(0.3), core.WithKnowledgeWeight(0.7), core.WithHistoryLimit(5), core.WithIncludeSources(true), core.WithFormatTemplate(`Context Information: Personal Memory: {{range .PersonalMemory}} - {{.Content}} {{end}} Knowledge Base: {{range .Knowledge}} - {{.Content}} (Source: {{.Source}}) {{end}} Recent Conversation: {{range .ChatHistory}} {{.Role}}: {{.Content}} {{end}} Query: {{.Query}}`), ) if err != nil { return fmt.Errorf(&#34;failed to build RAG context: %w&#34;, err) } fmt.Printf(&#34;RAG Context for: %s\n&#34;, ragContext.Query) fmt.Printf(&#34;Token Count: %d\n&#34;, ragContext.TokenCount) fmt.Printf(&#34;Sources: %v\n&#34;, ragContext.Sources) fmt.Printf(&#34;Context Text:\n%s\n&#34;, ragContext.ContextText) return nil }Production Optimization 1. Batch Processing Pipeline type BatchProcessor struct { memory core.Memory processor *DocumentProcessor concurrency int batchSize int } func NewBatchProcessor(memory core.Memory, concurrency, batchSize int) *BatchProcessor { return &amp;BatchProcessor{ memory: memory, processor: NewDocumentProcessor(memory, ProcessorConfig{ DefaultChunkStrategy: &#34;semantic&#34;, MaxConcurrentDocs: concurrency, EnableMetadataExtraction: true, EnableContentCleaning: true, }), concurrency: concurrency, batchSize: batchSize, } } func (bp *BatchProcessor) ProcessDocuments(ctx context.Context, documents []core.Document) error { // Process documents in batches for i := 0; i &lt; len(documents); i &#43;= bp.batchSize { end := i &#43; bp.batchSize if end &gt; len(documents) { end = len(documents) } batch := documents[i:end] err := bp.processBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to process batch %d-%d: %w&#34;, i, end-1, err) } fmt.Printf(&#34;Processed batch %d-%d (%d documents)\n&#34;, i, end-1, len(batch)) } return nil } func (bp *BatchProcessor) processBatch(ctx context.Context, documents []core.Document) error { // Use worker pool for concurrent processing jobs := make(chan core.Document, len(documents)) results := make(chan error, len(documents)) // Start workers for w := 0; w &lt; bp.concurrency; w&#43;&#43; { go bp.worker(ctx, jobs, results) } // Send jobs for _, doc := range documents { jobs &lt;- doc } close(jobs) // Collect results var errors []error for i := 0; i &lt; len(documents); i&#43;&#43; { if err := &lt;-results; err != nil { errors = append(errors, err) } } if len(errors) &gt; 0 { return fmt.Errorf(&#34;batch processing failed with %d errors: %v&#34;, len(errors), errors[0]) } return nil } func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan core.Document, results chan&lt;- error) { for doc := range jobs { err := bp.processor.ProcessDocument(ctx, doc, &#34;&#34;) results &lt;- err } }2. Performance Monitoring type IngestionMetrics struct { DocumentsProcessed int64 `json:&#34;documents_processed&#34;` ChunksCreated int64 `json:&#34;chunks_created&#34;` ProcessingTime time.Duration `json:&#34;processing_time&#34;` ErrorCount int64 `json:&#34;error_count&#34;` AverageChunkSize float64 `json:&#34;average_chunk_size&#34;` mu sync.RWMutex } func (m *IngestionMetrics) RecordDocument(chunkCount int, processingTime time.Duration, chunkSizes []int) { m.mu.Lock() defer m.mu.Unlock() m.DocumentsProcessed&#43;&#43; m.ChunksCreated &#43;= int64(chunkCount) m.ProcessingTime &#43;= processingTime // Update average chunk size if len(chunkSizes) &gt; 0 { totalSize := 0 for _, size := range chunkSizes { totalSize &#43;= size } avgSize := float64(totalSize) / float64(len(chunkSizes)) // Running average totalChunks := float64(m.ChunksCreated) m.AverageChunkSize = (m.AverageChunkSize*(totalChunks-float64(chunkCount)) &#43; avgSize*float64(chunkCount)) / totalChunks } } func (m *IngestionMetrics) RecordError() { m.mu.Lock() defer m.mu.Unlock() m.ErrorCount&#43;&#43; } func (m *IngestionMetrics) GetStats() IngestionMetrics { m.mu.RLock() defer m.mu.RUnlock() return IngestionMetrics{ DocumentsProcessed: m.DocumentsProcessed, ChunksCreated: m.ChunksCreated, ProcessingTime: m.ProcessingTime, ErrorCount: m.ErrorCount, AverageChunkSize: m.AverageChunkSize, } }Best Practices 1. Document Ingestion Guidelines Chunk Size: Balance between context preservation and retrieval precision Overlap: Use 10-20% overlap to maintain context continuity Metadata: Extract and store rich metadata for better filtering Batch Processing: Process documents in batches for better performance Error Handling: Implement robust error handling and retry mechanisms 2. Performance Optimization Concurrent Processing: Use worker pools for parallel document processing Embedding Caching: Cache embeddings to avoid recomputation Index Optimization: Optimize vector database indexes for your query patterns Memory Management: Monitor memory usage during large batch operations 3. Quality Assurance Content Validation: Validate document content before ingestion Duplicate Detection: Implement deduplication to avoid redundant storage Quality Metrics: Track ingestion quality and search relevance Regular Maintenance: Periodically clean up and optimize the knowledge base Conclusion Document ingestion and knowledge base management are critical for building effective RAG systems. By implementing proper chunking strategies, metadata extraction, and optimization techniques, you can create knowledge bases that provide accurate and relevant information to your agents.">
    <meta property="og:url" content="http://localhost:1313/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">
    <meta property="og:site_name" content="AgenticGoKit Docs">
    <meta property="og:title" content="document-ingestion :: AgenticGoKit Docs">
    <meta property="og:description" content="Document Ingestion and Knowledge Base Management Overview Document ingestion is a critical component of building comprehensive knowledge bases in AgenticGoKit. This tutorial covers the complete pipeline from raw documents to searchable knowledge, including document processing, chunking strategies, metadata extraction, and optimization techniques.
Effective document ingestion enables agents to access and reason over large collections of structured and unstructured data.
Prerequisites Understanding of Memory Systems Overview Familiarity with Vector Databases Knowledge of document formats (PDF, Markdown, HTML, etc.) Basic understanding of text processing and NLP concepts Document Ingestion Pipeline Architecture Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Raw │───▶│ Document │───▶│ Text ││ Documents │ │ Parser │ │ Extraction │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Vector │◀───│ Embedding │◀───│ Text ││ Storage │ │ Generation │ │ Chunking │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐│ Metadata ││ Extraction │└─────────────────┘Document Types and Processing 1. Supported Document Types // Document types supported by AgenticGoKit const ( DocumentTypePDF DocumentType = &#34;pdf&#34; DocumentTypeText DocumentType = &#34;txt&#34; DocumentTypeMarkdown DocumentType = &#34;md&#34; DocumentTypeWeb DocumentType = &#34;web&#34; DocumentTypeCode DocumentType = &#34;code&#34; DocumentTypeJSON DocumentType = &#34;json&#34; ) // Document structure for ingestion type Document struct { ID string `json:&#34;id&#34;` Title string `json:&#34;title,omitempty&#34;` Content string `json:&#34;content&#34;` Source string `json:&#34;source,omitempty&#34;` // URL, file path, etc. Type DocumentType `json:&#34;type,omitempty&#34;` Metadata map[string]any `json:&#34;metadata,omitempty&#34;` Tags []string `json:&#34;tags,omitempty&#34;` CreatedAt time.Time `json:&#34;created_at&#34;` UpdatedAt time.Time `json:&#34;updated_at,omitempty&#34;` ChunkIndex int `json:&#34;chunk_index,omitempty&#34;` // For chunked documents ChunkTotal int `json:&#34;chunk_total,omitempty&#34;` }2. Basic Document Ingestion package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func ingestBasicDocument(memory core.Memory) error { ctx := context.Background() // Create a document doc := core.Document{ ID: &#34;doc-001&#34;, Title: &#34;Introduction to Machine Learning&#34;, Content: `Machine learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed for every task. It involves algorithms that can identify patterns, make predictions, and improve their performance over time.`, Source: &#34;textbook-chapter-1.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 1, &#34;subject&#34;: &#34;machine-learning&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, &#34;language&#34;: &#34;english&#34;, }, Tags: []string{&#34;ml&#34;, &#34;ai&#34;, &#34;introduction&#34;}, CreatedAt: time.Now(), } // Ingest the document err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest document: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested document: %s\n&#34;, doc.Title) return nil }3. Batch Document Ingestion func ingestMultipleDocuments(memory core.Memory) error { ctx := context.Background() // Prepare multiple documents documents := []core.Document{ { ID: &#34;doc-002&#34;, Title: &#34;Neural Networks Fundamentals&#34;, Content: &#34;Neural networks are computing systems inspired by biological neural networks...&#34;, Source: &#34;textbook-chapter-2.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 2, &#34;subject&#34;: &#34;neural-networks&#34;, &#34;difficulty&#34;: &#34;intermediate&#34;, }, Tags: []string{&#34;neural-networks&#34;, &#34;deep-learning&#34;}, }, { ID: &#34;doc-003&#34;, Title: &#34;Data Preprocessing Techniques&#34;, Content: &#34;Data preprocessing is a crucial step in machine learning pipelines...&#34;, Source: &#34;textbook-chapter-3.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 3, &#34;subject&#34;: &#34;data-preprocessing&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, }, Tags: []string{&#34;data-science&#34;, &#34;preprocessing&#34;}, }, } // Batch ingest documents err := memory.IngestDocuments(ctx, documents) if err != nil { return fmt.Errorf(&#34;failed to ingest documents: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested %d documents\n&#34;, len(documents)) return nil }Text Chunking Strategies 1. Fixed-Size Chunking type FixedSizeChunker struct { ChunkSize int ChunkOverlap int } func NewFixedSizeChunker(chunkSize, overlap int) *FixedSizeChunker { return &amp;FixedSizeChunker{ ChunkSize: chunkSize, ChunkOverlap: overlap, } } func (c *FixedSizeChunker) ChunkText(text string) []string { if len(text) &lt;= c.ChunkSize { return []string{text} } var chunks []string start := 0 for start &lt; len(text) { end := start &#43; c.ChunkSize if end &gt; len(text) { end = len(text) } chunk := text[start:end] chunks = append(chunks, chunk) // Move start position considering overlap start &#43;= c.ChunkSize - c.ChunkOverlap if start &gt;= len(text) { break } } return chunks } // Example usage func chunkLargeDocument(memory core.Memory, largeText string) error { ctx := context.Background() chunker := NewFixedSizeChunker(1000, 200) chunks := chunker.ChunkText(largeText) for i, chunk := range chunks { doc := core.Document{ ID: fmt.Sprintf(&#34;large-doc-chunk-%d&#34;, i), Title: fmt.Sprintf(&#34;Large Document - Chunk %d&#34;, i&#43;1), Content: chunk, Source: &#34;large-document.pdf&#34;, Type: core.DocumentTypePDF, ChunkIndex: i, ChunkTotal: len(chunks), Metadata: map[string]any{ &#34;chunk_method&#34;: &#34;fixed-size&#34;, &#34;chunk_size&#34;: 1000, &#34;chunk_overlap&#34;: 200, }, CreatedAt: time.Now(), } err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest chunk %d: %w&#34;, i, err) } } return nil }2. Semantic Chunking type SemanticChunker struct { MaxChunkSize int MinChunkSize int } func NewSemanticChunker(minSize, maxSize int) *SemanticChunker { return &amp;SemanticChunker{ MinChunkSize: minSize, MaxChunkSize: maxSize, } } func (c *SemanticChunker) ChunkText(text string) []string { // Split by paragraphs first paragraphs := strings.Split(text, &#34;\n\n&#34;) var chunks []string var currentChunk strings.Builder for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed max size if currentChunk.Len() &gt; 0 &amp;&amp; currentChunk.Len()&#43;len(paragraph) &gt; c.MaxChunkSize { // Finalize current chunk if it meets minimum size if currentChunk.Len() &gt;= c.MinChunkSize { chunks = append(chunks, currentChunk.String()) currentChunk.Reset() } } // Add paragraph to current chunk if currentChunk.Len() &gt; 0 { currentChunk.WriteString(&#34;\n\n&#34;) } currentChunk.WriteString(paragraph) } // Add final chunk if it has content if currentChunk.Len() &gt; 0 { chunks = append(chunks, currentChunk.String()) } return chunks }3. Sentence-Based Chunking type SentenceChunker struct { MaxSentences int Overlap int } func NewSentenceChunker(maxSentences, overlap int) *SentenceChunker { return &amp;SentenceChunker{ MaxSentences: maxSentences, Overlap: overlap, } } func (c *SentenceChunker) ChunkText(text string) []string { sentences := c.splitIntoSentences(text) if len(sentences) &lt;= c.MaxSentences { return []string{text} } var chunks []string start := 0 for start &lt; len(sentences) { end := start &#43; c.MaxSentences if end &gt; len(sentences) { end = len(sentences) } chunk := strings.Join(sentences[start:end], &#34; &#34;) chunks = append(chunks, chunk) start &#43;= c.MaxSentences - c.Overlap if start &gt;= len(sentences) { break } } return chunks } func (c *SentenceChunker) splitIntoSentences(text string) []string { // Simple sentence splitting (in production, use a proper NLP library) sentences := strings.FieldsFunc(text, func(r rune) bool { return r == &#39;.&#39; || r == &#39;!&#39; || r == &#39;?&#39; }) // Clean up sentences var cleanSentences []string for _, sentence := range sentences { sentence = strings.TrimSpace(sentence) if len(sentence) &gt; 10 { // Filter out very short fragments cleanSentences = append(cleanSentences, sentence) } } return cleanSentences }Advanced Document Processing 1. Document Processor with Multiple Strategies type DocumentProcessor struct { memory core.Memory chunkers map[string]TextChunker extractors map[core.DocumentType]MetadataExtractor config ProcessorConfig } type TextChunker interface { ChunkText(text string) []string } type MetadataExtractor interface { ExtractMetadata(doc core.Document) (map[string]any, error) } type ProcessorConfig struct { DefaultChunkStrategy string MaxConcurrentDocs int EnableMetadataExtraction bool EnableContentCleaning bool } func NewDocumentProcessor(memory core.Memory, config ProcessorConfig) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, chunkers: make(map[string]TextChunker), extractors: make(map[core.DocumentType]MetadataExtractor), config: config, } // Register default chunkers dp.chunkers[&#34;fixed&#34;] = NewFixedSizeChunker(1000, 200) dp.chunkers[&#34;semantic&#34;] = NewSemanticChunker(500, 1500) dp.chunkers[&#34;sentence&#34;] = NewSentenceChunker(10, 2) // Register metadata extractors dp.extractors[core.DocumentTypePDF] = &amp;PDFMetadataExtractor{} dp.extractors[core.DocumentTypeMarkdown] = &amp;MarkdownMetadataExtractor{} dp.extractors[core.DocumentTypeCode] = &amp;CodeMetadataExtractor{} return dp } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc core.Document, chunkStrategy string) error { // Clean content if enabled if dp.config.EnableContentCleaning { doc.Content = dp.cleanContent(doc.Content) } // Extract metadata if enabled if dp.config.EnableMetadataExtraction { if extractor, exists := dp.extractors[doc.Type]; exists { metadata, err := extractor.ExtractMetadata(doc) if err == nil { // Merge extracted metadata with existing if doc.Metadata == nil { doc.Metadata = make(map[string]any) } for k, v := range metadata { doc.Metadata[k] = v } } } } // Choose chunking strategy if chunkStrategy == &#34;&#34; { chunkStrategy = dp.config.DefaultChunkStrategy } chunker, exists := dp.chunkers[chunkStrategy] if !exists { return fmt.Errorf(&#34;unknown chunking strategy: %s&#34;, chunkStrategy) } // Chunk the document chunks := chunker.ChunkText(doc.Content) // Process chunks if len(chunks) == 1 { // Single chunk - ingest as-is return dp.memory.IngestDocument(ctx, doc) } // Multiple chunks - create separate documents var documents []core.Document for i, chunk := range chunks { chunkDoc := doc // Copy original document chunkDoc.ID = fmt.Sprintf(&#34;%s-chunk-%d&#34;, doc.ID, i) chunkDoc.Content = chunk chunkDoc.ChunkIndex = i chunkDoc.ChunkTotal = len(chunks) // Add chunking metadata if chunkDoc.Metadata == nil { chunkDoc.Metadata = make(map[string]any) } chunkDoc.Metadata[&#34;chunk_strategy&#34;] = chunkStrategy chunkDoc.Metadata[&#34;original_doc_id&#34;] = doc.ID documents = append(documents, chunkDoc) } return dp.memory.IngestDocuments(ctx, documents) } func (dp *DocumentProcessor) cleanContent(content string) string { // Remove excessive whitespace content = regexp.MustCompile(`\s&#43;`).ReplaceAllString(content, &#34; &#34;) // Remove special characters that might interfere with processing content = regexp.MustCompile(`[^\w\s\.,!?;:()\-&#34;&#39;]`).ReplaceAllString(content, &#34;&#34;) // Trim whitespace content = strings.TrimSpace(content) return content }2. Metadata Extractors // PDF Metadata Extractor type PDFMetadataExtractor struct{} func (e *PDFMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract basic statistics metadata[&#34;word_count&#34;] = len(strings.Fields(doc.Content)) metadata[&#34;char_count&#34;] = len(doc.Content) metadata[&#34;paragraph_count&#34;] = len(strings.Split(doc.Content, &#34;\n\n&#34;)) // Extract potential headings (lines that are short and followed by longer content) lines := strings.Split(doc.Content, &#34;\n&#34;) var headings []string for i, line := range lines { line = strings.TrimSpace(line) if len(line) &gt; 0 &amp;&amp; len(line) &lt; 100 &amp;&amp; i&#43;1 &lt; len(lines) { nextLine := strings.TrimSpace(lines[i&#43;1]) if len(nextLine) &gt; len(line)*2 { headings = append(headings, line) } } } metadata[&#34;potential_headings&#34;] = headings // Detect language (simple heuristic) metadata[&#34;detected_language&#34;] = detectLanguage(doc.Content) return metadata, nil } // Markdown Metadata Extractor type MarkdownMetadataExtractor struct{} func (e *MarkdownMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract headings headings := extractMarkdownHeadings(doc.Content) metadata[&#34;headings&#34;] = headings metadata[&#34;heading_count&#34;] = len(headings) // Extract links links := extractMarkdownLinks(doc.Content) metadata[&#34;links&#34;] = links metadata[&#34;link_count&#34;] = len(links) // Extract code blocks codeBlocks := extractMarkdownCodeBlocks(doc.Content) metadata[&#34;code_blocks&#34;] = len(codeBlocks) // Extract front matter if present frontMatter := extractFrontMatter(doc.Content) if frontMatter != nil { metadata[&#34;front_matter&#34;] = frontMatter } return metadata, nil } // Code Metadata Extractor type CodeMetadataExtractor struct{} func (e *CodeMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Detect programming language language := detectProgrammingLanguage(doc.Source, doc.Content) metadata[&#34;programming_language&#34;] = language // Count lines of code lines := strings.Split(doc.Content, &#34;\n&#34;) metadata[&#34;total_lines&#34;] = len(lines) // Count non-empty lines nonEmptyLines := 0 commentLines := 0 for _, line := range lines { line = strings.TrimSpace(line) if line != &#34;&#34; { nonEmptyLines&#43;&#43; if isCommentLine(line, language) { commentLines&#43;&#43; } } } metadata[&#34;code_lines&#34;] = nonEmptyLines metadata[&#34;comment_lines&#34;] = commentLines // Extract functions/methods (basic pattern matching) functions := extractFunctions(doc.Content, language) metadata[&#34;functions&#34;] = functions metadata[&#34;function_count&#34;] = len(functions) return metadata, nil } // Helper functions for metadata extraction func detectLanguage(content string) string { // Simple language detection based on common words englishWords := []string{&#34;the&#34;, &#34;and&#34;, &#34;is&#34;, &#34;in&#34;, &#34;to&#34;, &#34;of&#34;, &#34;a&#34;, &#34;that&#34;, &#34;it&#34;, &#34;with&#34;} words := strings.Fields(strings.ToLower(content)) englishCount := 0 for _, word := range words { for _, englishWord := range englishWords { if word == englishWord { englishCount&#43;&#43; break } } } if float64(englishCount)/float64(len(words)) &gt; 0.1 { return &#34;english&#34; } return &#34;unknown&#34; } func extractMarkdownHeadings(content string) []string { var headings []string lines := strings.Split(content, &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;#&#34;) { headings = append(headings, line) } } return headings } func extractMarkdownLinks(content string) []string { // Simple regex for markdown links [text](url) linkRegex := regexp.MustCompile(`\[([^\]]&#43;)\]\(([^)]&#43;)\)`) matches := linkRegex.FindAllStringSubmatch(content, -1) var links []string for _, match := range matches { if len(match) &gt;= 3 { links = append(links, match[2]) // URL part } } return links } func extractMarkdownCodeBlocks(content string) []string { // Simple extraction of code blocks codeBlockRegex := regexp.MustCompile(&#34;```[\\s\\S]*?```&#34;) matches := codeBlockRegex.FindAllString(content, -1) return matches } func extractFrontMatter(content string) map[string]any { // Extract YAML front matter if !strings.HasPrefix(content, &#34;---&#34;) { return nil } parts := strings.SplitN(content, &#34;---&#34;, 3) if len(parts) &lt; 3 { return nil } // Simple key-value extraction (in production, use a YAML parser) frontMatter := make(map[string]any) lines := strings.Split(parts[1], &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.Contains(line, &#34;:&#34;) { parts := strings.SplitN(line, &#34;:&#34;, 2) if len(parts) == 2 { key := strings.TrimSpace(parts[0]) value := strings.TrimSpace(parts[1]) frontMatter[key] = value } } } return frontMatter } func detectProgrammingLanguage(filename, content string) string { // Detect by file extension ext := strings.ToLower(filepath.Ext(filename)) switch ext { case &#34;.go&#34;: return &#34;go&#34; case &#34;.py&#34;: return &#34;python&#34; case &#34;.js&#34;: return &#34;javascript&#34; case &#34;.ts&#34;: return &#34;typescript&#34; case &#34;.java&#34;: return &#34;java&#34; case &#34;.cpp&#34;, &#34;.cc&#34;, &#34;.cxx&#34;: return &#34;cpp&#34; case &#34;.c&#34;: return &#34;c&#34; case &#34;.rs&#34;: return &#34;rust&#34; } // Detect by content patterns if strings.Contains(content, &#34;package main&#34;) || strings.Contains(content, &#34;func &#34;) { return &#34;go&#34; } if strings.Contains(content, &#34;def &#34;) || strings.Contains(content, &#34;import &#34;) { return &#34;python&#34; } return &#34;unknown&#34; } func isCommentLine(line, language string) bool { switch language { case &#34;go&#34;, &#34;javascript&#34;, &#34;typescript&#34;, &#34;java&#34;, &#34;cpp&#34;, &#34;c&#34;, &#34;rust&#34;: return strings.HasPrefix(line, &#34;//&#34;) || strings.HasPrefix(line, &#34;/*&#34;) case &#34;python&#34;: return strings.HasPrefix(line, &#34;#&#34;) } return false } func extractFunctions(content, language string) []string { var functions []string switch language { case &#34;go&#34;: funcRegex := regexp.MustCompile(`func\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;python&#34;: funcRegex := regexp.MustCompile(`def\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;javascript&#34;, &#34;typescript&#34;: funcRegex := regexp.MustCompile(`function\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } } return functions }Knowledge Base Search and Retrieval 1. Advanced Search with Filters func performAdvancedKnowledgeSearch(memory core.Memory) error { ctx := context.Background() // Search with multiple filters results, err := memory.SearchKnowledge(ctx, &#34;machine learning algorithms&#34;, core.WithLimit(10), core.WithScoreThreshold(0.7), core.WithSources([]string{&#34;textbook-chapter-1.pdf&#34;, &#34;textbook-chapter-2.pdf&#34;}), core.WithDocumentTypes([]core.DocumentType{core.DocumentTypePDF}), core.WithTags([]string{&#34;ml&#34;, &#34;algorithms&#34;}), core.WithDateRange(&amp;core.DateRange{ Start: time.Now().Add(-30 * 24 * time.Hour), End: time.Now(), }), ) if err != nil { return fmt.Errorf(&#34;knowledge search failed: %w&#34;, err) } fmt.Printf(&#34;Found %d relevant knowledge items:\n&#34;, len(results)) for _, result := range results { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, result.Title, result.Score) fmt.Printf(&#34; Source: %s\n&#34;, result.Source) fmt.Printf(&#34; Content: %s...\n&#34;, truncateString(result.Content, 100)) if result.ChunkIndex &gt; 0 { fmt.Printf(&#34; Chunk: %d/%d\n&#34;, result.ChunkIndex&#43;1, result.ChunkTotal) } fmt.Println() } return nil } func truncateString(s string, maxLen int) string { if len(s) &lt;= maxLen { return s } return s[:maxLen] &#43; &#34;...&#34; }2. Hybrid Search (Personal &#43; Knowledge) func performHybridSearch(memory core.Memory) error { ctx := context.Context() // Perform hybrid search combining personal memory and knowledge base result, err := memory.SearchAll(ctx, &#34;neural network implementation&#34;, core.WithLimit(15), core.WithScoreThreshold(0.6), core.WithIncludePersonal(true), core.WithIncludeKnowledge(true), core.WithHybridWeight(0.7), // 70% semantic, 30% keyword ) if err != nil { return fmt.Errorf(&#34;hybrid search failed: %w&#34;, err) } fmt.Printf(&#34;Hybrid Search Results for: %s\n&#34;, result.Query) fmt.Printf(&#34;Total Results: %d (Search Time: %v)\n\n&#34;, result.TotalResults, result.SearchTime) // Display personal memory results if len(result.PersonalMemory) &gt; 0 { fmt.Println(&#34;Personal Memory Results:&#34;) for _, item := range result.PersonalMemory { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, truncateString(item.Content, 80), item.Score) } fmt.Println() } // Display knowledge base results if len(result.Knowledge) &gt; 0 { fmt.Println(&#34;Knowledge Base Results:&#34;) for _, item := range result.Knowledge { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, item.Title, item.Score) fmt.Printf(&#34; Source: %s\n&#34;, item.Source) } } return nil }3. RAG Context Building func buildRAGContext(memory core.Memory, query string) error { ctx := context.Background() // Build comprehensive RAG context ragContext, err := memory.BuildContext(ctx, query, core.WithMaxTokens(4000), core.WithPersonalWeight(0.3), core.WithKnowledgeWeight(0.7), core.WithHistoryLimit(5), core.WithIncludeSources(true), core.WithFormatTemplate(`Context Information: Personal Memory: {{range .PersonalMemory}} - {{.Content}} {{end}} Knowledge Base: {{range .Knowledge}} - {{.Content}} (Source: {{.Source}}) {{end}} Recent Conversation: {{range .ChatHistory}} {{.Role}}: {{.Content}} {{end}} Query: {{.Query}}`), ) if err != nil { return fmt.Errorf(&#34;failed to build RAG context: %w&#34;, err) } fmt.Printf(&#34;RAG Context for: %s\n&#34;, ragContext.Query) fmt.Printf(&#34;Token Count: %d\n&#34;, ragContext.TokenCount) fmt.Printf(&#34;Sources: %v\n&#34;, ragContext.Sources) fmt.Printf(&#34;Context Text:\n%s\n&#34;, ragContext.ContextText) return nil }Production Optimization 1. Batch Processing Pipeline type BatchProcessor struct { memory core.Memory processor *DocumentProcessor concurrency int batchSize int } func NewBatchProcessor(memory core.Memory, concurrency, batchSize int) *BatchProcessor { return &amp;BatchProcessor{ memory: memory, processor: NewDocumentProcessor(memory, ProcessorConfig{ DefaultChunkStrategy: &#34;semantic&#34;, MaxConcurrentDocs: concurrency, EnableMetadataExtraction: true, EnableContentCleaning: true, }), concurrency: concurrency, batchSize: batchSize, } } func (bp *BatchProcessor) ProcessDocuments(ctx context.Context, documents []core.Document) error { // Process documents in batches for i := 0; i &lt; len(documents); i &#43;= bp.batchSize { end := i &#43; bp.batchSize if end &gt; len(documents) { end = len(documents) } batch := documents[i:end] err := bp.processBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to process batch %d-%d: %w&#34;, i, end-1, err) } fmt.Printf(&#34;Processed batch %d-%d (%d documents)\n&#34;, i, end-1, len(batch)) } return nil } func (bp *BatchProcessor) processBatch(ctx context.Context, documents []core.Document) error { // Use worker pool for concurrent processing jobs := make(chan core.Document, len(documents)) results := make(chan error, len(documents)) // Start workers for w := 0; w &lt; bp.concurrency; w&#43;&#43; { go bp.worker(ctx, jobs, results) } // Send jobs for _, doc := range documents { jobs &lt;- doc } close(jobs) // Collect results var errors []error for i := 0; i &lt; len(documents); i&#43;&#43; { if err := &lt;-results; err != nil { errors = append(errors, err) } } if len(errors) &gt; 0 { return fmt.Errorf(&#34;batch processing failed with %d errors: %v&#34;, len(errors), errors[0]) } return nil } func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan core.Document, results chan&lt;- error) { for doc := range jobs { err := bp.processor.ProcessDocument(ctx, doc, &#34;&#34;) results &lt;- err } }2. Performance Monitoring type IngestionMetrics struct { DocumentsProcessed int64 `json:&#34;documents_processed&#34;` ChunksCreated int64 `json:&#34;chunks_created&#34;` ProcessingTime time.Duration `json:&#34;processing_time&#34;` ErrorCount int64 `json:&#34;error_count&#34;` AverageChunkSize float64 `json:&#34;average_chunk_size&#34;` mu sync.RWMutex } func (m *IngestionMetrics) RecordDocument(chunkCount int, processingTime time.Duration, chunkSizes []int) { m.mu.Lock() defer m.mu.Unlock() m.DocumentsProcessed&#43;&#43; m.ChunksCreated &#43;= int64(chunkCount) m.ProcessingTime &#43;= processingTime // Update average chunk size if len(chunkSizes) &gt; 0 { totalSize := 0 for _, size := range chunkSizes { totalSize &#43;= size } avgSize := float64(totalSize) / float64(len(chunkSizes)) // Running average totalChunks := float64(m.ChunksCreated) m.AverageChunkSize = (m.AverageChunkSize*(totalChunks-float64(chunkCount)) &#43; avgSize*float64(chunkCount)) / totalChunks } } func (m *IngestionMetrics) RecordError() { m.mu.Lock() defer m.mu.Unlock() m.ErrorCount&#43;&#43; } func (m *IngestionMetrics) GetStats() IngestionMetrics { m.mu.RLock() defer m.mu.RUnlock() return IngestionMetrics{ DocumentsProcessed: m.DocumentsProcessed, ChunksCreated: m.ChunksCreated, ProcessingTime: m.ProcessingTime, ErrorCount: m.ErrorCount, AverageChunkSize: m.AverageChunkSize, } }Best Practices 1. Document Ingestion Guidelines Chunk Size: Balance between context preservation and retrieval precision Overlap: Use 10-20% overlap to maintain context continuity Metadata: Extract and store rich metadata for better filtering Batch Processing: Process documents in batches for better performance Error Handling: Implement robust error handling and retry mechanisms 2. Performance Optimization Concurrent Processing: Use worker pools for parallel document processing Embedding Caching: Cache embeddings to avoid recomputation Index Optimization: Optimize vector database indexes for your query patterns Memory Management: Monitor memory usage during large batch operations 3. Quality Assurance Content Validation: Validate document content before ingestion Duplicate Detection: Implement deduplication to avoid redundant storage Quality Metrics: Track ingestion quality and search relevance Regular Maintenance: Periodically clean up and optimize the knowledge base Conclusion Document ingestion and knowledge base management are critical for building effective RAG systems. By implementing proper chunking strategies, metadata extraction, and optimization techniques, you can create knowledge bases that provide accurate and relevant information to your agents.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="tutorials">
    <meta property="article:published_time" content="2025-07-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="name" content="document-ingestion :: AgenticGoKit Docs">
    <meta itemprop="description" content="Document Ingestion and Knowledge Base Management Overview Document ingestion is a critical component of building comprehensive knowledge bases in AgenticGoKit. This tutorial covers the complete pipeline from raw documents to searchable knowledge, including document processing, chunking strategies, metadata extraction, and optimization techniques.
Effective document ingestion enables agents to access and reason over large collections of structured and unstructured data.
Prerequisites Understanding of Memory Systems Overview Familiarity with Vector Databases Knowledge of document formats (PDF, Markdown, HTML, etc.) Basic understanding of text processing and NLP concepts Document Ingestion Pipeline Architecture Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Raw │───▶│ Document │───▶│ Text ││ Documents │ │ Parser │ │ Extraction │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Vector │◀───│ Embedding │◀───│ Text ││ Storage │ │ Generation │ │ Chunking │└─────────────────┘ └──────────────────┘ └─────────────────┘│▼┌─────────────────┐│ Metadata ││ Extraction │└─────────────────┘Document Types and Processing 1. Supported Document Types // Document types supported by AgenticGoKit const ( DocumentTypePDF DocumentType = &#34;pdf&#34; DocumentTypeText DocumentType = &#34;txt&#34; DocumentTypeMarkdown DocumentType = &#34;md&#34; DocumentTypeWeb DocumentType = &#34;web&#34; DocumentTypeCode DocumentType = &#34;code&#34; DocumentTypeJSON DocumentType = &#34;json&#34; ) // Document structure for ingestion type Document struct { ID string `json:&#34;id&#34;` Title string `json:&#34;title,omitempty&#34;` Content string `json:&#34;content&#34;` Source string `json:&#34;source,omitempty&#34;` // URL, file path, etc. Type DocumentType `json:&#34;type,omitempty&#34;` Metadata map[string]any `json:&#34;metadata,omitempty&#34;` Tags []string `json:&#34;tags,omitempty&#34;` CreatedAt time.Time `json:&#34;created_at&#34;` UpdatedAt time.Time `json:&#34;updated_at,omitempty&#34;` ChunkIndex int `json:&#34;chunk_index,omitempty&#34;` // For chunked documents ChunkTotal int `json:&#34;chunk_total,omitempty&#34;` }2. Basic Document Ingestion package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) func ingestBasicDocument(memory core.Memory) error { ctx := context.Background() // Create a document doc := core.Document{ ID: &#34;doc-001&#34;, Title: &#34;Introduction to Machine Learning&#34;, Content: `Machine learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed for every task. It involves algorithms that can identify patterns, make predictions, and improve their performance over time.`, Source: &#34;textbook-chapter-1.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 1, &#34;subject&#34;: &#34;machine-learning&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, &#34;language&#34;: &#34;english&#34;, }, Tags: []string{&#34;ml&#34;, &#34;ai&#34;, &#34;introduction&#34;}, CreatedAt: time.Now(), } // Ingest the document err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest document: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested document: %s\n&#34;, doc.Title) return nil }3. Batch Document Ingestion func ingestMultipleDocuments(memory core.Memory) error { ctx := context.Background() // Prepare multiple documents documents := []core.Document{ { ID: &#34;doc-002&#34;, Title: &#34;Neural Networks Fundamentals&#34;, Content: &#34;Neural networks are computing systems inspired by biological neural networks...&#34;, Source: &#34;textbook-chapter-2.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 2, &#34;subject&#34;: &#34;neural-networks&#34;, &#34;difficulty&#34;: &#34;intermediate&#34;, }, Tags: []string{&#34;neural-networks&#34;, &#34;deep-learning&#34;}, }, { ID: &#34;doc-003&#34;, Title: &#34;Data Preprocessing Techniques&#34;, Content: &#34;Data preprocessing is a crucial step in machine learning pipelines...&#34;, Source: &#34;textbook-chapter-3.pdf&#34;, Type: core.DocumentTypePDF, Metadata: map[string]any{ &#34;author&#34;: &#34;Dr. Jane Smith&#34;, &#34;chapter&#34;: 3, &#34;subject&#34;: &#34;data-preprocessing&#34;, &#34;difficulty&#34;: &#34;beginner&#34;, }, Tags: []string{&#34;data-science&#34;, &#34;preprocessing&#34;}, }, } // Batch ingest documents err := memory.IngestDocuments(ctx, documents) if err != nil { return fmt.Errorf(&#34;failed to ingest documents: %w&#34;, err) } fmt.Printf(&#34;Successfully ingested %d documents\n&#34;, len(documents)) return nil }Text Chunking Strategies 1. Fixed-Size Chunking type FixedSizeChunker struct { ChunkSize int ChunkOverlap int } func NewFixedSizeChunker(chunkSize, overlap int) *FixedSizeChunker { return &amp;FixedSizeChunker{ ChunkSize: chunkSize, ChunkOverlap: overlap, } } func (c *FixedSizeChunker) ChunkText(text string) []string { if len(text) &lt;= c.ChunkSize { return []string{text} } var chunks []string start := 0 for start &lt; len(text) { end := start &#43; c.ChunkSize if end &gt; len(text) { end = len(text) } chunk := text[start:end] chunks = append(chunks, chunk) // Move start position considering overlap start &#43;= c.ChunkSize - c.ChunkOverlap if start &gt;= len(text) { break } } return chunks } // Example usage func chunkLargeDocument(memory core.Memory, largeText string) error { ctx := context.Background() chunker := NewFixedSizeChunker(1000, 200) chunks := chunker.ChunkText(largeText) for i, chunk := range chunks { doc := core.Document{ ID: fmt.Sprintf(&#34;large-doc-chunk-%d&#34;, i), Title: fmt.Sprintf(&#34;Large Document - Chunk %d&#34;, i&#43;1), Content: chunk, Source: &#34;large-document.pdf&#34;, Type: core.DocumentTypePDF, ChunkIndex: i, ChunkTotal: len(chunks), Metadata: map[string]any{ &#34;chunk_method&#34;: &#34;fixed-size&#34;, &#34;chunk_size&#34;: 1000, &#34;chunk_overlap&#34;: 200, }, CreatedAt: time.Now(), } err := memory.IngestDocument(ctx, doc) if err != nil { return fmt.Errorf(&#34;failed to ingest chunk %d: %w&#34;, i, err) } } return nil }2. Semantic Chunking type SemanticChunker struct { MaxChunkSize int MinChunkSize int } func NewSemanticChunker(minSize, maxSize int) *SemanticChunker { return &amp;SemanticChunker{ MinChunkSize: minSize, MaxChunkSize: maxSize, } } func (c *SemanticChunker) ChunkText(text string) []string { // Split by paragraphs first paragraphs := strings.Split(text, &#34;\n\n&#34;) var chunks []string var currentChunk strings.Builder for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed max size if currentChunk.Len() &gt; 0 &amp;&amp; currentChunk.Len()&#43;len(paragraph) &gt; c.MaxChunkSize { // Finalize current chunk if it meets minimum size if currentChunk.Len() &gt;= c.MinChunkSize { chunks = append(chunks, currentChunk.String()) currentChunk.Reset() } } // Add paragraph to current chunk if currentChunk.Len() &gt; 0 { currentChunk.WriteString(&#34;\n\n&#34;) } currentChunk.WriteString(paragraph) } // Add final chunk if it has content if currentChunk.Len() &gt; 0 { chunks = append(chunks, currentChunk.String()) } return chunks }3. Sentence-Based Chunking type SentenceChunker struct { MaxSentences int Overlap int } func NewSentenceChunker(maxSentences, overlap int) *SentenceChunker { return &amp;SentenceChunker{ MaxSentences: maxSentences, Overlap: overlap, } } func (c *SentenceChunker) ChunkText(text string) []string { sentences := c.splitIntoSentences(text) if len(sentences) &lt;= c.MaxSentences { return []string{text} } var chunks []string start := 0 for start &lt; len(sentences) { end := start &#43; c.MaxSentences if end &gt; len(sentences) { end = len(sentences) } chunk := strings.Join(sentences[start:end], &#34; &#34;) chunks = append(chunks, chunk) start &#43;= c.MaxSentences - c.Overlap if start &gt;= len(sentences) { break } } return chunks } func (c *SentenceChunker) splitIntoSentences(text string) []string { // Simple sentence splitting (in production, use a proper NLP library) sentences := strings.FieldsFunc(text, func(r rune) bool { return r == &#39;.&#39; || r == &#39;!&#39; || r == &#39;?&#39; }) // Clean up sentences var cleanSentences []string for _, sentence := range sentences { sentence = strings.TrimSpace(sentence) if len(sentence) &gt; 10 { // Filter out very short fragments cleanSentences = append(cleanSentences, sentence) } } return cleanSentences }Advanced Document Processing 1. Document Processor with Multiple Strategies type DocumentProcessor struct { memory core.Memory chunkers map[string]TextChunker extractors map[core.DocumentType]MetadataExtractor config ProcessorConfig } type TextChunker interface { ChunkText(text string) []string } type MetadataExtractor interface { ExtractMetadata(doc core.Document) (map[string]any, error) } type ProcessorConfig struct { DefaultChunkStrategy string MaxConcurrentDocs int EnableMetadataExtraction bool EnableContentCleaning bool } func NewDocumentProcessor(memory core.Memory, config ProcessorConfig) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, chunkers: make(map[string]TextChunker), extractors: make(map[core.DocumentType]MetadataExtractor), config: config, } // Register default chunkers dp.chunkers[&#34;fixed&#34;] = NewFixedSizeChunker(1000, 200) dp.chunkers[&#34;semantic&#34;] = NewSemanticChunker(500, 1500) dp.chunkers[&#34;sentence&#34;] = NewSentenceChunker(10, 2) // Register metadata extractors dp.extractors[core.DocumentTypePDF] = &amp;PDFMetadataExtractor{} dp.extractors[core.DocumentTypeMarkdown] = &amp;MarkdownMetadataExtractor{} dp.extractors[core.DocumentTypeCode] = &amp;CodeMetadataExtractor{} return dp } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc core.Document, chunkStrategy string) error { // Clean content if enabled if dp.config.EnableContentCleaning { doc.Content = dp.cleanContent(doc.Content) } // Extract metadata if enabled if dp.config.EnableMetadataExtraction { if extractor, exists := dp.extractors[doc.Type]; exists { metadata, err := extractor.ExtractMetadata(doc) if err == nil { // Merge extracted metadata with existing if doc.Metadata == nil { doc.Metadata = make(map[string]any) } for k, v := range metadata { doc.Metadata[k] = v } } } } // Choose chunking strategy if chunkStrategy == &#34;&#34; { chunkStrategy = dp.config.DefaultChunkStrategy } chunker, exists := dp.chunkers[chunkStrategy] if !exists { return fmt.Errorf(&#34;unknown chunking strategy: %s&#34;, chunkStrategy) } // Chunk the document chunks := chunker.ChunkText(doc.Content) // Process chunks if len(chunks) == 1 { // Single chunk - ingest as-is return dp.memory.IngestDocument(ctx, doc) } // Multiple chunks - create separate documents var documents []core.Document for i, chunk := range chunks { chunkDoc := doc // Copy original document chunkDoc.ID = fmt.Sprintf(&#34;%s-chunk-%d&#34;, doc.ID, i) chunkDoc.Content = chunk chunkDoc.ChunkIndex = i chunkDoc.ChunkTotal = len(chunks) // Add chunking metadata if chunkDoc.Metadata == nil { chunkDoc.Metadata = make(map[string]any) } chunkDoc.Metadata[&#34;chunk_strategy&#34;] = chunkStrategy chunkDoc.Metadata[&#34;original_doc_id&#34;] = doc.ID documents = append(documents, chunkDoc) } return dp.memory.IngestDocuments(ctx, documents) } func (dp *DocumentProcessor) cleanContent(content string) string { // Remove excessive whitespace content = regexp.MustCompile(`\s&#43;`).ReplaceAllString(content, &#34; &#34;) // Remove special characters that might interfere with processing content = regexp.MustCompile(`[^\w\s\.,!?;:()\-&#34;&#39;]`).ReplaceAllString(content, &#34;&#34;) // Trim whitespace content = strings.TrimSpace(content) return content }2. Metadata Extractors // PDF Metadata Extractor type PDFMetadataExtractor struct{} func (e *PDFMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract basic statistics metadata[&#34;word_count&#34;] = len(strings.Fields(doc.Content)) metadata[&#34;char_count&#34;] = len(doc.Content) metadata[&#34;paragraph_count&#34;] = len(strings.Split(doc.Content, &#34;\n\n&#34;)) // Extract potential headings (lines that are short and followed by longer content) lines := strings.Split(doc.Content, &#34;\n&#34;) var headings []string for i, line := range lines { line = strings.TrimSpace(line) if len(line) &gt; 0 &amp;&amp; len(line) &lt; 100 &amp;&amp; i&#43;1 &lt; len(lines) { nextLine := strings.TrimSpace(lines[i&#43;1]) if len(nextLine) &gt; len(line)*2 { headings = append(headings, line) } } } metadata[&#34;potential_headings&#34;] = headings // Detect language (simple heuristic) metadata[&#34;detected_language&#34;] = detectLanguage(doc.Content) return metadata, nil } // Markdown Metadata Extractor type MarkdownMetadataExtractor struct{} func (e *MarkdownMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Extract headings headings := extractMarkdownHeadings(doc.Content) metadata[&#34;headings&#34;] = headings metadata[&#34;heading_count&#34;] = len(headings) // Extract links links := extractMarkdownLinks(doc.Content) metadata[&#34;links&#34;] = links metadata[&#34;link_count&#34;] = len(links) // Extract code blocks codeBlocks := extractMarkdownCodeBlocks(doc.Content) metadata[&#34;code_blocks&#34;] = len(codeBlocks) // Extract front matter if present frontMatter := extractFrontMatter(doc.Content) if frontMatter != nil { metadata[&#34;front_matter&#34;] = frontMatter } return metadata, nil } // Code Metadata Extractor type CodeMetadataExtractor struct{} func (e *CodeMetadataExtractor) ExtractMetadata(doc core.Document) (map[string]any, error) { metadata := make(map[string]any) // Detect programming language language := detectProgrammingLanguage(doc.Source, doc.Content) metadata[&#34;programming_language&#34;] = language // Count lines of code lines := strings.Split(doc.Content, &#34;\n&#34;) metadata[&#34;total_lines&#34;] = len(lines) // Count non-empty lines nonEmptyLines := 0 commentLines := 0 for _, line := range lines { line = strings.TrimSpace(line) if line != &#34;&#34; { nonEmptyLines&#43;&#43; if isCommentLine(line, language) { commentLines&#43;&#43; } } } metadata[&#34;code_lines&#34;] = nonEmptyLines metadata[&#34;comment_lines&#34;] = commentLines // Extract functions/methods (basic pattern matching) functions := extractFunctions(doc.Content, language) metadata[&#34;functions&#34;] = functions metadata[&#34;function_count&#34;] = len(functions) return metadata, nil } // Helper functions for metadata extraction func detectLanguage(content string) string { // Simple language detection based on common words englishWords := []string{&#34;the&#34;, &#34;and&#34;, &#34;is&#34;, &#34;in&#34;, &#34;to&#34;, &#34;of&#34;, &#34;a&#34;, &#34;that&#34;, &#34;it&#34;, &#34;with&#34;} words := strings.Fields(strings.ToLower(content)) englishCount := 0 for _, word := range words { for _, englishWord := range englishWords { if word == englishWord { englishCount&#43;&#43; break } } } if float64(englishCount)/float64(len(words)) &gt; 0.1 { return &#34;english&#34; } return &#34;unknown&#34; } func extractMarkdownHeadings(content string) []string { var headings []string lines := strings.Split(content, &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;#&#34;) { headings = append(headings, line) } } return headings } func extractMarkdownLinks(content string) []string { // Simple regex for markdown links [text](url) linkRegex := regexp.MustCompile(`\[([^\]]&#43;)\]\(([^)]&#43;)\)`) matches := linkRegex.FindAllStringSubmatch(content, -1) var links []string for _, match := range matches { if len(match) &gt;= 3 { links = append(links, match[2]) // URL part } } return links } func extractMarkdownCodeBlocks(content string) []string { // Simple extraction of code blocks codeBlockRegex := regexp.MustCompile(&#34;```[\\s\\S]*?```&#34;) matches := codeBlockRegex.FindAllString(content, -1) return matches } func extractFrontMatter(content string) map[string]any { // Extract YAML front matter if !strings.HasPrefix(content, &#34;---&#34;) { return nil } parts := strings.SplitN(content, &#34;---&#34;, 3) if len(parts) &lt; 3 { return nil } // Simple key-value extraction (in production, use a YAML parser) frontMatter := make(map[string]any) lines := strings.Split(parts[1], &#34;\n&#34;) for _, line := range lines { line = strings.TrimSpace(line) if strings.Contains(line, &#34;:&#34;) { parts := strings.SplitN(line, &#34;:&#34;, 2) if len(parts) == 2 { key := strings.TrimSpace(parts[0]) value := strings.TrimSpace(parts[1]) frontMatter[key] = value } } } return frontMatter } func detectProgrammingLanguage(filename, content string) string { // Detect by file extension ext := strings.ToLower(filepath.Ext(filename)) switch ext { case &#34;.go&#34;: return &#34;go&#34; case &#34;.py&#34;: return &#34;python&#34; case &#34;.js&#34;: return &#34;javascript&#34; case &#34;.ts&#34;: return &#34;typescript&#34; case &#34;.java&#34;: return &#34;java&#34; case &#34;.cpp&#34;, &#34;.cc&#34;, &#34;.cxx&#34;: return &#34;cpp&#34; case &#34;.c&#34;: return &#34;c&#34; case &#34;.rs&#34;: return &#34;rust&#34; } // Detect by content patterns if strings.Contains(content, &#34;package main&#34;) || strings.Contains(content, &#34;func &#34;) { return &#34;go&#34; } if strings.Contains(content, &#34;def &#34;) || strings.Contains(content, &#34;import &#34;) { return &#34;python&#34; } return &#34;unknown&#34; } func isCommentLine(line, language string) bool { switch language { case &#34;go&#34;, &#34;javascript&#34;, &#34;typescript&#34;, &#34;java&#34;, &#34;cpp&#34;, &#34;c&#34;, &#34;rust&#34;: return strings.HasPrefix(line, &#34;//&#34;) || strings.HasPrefix(line, &#34;/*&#34;) case &#34;python&#34;: return strings.HasPrefix(line, &#34;#&#34;) } return false } func extractFunctions(content, language string) []string { var functions []string switch language { case &#34;go&#34;: funcRegex := regexp.MustCompile(`func\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;python&#34;: funcRegex := regexp.MustCompile(`def\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } case &#34;javascript&#34;, &#34;typescript&#34;: funcRegex := regexp.MustCompile(`function\s&#43;(\w&#43;)\s*\(`) matches := funcRegex.FindAllStringSubmatch(content, -1) for _, match := range matches { if len(match) &gt;= 2 { functions = append(functions, match[1]) } } } return functions }Knowledge Base Search and Retrieval 1. Advanced Search with Filters func performAdvancedKnowledgeSearch(memory core.Memory) error { ctx := context.Background() // Search with multiple filters results, err := memory.SearchKnowledge(ctx, &#34;machine learning algorithms&#34;, core.WithLimit(10), core.WithScoreThreshold(0.7), core.WithSources([]string{&#34;textbook-chapter-1.pdf&#34;, &#34;textbook-chapter-2.pdf&#34;}), core.WithDocumentTypes([]core.DocumentType{core.DocumentTypePDF}), core.WithTags([]string{&#34;ml&#34;, &#34;algorithms&#34;}), core.WithDateRange(&amp;core.DateRange{ Start: time.Now().Add(-30 * 24 * time.Hour), End: time.Now(), }), ) if err != nil { return fmt.Errorf(&#34;knowledge search failed: %w&#34;, err) } fmt.Printf(&#34;Found %d relevant knowledge items:\n&#34;, len(results)) for _, result := range results { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, result.Title, result.Score) fmt.Printf(&#34; Source: %s\n&#34;, result.Source) fmt.Printf(&#34; Content: %s...\n&#34;, truncateString(result.Content, 100)) if result.ChunkIndex &gt; 0 { fmt.Printf(&#34; Chunk: %d/%d\n&#34;, result.ChunkIndex&#43;1, result.ChunkTotal) } fmt.Println() } return nil } func truncateString(s string, maxLen int) string { if len(s) &lt;= maxLen { return s } return s[:maxLen] &#43; &#34;...&#34; }2. Hybrid Search (Personal &#43; Knowledge) func performHybridSearch(memory core.Memory) error { ctx := context.Context() // Perform hybrid search combining personal memory and knowledge base result, err := memory.SearchAll(ctx, &#34;neural network implementation&#34;, core.WithLimit(15), core.WithScoreThreshold(0.6), core.WithIncludePersonal(true), core.WithIncludeKnowledge(true), core.WithHybridWeight(0.7), // 70% semantic, 30% keyword ) if err != nil { return fmt.Errorf(&#34;hybrid search failed: %w&#34;, err) } fmt.Printf(&#34;Hybrid Search Results for: %s\n&#34;, result.Query) fmt.Printf(&#34;Total Results: %d (Search Time: %v)\n\n&#34;, result.TotalResults, result.SearchTime) // Display personal memory results if len(result.PersonalMemory) &gt; 0 { fmt.Println(&#34;Personal Memory Results:&#34;) for _, item := range result.PersonalMemory { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, truncateString(item.Content, 80), item.Score) } fmt.Println() } // Display knowledge base results if len(result.Knowledge) &gt; 0 { fmt.Println(&#34;Knowledge Base Results:&#34;) for _, item := range result.Knowledge { fmt.Printf(&#34;- %s (Score: %.3f)\n&#34;, item.Title, item.Score) fmt.Printf(&#34; Source: %s\n&#34;, item.Source) } } return nil }3. RAG Context Building func buildRAGContext(memory core.Memory, query string) error { ctx := context.Background() // Build comprehensive RAG context ragContext, err := memory.BuildContext(ctx, query, core.WithMaxTokens(4000), core.WithPersonalWeight(0.3), core.WithKnowledgeWeight(0.7), core.WithHistoryLimit(5), core.WithIncludeSources(true), core.WithFormatTemplate(`Context Information: Personal Memory: {{range .PersonalMemory}} - {{.Content}} {{end}} Knowledge Base: {{range .Knowledge}} - {{.Content}} (Source: {{.Source}}) {{end}} Recent Conversation: {{range .ChatHistory}} {{.Role}}: {{.Content}} {{end}} Query: {{.Query}}`), ) if err != nil { return fmt.Errorf(&#34;failed to build RAG context: %w&#34;, err) } fmt.Printf(&#34;RAG Context for: %s\n&#34;, ragContext.Query) fmt.Printf(&#34;Token Count: %d\n&#34;, ragContext.TokenCount) fmt.Printf(&#34;Sources: %v\n&#34;, ragContext.Sources) fmt.Printf(&#34;Context Text:\n%s\n&#34;, ragContext.ContextText) return nil }Production Optimization 1. Batch Processing Pipeline type BatchProcessor struct { memory core.Memory processor *DocumentProcessor concurrency int batchSize int } func NewBatchProcessor(memory core.Memory, concurrency, batchSize int) *BatchProcessor { return &amp;BatchProcessor{ memory: memory, processor: NewDocumentProcessor(memory, ProcessorConfig{ DefaultChunkStrategy: &#34;semantic&#34;, MaxConcurrentDocs: concurrency, EnableMetadataExtraction: true, EnableContentCleaning: true, }), concurrency: concurrency, batchSize: batchSize, } } func (bp *BatchProcessor) ProcessDocuments(ctx context.Context, documents []core.Document) error { // Process documents in batches for i := 0; i &lt; len(documents); i &#43;= bp.batchSize { end := i &#43; bp.batchSize if end &gt; len(documents) { end = len(documents) } batch := documents[i:end] err := bp.processBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to process batch %d-%d: %w&#34;, i, end-1, err) } fmt.Printf(&#34;Processed batch %d-%d (%d documents)\n&#34;, i, end-1, len(batch)) } return nil } func (bp *BatchProcessor) processBatch(ctx context.Context, documents []core.Document) error { // Use worker pool for concurrent processing jobs := make(chan core.Document, len(documents)) results := make(chan error, len(documents)) // Start workers for w := 0; w &lt; bp.concurrency; w&#43;&#43; { go bp.worker(ctx, jobs, results) } // Send jobs for _, doc := range documents { jobs &lt;- doc } close(jobs) // Collect results var errors []error for i := 0; i &lt; len(documents); i&#43;&#43; { if err := &lt;-results; err != nil { errors = append(errors, err) } } if len(errors) &gt; 0 { return fmt.Errorf(&#34;batch processing failed with %d errors: %v&#34;, len(errors), errors[0]) } return nil } func (bp *BatchProcessor) worker(ctx context.Context, jobs &lt;-chan core.Document, results chan&lt;- error) { for doc := range jobs { err := bp.processor.ProcessDocument(ctx, doc, &#34;&#34;) results &lt;- err } }2. Performance Monitoring type IngestionMetrics struct { DocumentsProcessed int64 `json:&#34;documents_processed&#34;` ChunksCreated int64 `json:&#34;chunks_created&#34;` ProcessingTime time.Duration `json:&#34;processing_time&#34;` ErrorCount int64 `json:&#34;error_count&#34;` AverageChunkSize float64 `json:&#34;average_chunk_size&#34;` mu sync.RWMutex } func (m *IngestionMetrics) RecordDocument(chunkCount int, processingTime time.Duration, chunkSizes []int) { m.mu.Lock() defer m.mu.Unlock() m.DocumentsProcessed&#43;&#43; m.ChunksCreated &#43;= int64(chunkCount) m.ProcessingTime &#43;= processingTime // Update average chunk size if len(chunkSizes) &gt; 0 { totalSize := 0 for _, size := range chunkSizes { totalSize &#43;= size } avgSize := float64(totalSize) / float64(len(chunkSizes)) // Running average totalChunks := float64(m.ChunksCreated) m.AverageChunkSize = (m.AverageChunkSize*(totalChunks-float64(chunkCount)) &#43; avgSize*float64(chunkCount)) / totalChunks } } func (m *IngestionMetrics) RecordError() { m.mu.Lock() defer m.mu.Unlock() m.ErrorCount&#43;&#43; } func (m *IngestionMetrics) GetStats() IngestionMetrics { m.mu.RLock() defer m.mu.RUnlock() return IngestionMetrics{ DocumentsProcessed: m.DocumentsProcessed, ChunksCreated: m.ChunksCreated, ProcessingTime: m.ProcessingTime, ErrorCount: m.ErrorCount, AverageChunkSize: m.AverageChunkSize, } }Best Practices 1. Document Ingestion Guidelines Chunk Size: Balance between context preservation and retrieval precision Overlap: Use 10-20% overlap to maintain context continuity Metadata: Extract and store rich metadata for better filtering Batch Processing: Process documents in batches for better performance Error Handling: Implement robust error handling and retry mechanisms 2. Performance Optimization Concurrent Processing: Use worker pools for parallel document processing Embedding Caching: Cache embeddings to avoid recomputation Index Optimization: Optimize vector database indexes for your query patterns Memory Management: Monitor memory usage during large batch operations 3. Quality Assurance Content Validation: Validate document content before ingestion Duplicate Detection: Implement deduplication to avoid redundant storage Quality Metrics: Track ingestion quality and search relevance Regular Maintenance: Periodically clean up and optimize the knowledge base Conclusion Document ingestion and knowledge base management are critical for building effective RAG systems. By implementing proper chunking strategies, metadata extraction, and optimization techniques, you can create knowledge bases that provide accurate and relevant information to your agents.">
    <meta itemprop="datePublished" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="dateModified" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="wordCount" content="3048">
    <title>document-ingestion :: AgenticGoKit Docs</title>
    <link href="/AgenticGoKitDocs/css/auto-complete/auto-complete.min.css?1753430931" rel="stylesheet">
    <script src="/AgenticGoKitDocs/js/auto-complete/auto-complete.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search-lunr.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/AgenticGoKitDocs/searchindex.en.js?1753430931";
    </script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.stemmer.support.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.multi.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.en.min.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet"></noscript>
    <link href="/AgenticGoKitDocs/css/perfect-scrollbar/perfect-scrollbar.min.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/theme.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/format-html.css?1753430931" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/tutorials\/memory-systems\/document-ingestion\/index.html';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='http:\/\/localhost:1313\/AgenticGoKitDocs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'blue' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
  </head>
  <body class="mobile-support html" data-url="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#prerequisites">Prerequisites</a></li>
    <li><a href="#document-ingestion-pipeline">Document Ingestion Pipeline</a>
      <ul>
        <li><a href="#architecture-overview">Architecture Overview</a></li>
      </ul>
    </li>
    <li><a href="#document-types-and-processing">Document Types and Processing</a>
      <ul>
        <li><a href="#1-supported-document-types">1. Supported Document Types</a></li>
        <li><a href="#2-basic-document-ingestion">2. Basic Document Ingestion</a></li>
        <li><a href="#3-batch-document-ingestion">3. Batch Document Ingestion</a></li>
      </ul>
    </li>
    <li><a href="#text-chunking-strategies">Text Chunking Strategies</a>
      <ul>
        <li><a href="#1-fixed-size-chunking">1. Fixed-Size Chunking</a></li>
        <li><a href="#2-semantic-chunking">2. Semantic Chunking</a></li>
        <li><a href="#3-sentence-based-chunking">3. Sentence-Based Chunking</a></li>
      </ul>
    </li>
    <li><a href="#advanced-document-processing">Advanced Document Processing</a>
      <ul>
        <li><a href="#1-document-processor-with-multiple-strategies">1. Document Processor with Multiple Strategies</a></li>
        <li><a href="#2-metadata-extractors">2. Metadata Extractors</a></li>
      </ul>
    </li>
    <li><a href="#knowledge-base-search-and-retrieval">Knowledge Base Search and Retrieval</a>
      <ul>
        <li><a href="#1-advanced-search-with-filters">1. Advanced Search with Filters</a></li>
        <li><a href="#2-hybrid-search-personal--knowledge">2. Hybrid Search (Personal + Knowledge)</a></li>
        <li><a href="#3-rag-context-building">3. RAG Context Building</a></li>
      </ul>
    </li>
    <li><a href="#production-optimization">Production Optimization</a>
      <ul>
        <li><a href="#1-batch-processing-pipeline">1. Batch Processing Pipeline</a></li>
        <li><a href="#2-performance-monitoring">2. Performance Monitoring</a></li>
      </ul>
    </li>
    <li><a href="#best-practices">Best Practices</a>
      <ul>
        <li><a href="#1-document-ingestion-guidelines">1. Document Ingestion Guidelines</a></li>
        <li><a href="#2-performance-optimization">2. Performance Optimization</a></li>
        <li><a href="#3-quality-assurance">3. Quality Assurance</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#next-steps">Next Steps</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/index.html"><span itemprop="name">content</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/index.html"><span itemprop="name">tutorials</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><span itemprop="name">memory-systems</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">document-ingestion</span><meta itemprop="position" content="4"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html" title="basic-memory (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html" title="knowledge-bases (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable tutorials" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="document-ingestion">document-ingestion</h1>

<h1 id="document-ingestion-and-knowledge-base-management">Document Ingestion and Knowledge Base Management</h1>
<h2 id="overview">Overview</h2>
<p>Document ingestion is a critical component of building comprehensive knowledge bases in AgenticGoKit. This tutorial covers the complete pipeline from raw documents to searchable knowledge, including document processing, chunking strategies, metadata extraction, and optimization techniques.</p>
<p>Effective document ingestion enables agents to access and reason over large collections of structured and unstructured data.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Understanding of <a href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">Memory Systems Overview</a></li>
<li>Familiarity with <a href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">Vector Databases</a></li>
<li>Knowledge of document formats (PDF, Markdown, HTML, etc.)</li>
<li>Basic understanding of text processing and NLP concepts</li>
</ul>
<h2 id="document-ingestion-pipeline">Document Ingestion Pipeline</h2>
<h3 id="architecture-overview">Architecture Overview</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Raw           │───▶│   Document       │───▶│   Text          │
│   Documents     │    │   Parser         │    │   Extraction    │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                                        │
                                                        ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Vector        │◀───│   Embedding      │◀───│   Text          │
│   Storage       │    │   Generation     │    │   Chunking      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                                        │
                                                        ▼
                                                ┌─────────────────┐
                                                │   Metadata      │
                                                │   Extraction    │
                                                └─────────────────┘</code></pre></div>
<h2 id="document-types-and-processing">Document Types and Processing</h2>
<h3 id="1-supported-document-types">1. Supported Document Types</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Document types supported by AgenticGoKit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypePDF</span>      <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;pdf&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypeText</span>     <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;txt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypeMarkdown</span> <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;md&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypeWeb</span>      <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;web&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypeCode</span>     <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;code&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentTypeJSON</span>     <span style="color:#a6e22e">DocumentType</span> = <span style="color:#e6db74">&#34;json&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Document structure for ingestion</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Document</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ID</span>         <span style="color:#66d9ef">string</span>         <span style="color:#e6db74">`json:&#34;id&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Title</span>      <span style="color:#66d9ef">string</span>         <span style="color:#e6db74">`json:&#34;title,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Content</span>    <span style="color:#66d9ef">string</span>         <span style="color:#e6db74">`json:&#34;content&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Source</span>     <span style="color:#66d9ef">string</span>         <span style="color:#e6db74">`json:&#34;source,omitempty&#34;`</span> <span style="color:#75715e">// URL, file path, etc.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Type</span>       <span style="color:#a6e22e">DocumentType</span>   <span style="color:#e6db74">`json:&#34;type,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Metadata</span>   <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span> <span style="color:#e6db74">`json:&#34;metadata,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tags</span>       []<span style="color:#66d9ef">string</span>       <span style="color:#e6db74">`json:&#34;tags,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CreatedAt</span>  <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>      <span style="color:#e6db74">`json:&#34;created_at&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">UpdatedAt</span>  <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>      <span style="color:#e6db74">`json:&#34;updated_at,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkIndex</span> <span style="color:#66d9ef">int</span>            <span style="color:#e6db74">`json:&#34;chunk_index,omitempty&#34;`</span> <span style="color:#75715e">// For chunked documents</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkTotal</span> <span style="color:#66d9ef">int</span>            <span style="color:#e6db74">`json:&#34;chunk_total,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-basic-document-ingestion">2. Basic Document Ingestion</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/kunalkushwaha/agenticgokit/core&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ingestBasicDocument</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create a document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:      <span style="color:#e6db74">&#34;doc-001&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Title</span>:   <span style="color:#e6db74">&#34;Introduction to Machine Learning&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Content</span>: <span style="color:#e6db74">`Machine learning is a subset of artificial intelligence that enables computers to learn and make decisions from data without being explicitly programmed for every task. It involves algorithms that can identify patterns, make predictions, and improve their performance over time.`</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Source</span>:  <span style="color:#e6db74">&#34;textbook-chapter-1.pdf&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Type</span>:    <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;author&#34;</span>:     <span style="color:#e6db74">&#34;Dr. Jane Smith&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;chapter&#34;</span>:    <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;subject&#34;</span>:    <span style="color:#e6db74">&#34;machine-learning&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;difficulty&#34;</span>: <span style="color:#e6db74">&#34;beginner&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;language&#34;</span>:   <span style="color:#e6db74">&#34;english&#34;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Tags</span>:      []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;ml&#34;</span>, <span style="color:#e6db74">&#34;ai&#34;</span>, <span style="color:#e6db74">&#34;introduction&#34;</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CreatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ingest the document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">IngestDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to ingest document: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Successfully ingested document: %s\n&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Title</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="3-batch-document-ingestion">3. Batch Document Ingestion</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ingestMultipleDocuments</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prepare multiple documents</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">documents</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ID</span>:      <span style="color:#e6db74">&#34;doc-002&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Title</span>:   <span style="color:#e6db74">&#34;Neural Networks Fundamentals&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Content</span>: <span style="color:#e6db74">&#34;Neural networks are computing systems inspired by biological neural networks...&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Source</span>:  <span style="color:#e6db74">&#34;textbook-chapter-2.pdf&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:    <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;author&#34;</span>:     <span style="color:#e6db74">&#34;Dr. Jane Smith&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chapter&#34;</span>:    <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;subject&#34;</span>:    <span style="color:#e6db74">&#34;neural-networks&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;difficulty&#34;</span>: <span style="color:#e6db74">&#34;intermediate&#34;</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Tags</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;neural-networks&#34;</span>, <span style="color:#e6db74">&#34;deep-learning&#34;</span>},
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ID</span>:      <span style="color:#e6db74">&#34;doc-003&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Title</span>:   <span style="color:#e6db74">&#34;Data Preprocessing Techniques&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Content</span>: <span style="color:#e6db74">&#34;Data preprocessing is a crucial step in machine learning pipelines...&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Source</span>:  <span style="color:#e6db74">&#34;textbook-chapter-3.pdf&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:    <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;author&#34;</span>:     <span style="color:#e6db74">&#34;Dr. Jane Smith&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chapter&#34;</span>:    <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;subject&#34;</span>:    <span style="color:#e6db74">&#34;data-preprocessing&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;difficulty&#34;</span>: <span style="color:#e6db74">&#34;beginner&#34;</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Tags</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;data-science&#34;</span>, <span style="color:#e6db74">&#34;preprocessing&#34;</span>},
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Batch ingest documents</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">IngestDocuments</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">documents</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to ingest documents: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Successfully ingested %d documents\n&#34;</span>, len(<span style="color:#a6e22e">documents</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="text-chunking-strategies">Text Chunking Strategies</h2>
<h3 id="1-fixed-size-chunking">1. Fixed-Size Chunking</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FixedSizeChunker</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkSize</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkOverlap</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewFixedSizeChunker</span>(<span style="color:#a6e22e">chunkSize</span>, <span style="color:#a6e22e">overlap</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">FixedSizeChunker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">FixedSizeChunker</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ChunkSize</span>:    <span style="color:#a6e22e">chunkSize</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ChunkOverlap</span>: <span style="color:#a6e22e">overlap</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FixedSizeChunker</span>) <span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">text</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">ChunkSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">string</span>{<span style="color:#a6e22e">text</span>}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">chunks</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">start</span> &lt; len(<span style="color:#a6e22e">text</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">ChunkSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">text</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">text</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">end</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">chunk</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Move start position considering overlap</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">ChunkSize</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">ChunkOverlap</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">text</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chunks</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Example usage</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chunkLargeDocument</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">largeText</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewFixedSizeChunker</span>(<span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">200</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunks</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chunker</span>.<span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">largeText</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">chunks</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ID</span>:         <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;large-doc-chunk-%d&#34;</span>, <span style="color:#a6e22e">i</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Title</span>:      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Large Document - Chunk %d&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Content</span>:    <span style="color:#a6e22e">chunk</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Source</span>:     <span style="color:#e6db74">&#34;large-document.pdf&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:       <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkIndex</span>: <span style="color:#a6e22e">i</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkTotal</span>: len(<span style="color:#a6e22e">chunks</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chunk_method&#34;</span>: <span style="color:#e6db74">&#34;fixed-size&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chunk_size&#34;</span>:   <span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chunk_overlap&#34;</span>: <span style="color:#ae81ff">200</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">CreatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">IngestDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to ingest chunk %d: %w&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-semantic-chunking">2. Semantic Chunking</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SemanticChunker</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxChunkSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MinChunkSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSemanticChunker</span>(<span style="color:#a6e22e">minSize</span>, <span style="color:#a6e22e">maxSize</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">SemanticChunker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SemanticChunker</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">MinChunkSize</span>: <span style="color:#a6e22e">minSize</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">MaxChunkSize</span>: <span style="color:#a6e22e">maxSize</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SemanticChunker</span>) <span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Split by paragraphs first</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">paragraphs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">text</span>, <span style="color:#e6db74">&#34;\n\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">chunks</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">currentChunk</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">paragraph</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">paragraphs</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">paragraph</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">paragraph</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">paragraph</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if adding this paragraph would exceed max size</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Len</span>() &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>           <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Len</span>()<span style="color:#f92672">+</span>len(<span style="color:#a6e22e">paragraph</span>) &gt; <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">MaxChunkSize</span> {
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Finalize current chunk if it meets minimum size</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Len</span>() <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">MinChunkSize</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">String</span>())
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Reset</span>()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add paragraph to current chunk</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Len</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\n\n&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">paragraph</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add final chunk if it has content</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">Len</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">currentChunk</span>.<span style="color:#a6e22e">String</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chunks</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="3-sentence-based-chunking">3. Sentence-Based Chunking</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SentenceChunker</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxSentences</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Overlap</span>      <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSentenceChunker</span>(<span style="color:#a6e22e">maxSentences</span>, <span style="color:#a6e22e">overlap</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">SentenceChunker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SentenceChunker</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">MaxSentences</span>: <span style="color:#a6e22e">maxSentences</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Overlap</span>:      <span style="color:#a6e22e">overlap</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SentenceChunker</span>) <span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sentences</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">splitIntoSentences</span>(<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">sentences</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">MaxSentences</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">string</span>{<span style="color:#a6e22e">text</span>}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">chunks</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">start</span> &lt; len(<span style="color:#a6e22e">sentences</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">MaxSentences</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">sentences</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">sentences</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">sentences</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">end</span>], <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">chunk</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">MaxSentences</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Overlap</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">sentences</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chunks</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SentenceChunker</span>) <span style="color:#a6e22e">splitIntoSentences</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple sentence splitting (in production, use a proper NLP library)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sentences</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">FieldsFunc</span>(<span style="color:#a6e22e">text</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;!&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clean up sentences</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cleanSentences</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">sentence</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sentences</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sentence</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">sentence</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">sentence</span>) &gt; <span style="color:#ae81ff">10</span> { <span style="color:#75715e">// Filter out very short fragments</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cleanSentences</span> = append(<span style="color:#a6e22e">cleanSentences</span>, <span style="color:#a6e22e">sentence</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cleanSentences</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="advanced-document-processing">Advanced Document Processing</h2>
<h3 id="1-document-processor-with-multiple-strategies">1. Document Processor with Multiple Strategies</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DocumentProcessor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>      <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunkers</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">TextChunker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">extractors</span>  <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentType</span>]<span style="color:#a6e22e">MetadataExtractor</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span>      <span style="color:#a6e22e">ProcessorConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TextChunker</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MetadataExtractor</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ExtractMetadata</span>(<span style="color:#a6e22e">doc</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) (<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ProcessorConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DefaultChunkStrategy</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxConcurrentDocs</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EnableMetadataExtraction</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EnableContentCleaning</span>    <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewDocumentProcessor</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">config</span> <span style="color:#a6e22e">ProcessorConfig</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">DocumentProcessor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>:     <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkers</span>:   make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">TextChunker</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">extractors</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentType</span>]<span style="color:#a6e22e">MetadataExtractor</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">config</span>:     <span style="color:#a6e22e">config</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Register default chunkers</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">chunkers</span>[<span style="color:#e6db74">&#34;fixed&#34;</span>] = <span style="color:#a6e22e">NewFixedSizeChunker</span>(<span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">200</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">chunkers</span>[<span style="color:#e6db74">&#34;semantic&#34;</span>] = <span style="color:#a6e22e">NewSemanticChunker</span>(<span style="color:#ae81ff">500</span>, <span style="color:#ae81ff">1500</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">chunkers</span>[<span style="color:#e6db74">&#34;sentence&#34;</span>] = <span style="color:#a6e22e">NewSentenceChunker</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Register metadata extractors</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">extractors</span>[<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">PDFMetadataExtractor</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">extractors</span>[<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypeMarkdown</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MarkdownMetadataExtractor</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">extractors</span>[<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypeCode</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">CodeMetadataExtractor</span>{}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">ProcessDocument</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">doc</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>, <span style="color:#a6e22e">chunkStrategy</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clean content if enabled</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">EnableContentCleaning</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span> = <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">cleanContent</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract metadata if enabled</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">EnableMetadataExtraction</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">extractor</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">extractors</span>[<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Type</span>]; <span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">metadata</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractor</span>.<span style="color:#a6e22e">ExtractMetadata</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Merge extracted metadata with existing</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">metadata</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Choose chunking strategy</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">chunkStrategy</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkStrategy</span> = <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">DefaultChunkStrategy</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunker</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">chunkers</span>[<span style="color:#a6e22e">chunkStrategy</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unknown chunking strategy: %s&#34;</span>, <span style="color:#a6e22e">chunkStrategy</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Chunk the document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunks</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chunker</span>.<span style="color:#a6e22e">ChunkText</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process chunks</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">chunks</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Single chunk - ingest as-is</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">IngestDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Multiple chunks - create separate documents</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">documents</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">chunks</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">doc</span> <span style="color:#75715e">// Copy original document</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">ID</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s-chunk-%d&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">Content</span> = <span style="color:#a6e22e">chunk</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">ChunkIndex</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">ChunkTotal</span> = len(<span style="color:#a6e22e">chunks</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add chunking metadata</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">Metadata</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">Metadata</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;chunk_strategy&#34;</span>] = <span style="color:#a6e22e">chunkStrategy</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkDoc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;original_doc_id&#34;</span>] = <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">documents</span> = append(<span style="color:#a6e22e">documents</span>, <span style="color:#a6e22e">chunkDoc</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">IngestDocuments</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">documents</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">cleanContent</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Remove excessive whitespace</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`\s+`</span>).<span style="color:#a6e22e">ReplaceAllString</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Remove special characters that might interfere with processing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`[^\w\s\.,!?;:()\-&#34;&#39;]`</span>).<span style="color:#a6e22e">ReplaceAllString</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Trim whitespace</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">content</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-metadata-extractors">2. Metadata Extractors</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// PDF Metadata Extractor</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PDFMetadataExtractor</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PDFMetadataExtractor</span>) <span style="color:#a6e22e">ExtractMetadata</span>(<span style="color:#a6e22e">doc</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) (<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract basic statistics</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;word_count&#34;</span>] = len(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Fields</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;char_count&#34;</span>] = len(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;paragraph_count&#34;</span>] = len(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#e6db74">&#34;\n\n&#34;</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract potential headings (lines that are short and followed by longer content)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">headings</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">line</span>) &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">line</span>) &lt; <span style="color:#ae81ff">100</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> &lt; len(<span style="color:#a6e22e">lines</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">nextLine</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">lines</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nextLine</span>) &gt; len(<span style="color:#a6e22e">line</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">headings</span> = append(<span style="color:#a6e22e">headings</span>, <span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;potential_headings&#34;</span>] = <span style="color:#a6e22e">headings</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Detect language (simple heuristic)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;detected_language&#34;</span>] = <span style="color:#a6e22e">detectLanguage</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">metadata</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Markdown Metadata Extractor</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MarkdownMetadataExtractor</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MarkdownMetadataExtractor</span>) <span style="color:#a6e22e">ExtractMetadata</span>(<span style="color:#a6e22e">doc</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) (<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract headings</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">headings</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractMarkdownHeadings</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;headings&#34;</span>] = <span style="color:#a6e22e">headings</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;heading_count&#34;</span>] = len(<span style="color:#a6e22e">headings</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract links</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">links</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractMarkdownLinks</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;links&#34;</span>] = <span style="color:#a6e22e">links</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;link_count&#34;</span>] = len(<span style="color:#a6e22e">links</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract code blocks</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">codeBlocks</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractMarkdownCodeBlocks</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;code_blocks&#34;</span>] = len(<span style="color:#a6e22e">codeBlocks</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract front matter if present</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">frontMatter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractFrontMatter</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">frontMatter</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;front_matter&#34;</span>] = <span style="color:#a6e22e">frontMatter</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">metadata</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Code Metadata Extractor</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CodeMetadataExtractor</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CodeMetadataExtractor</span>) <span style="color:#a6e22e">ExtractMetadata</span>(<span style="color:#a6e22e">doc</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) (<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Detect programming language</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">language</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">detectProgrammingLanguage</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Source</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;programming_language&#34;</span>] = <span style="color:#a6e22e">language</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Count lines of code</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;total_lines&#34;</span>] = len(<span style="color:#a6e22e">lines</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Count non-empty lines</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nonEmptyLines</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">commentLines</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">line</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">nonEmptyLines</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isCommentLine</span>(<span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">language</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">commentLines</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;code_lines&#34;</span>] = <span style="color:#a6e22e">nonEmptyLines</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;comment_lines&#34;</span>] = <span style="color:#a6e22e">commentLines</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract functions/methods (basic pattern matching)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">functions</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">extractFunctions</span>(<span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#a6e22e">language</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;functions&#34;</span>] = <span style="color:#a6e22e">functions</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metadata</span>[<span style="color:#e6db74">&#34;function_count&#34;</span>] = len(<span style="color:#a6e22e">functions</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">metadata</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Helper functions for metadata extraction</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detectLanguage</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple language detection based on common words</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">englishWords</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;the&#34;</span>, <span style="color:#e6db74">&#34;and&#34;</span>, <span style="color:#e6db74">&#34;is&#34;</span>, <span style="color:#e6db74">&#34;in&#34;</span>, <span style="color:#e6db74">&#34;to&#34;</span>, <span style="color:#e6db74">&#34;of&#34;</span>, <span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;that&#34;</span>, <span style="color:#e6db74">&#34;it&#34;</span>, <span style="color:#e6db74">&#34;with&#34;</span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">words</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Fields</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">content</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">englishCount</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">word</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">words</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">englishWord</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">englishWords</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">word</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">englishWord</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">englishCount</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> float64(<span style="color:#a6e22e">englishCount</span>)<span style="color:#f92672">/</span>float64(len(<span style="color:#a6e22e">words</span>)) &gt; <span style="color:#ae81ff">0.1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;english&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">extractMarkdownHeadings</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">headings</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;#&#34;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">headings</span> = append(<span style="color:#a6e22e">headings</span>, <span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">headings</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">extractMarkdownLinks</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple regex for markdown links [text](url)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">linkRegex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`\[([^\]]+)\]\(([^)]+)\)`</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">matches</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkRegex</span>.<span style="color:#a6e22e">FindAllStringSubmatch</span>(<span style="color:#a6e22e">content</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">links</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">match</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">matches</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">match</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">links</span> = append(<span style="color:#a6e22e">links</span>, <span style="color:#a6e22e">match</span>[<span style="color:#ae81ff">2</span>]) <span style="color:#75715e">// URL part</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">links</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">extractMarkdownCodeBlocks</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple extraction of code blocks</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">codeBlockRegex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">&#34;```[\\s\\S]*?```&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">matches</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">codeBlockRegex</span>.<span style="color:#a6e22e">FindAllString</span>(<span style="color:#a6e22e">content</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">matches</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">extractFrontMatter</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract YAML front matter</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;---&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">SplitN</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;---&#34;</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">parts</span>) &lt; <span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple key-value extraction (in production, use a YAML parser)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">frontMatter</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">any</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;:&#34;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">parts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">SplitN</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">parts</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">frontMatter</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">frontMatter</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detectProgrammingLanguage</span>(<span style="color:#a6e22e">filename</span>, <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Detect by file extension</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ext</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">filepath</span>.<span style="color:#a6e22e">Ext</span>(<span style="color:#a6e22e">filename</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">ext</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.go&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;go&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.py&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;python&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.js&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;javascript&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.ts&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;typescript&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.java&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;java&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.cpp&#34;</span>, <span style="color:#e6db74">&#34;.cc&#34;</span>, <span style="color:#e6db74">&#34;.cxx&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;cpp&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.c&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;c&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;.rs&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;rust&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Detect by content patterns</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;package main&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;func &#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;go&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;def &#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;import &#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;python&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isCommentLine</span>(<span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">language</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">language</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;go&#34;</span>, <span style="color:#e6db74">&#34;javascript&#34;</span>, <span style="color:#e6db74">&#34;typescript&#34;</span>, <span style="color:#e6db74">&#34;java&#34;</span>, <span style="color:#e6db74">&#34;cpp&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>, <span style="color:#e6db74">&#34;rust&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;//&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;/*&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;python&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;#&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">extractFunctions</span>(<span style="color:#a6e22e">content</span>, <span style="color:#a6e22e">language</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">functions</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">language</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;go&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">funcRegex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`func\s+(\w+)\s*\(`</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">matches</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">funcRegex</span>.<span style="color:#a6e22e">FindAllStringSubmatch</span>(<span style="color:#a6e22e">content</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">match</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">matches</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">match</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">functions</span> = append(<span style="color:#a6e22e">functions</span>, <span style="color:#a6e22e">match</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;python&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">funcRegex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`def\s+(\w+)\s*\(`</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">matches</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">funcRegex</span>.<span style="color:#a6e22e">FindAllStringSubmatch</span>(<span style="color:#a6e22e">content</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">match</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">matches</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">match</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">functions</span> = append(<span style="color:#a6e22e">functions</span>, <span style="color:#a6e22e">match</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;javascript&#34;</span>, <span style="color:#e6db74">&#34;typescript&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">funcRegex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`function\s+(\w+)\s*\(`</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">matches</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">funcRegex</span>.<span style="color:#a6e22e">FindAllStringSubmatch</span>(<span style="color:#a6e22e">content</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">match</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">matches</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">match</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">functions</span> = append(<span style="color:#a6e22e">functions</span>, <span style="color:#a6e22e">match</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">functions</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="knowledge-base-search-and-retrieval">Knowledge Base Search and Retrieval</h2>
<h3 id="1-advanced-search-with-filters">1. Advanced Search with Filters</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">performAdvancedKnowledgeSearch</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Search with multiple filters</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">SearchKnowledge</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#e6db74">&#34;machine learning algorithms&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithLimit</span>(<span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithScoreThreshold</span>(<span style="color:#ae81ff">0.7</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSources</span>([]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;textbook-chapter-1.pdf&#34;</span>, <span style="color:#e6db74">&#34;textbook-chapter-2.pdf&#34;</span>}),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithDocumentTypes</span>([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentType</span>{<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DocumentTypePDF</span>}),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTags</span>([]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;ml&#34;</span>, <span style="color:#e6db74">&#34;algorithms&#34;</span>}),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithDateRange</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">DateRange</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Start</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Add</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">24</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Hour</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">End</span>:   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;knowledge search failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Found %d relevant knowledge items:\n&#34;</span>, len(<span style="color:#a6e22e">results</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;- %s (Score: %.3f)\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Title</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Score</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Source: %s\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Source</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Content: %s...\n&#34;</span>, <span style="color:#a6e22e">truncateString</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#ae81ff">100</span>))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">ChunkIndex</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Chunk: %d/%d\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">ChunkIndex</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">ChunkTotal</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">truncateString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">maxLen</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxLen</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>[:<span style="color:#a6e22e">maxLen</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;...&#34;</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-hybrid-search-personal--knowledge">2. Hybrid Search (Personal + Knowledge)</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">performHybridSearch</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Perform hybrid search combining personal memory and knowledge base</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">SearchAll</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#e6db74">&#34;neural network implementation&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithLimit</span>(<span style="color:#ae81ff">15</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithScoreThreshold</span>(<span style="color:#ae81ff">0.6</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithIncludePersonal</span>(<span style="color:#66d9ef">true</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithIncludeKnowledge</span>(<span style="color:#66d9ef">true</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithHybridWeight</span>(<span style="color:#ae81ff">0.7</span>), <span style="color:#75715e">// 70% semantic, 30% keyword</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;hybrid search failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Hybrid Search Results for: %s\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Query</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Total Results: %d (Search Time: %v)\n\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">TotalResults</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">SearchTime</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Display personal memory results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">PersonalMemory</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Personal Memory Results:&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">item</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">PersonalMemory</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;- %s (Score: %.3f)\n&#34;</span>, <span style="color:#a6e22e">truncateString</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#ae81ff">80</span>), <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Score</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Display knowledge base results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Knowledge</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Knowledge Base Results:&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">item</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Knowledge</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;- %s (Score: %.3f)\n&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Title</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Score</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Source: %s\n&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Source</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="3-rag-context-building">3. RAG Context Building</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildRAGContext</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Build comprehensive RAG context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ragContext</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">BuildContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMaxTokens</span>(<span style="color:#ae81ff">4000</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithPersonalWeight</span>(<span style="color:#ae81ff">0.3</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithKnowledgeWeight</span>(<span style="color:#ae81ff">0.7</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithHistoryLimit</span>(<span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithIncludeSources</span>(<span style="color:#66d9ef">true</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithFormatTemplate</span>(<span style="color:#e6db74">`Context Information:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Personal Memory:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">.PersonalMemory</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- </span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Content</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">end</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Knowledge Base:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">.Knowledge</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- </span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Content</span><span style="color:#75715e">}}</span><span style="color:#e6db74"> (Source: </span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Source</span><span style="color:#75715e">}}</span><span style="color:#e6db74">)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">end</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Recent Conversation:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">.ChatHistory</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Role</span><span style="color:#75715e">}}</span><span style="color:#e6db74">: </span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Content</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">{{</span><span style="color:#66d9ef">end</span><span style="color:#75715e">}}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Query: </span><span style="color:#75715e">{{</span><span style="color:#a6e22e">.Query</span><span style="color:#75715e">}}</span><span style="color:#e6db74">`</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to build RAG context: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;RAG Context for: %s\n&#34;</span>, <span style="color:#a6e22e">ragContext</span>.<span style="color:#a6e22e">Query</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Token Count: %d\n&#34;</span>, <span style="color:#a6e22e">ragContext</span>.<span style="color:#a6e22e">TokenCount</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Sources: %v\n&#34;</span>, <span style="color:#a6e22e">ragContext</span>.<span style="color:#a6e22e">Sources</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Context Text:\n%s\n&#34;</span>, <span style="color:#a6e22e">ragContext</span>.<span style="color:#a6e22e">ContextText</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="production-optimization">Production Optimization</h2>
<h3 id="1-batch-processing-pipeline">1. Batch Processing Pipeline</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BatchProcessor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>       <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">processor</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">concurrency</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">batchSize</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewBatchProcessor</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">concurrency</span>, <span style="color:#a6e22e">batchSize</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchProcessor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">BatchProcessor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>:      <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">processor</span>:   <span style="color:#a6e22e">NewDocumentProcessor</span>(<span style="color:#a6e22e">memory</span>, <span style="color:#a6e22e">ProcessorConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">DefaultChunkStrategy</span>:     <span style="color:#e6db74">&#34;semantic&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">MaxConcurrentDocs</span>:        <span style="color:#a6e22e">concurrency</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnableMetadataExtraction</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnableContentCleaning</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">concurrency</span>: <span style="color:#a6e22e">concurrency</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batchSize</span>:   <span style="color:#a6e22e">batchSize</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchProcessor</span>) <span style="color:#a6e22e">ProcessDocuments</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">documents</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process documents in batches</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">documents</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">batchSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">batchSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">documents</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">documents</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">documents</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">end</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">processBatch</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">batch</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to process batch %d-%d: %w&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Processed batch %d-%d (%d documents)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, len(<span style="color:#a6e22e">batch</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchProcessor</span>) <span style="color:#a6e22e">processBatch</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">documents</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use worker pool for concurrent processing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>, len(<span style="color:#a6e22e">documents</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">error</span>, len(<span style="color:#a6e22e">documents</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Start workers</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">w</span> &lt; <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">concurrency</span>; <span style="color:#a6e22e">w</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">jobs</span>, <span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Send jobs</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">documents</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">doc</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(<span style="color:#a6e22e">jobs</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Collect results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">errors</span> []<span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">documents</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">results</span>; <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">errors</span> = append(<span style="color:#a6e22e">errors</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">errors</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;batch processing failed with %d errors: %v&#34;</span>, len(<span style="color:#a6e22e">errors</span>), <span style="color:#a6e22e">errors</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchProcessor</span>) <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Document</span>, <span style="color:#a6e22e">results</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">jobs</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bp</span>.<span style="color:#a6e22e">processor</span>.<span style="color:#a6e22e">ProcessDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>, <span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-performance-monitoring">2. Performance Monitoring</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IngestionMetrics</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentsProcessed</span> <span style="color:#66d9ef">int64</span>         <span style="color:#e6db74">`json:&#34;documents_processed&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunksCreated</span>     <span style="color:#66d9ef">int64</span>         <span style="color:#e6db74">`json:&#34;chunks_created&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ProcessingTime</span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span> <span style="color:#e6db74">`json:&#34;processing_time&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ErrorCount</span>        <span style="color:#66d9ef">int64</span>         <span style="color:#e6db74">`json:&#34;error_count&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AverageChunkSize</span>  <span style="color:#66d9ef">float64</span>       <span style="color:#e6db74">`json:&#34;average_chunk_size&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>                <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">IngestionMetrics</span>) <span style="color:#a6e22e">RecordDocument</span>(<span style="color:#a6e22e">chunkCount</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">processingTime</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">chunkSizes</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">DocumentsProcessed</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ChunksCreated</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">chunkCount</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ProcessingTime</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">processingTime</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Update average chunk size</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">chunkSizes</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">chunkSizes</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">size</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">avgSize</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">totalSize</span>) <span style="color:#f92672">/</span> float64(len(<span style="color:#a6e22e">chunkSizes</span>))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Running average</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">totalChunks</span> <span style="color:#f92672">:=</span> float64(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ChunksCreated</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">AverageChunkSize</span> = (<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">AverageChunkSize</span><span style="color:#f92672">*</span>(<span style="color:#a6e22e">totalChunks</span><span style="color:#f92672">-</span>float64(<span style="color:#a6e22e">chunkCount</span>)) <span style="color:#f92672">+</span> <span style="color:#a6e22e">avgSize</span><span style="color:#f92672">*</span>float64(<span style="color:#a6e22e">chunkCount</span>)) <span style="color:#f92672">/</span> <span style="color:#a6e22e">totalChunks</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">IngestionMetrics</span>) <span style="color:#a6e22e">RecordError</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ErrorCount</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">IngestionMetrics</span>) <span style="color:#a6e22e">GetStats</span>() <span style="color:#a6e22e">IngestionMetrics</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">IngestionMetrics</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">DocumentsProcessed</span>: <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">DocumentsProcessed</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ChunksCreated</span>:     <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ChunksCreated</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ProcessingTime</span>:    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ProcessingTime</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ErrorCount</span>:        <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">ErrorCount</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AverageChunkSize</span>:  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">AverageChunkSize</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="best-practices">Best Practices</h2>
<h3 id="1-document-ingestion-guidelines">1. Document Ingestion Guidelines</h3>
<ul>
<li><strong>Chunk Size</strong>: Balance between context preservation and retrieval precision</li>
<li><strong>Overlap</strong>: Use 10-20% overlap to maintain context continuity</li>
<li><strong>Metadata</strong>: Extract and store rich metadata for better filtering</li>
<li><strong>Batch Processing</strong>: Process documents in batches for better performance</li>
<li><strong>Error Handling</strong>: Implement robust error handling and retry mechanisms</li>
</ul>
<h3 id="2-performance-optimization">2. Performance Optimization</h3>
<ul>
<li><strong>Concurrent Processing</strong>: Use worker pools for parallel document processing</li>
<li><strong>Embedding Caching</strong>: Cache embeddings to avoid recomputation</li>
<li><strong>Index Optimization</strong>: Optimize vector database indexes for your query patterns</li>
<li><strong>Memory Management</strong>: Monitor memory usage during large batch operations</li>
</ul>
<h3 id="3-quality-assurance">3. Quality Assurance</h3>
<ul>
<li><strong>Content Validation</strong>: Validate document content before ingestion</li>
<li><strong>Duplicate Detection</strong>: Implement deduplication to avoid redundant storage</li>
<li><strong>Quality Metrics</strong>: Track ingestion quality and search relevance</li>
<li><strong>Regular Maintenance</strong>: Periodically clean up and optimize the knowledge base</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Document ingestion and knowledge base management are critical for building effective RAG systems. By implementing proper chunking strategies, metadata extraction, and optimization techniques, you can create knowledge bases that provide accurate and relevant information to your agents.</p>
<p>Key takeaways:</p>
<ul>
<li>Choose appropriate chunking strategies based on your content type</li>
<li>Extract rich metadata to enable better filtering and search</li>
<li>Implement batch processing for handling large document collections</li>
<li>Monitor performance and optimize based on usage patterns</li>
<li>Follow best practices for quality and maintenance</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">RAG Implementation</a> - Build complete RAG systems</li>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">Memory Optimization</a> - Optimize performance and scaling</li>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">Vector Databases</a> - Advanced database configuration</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="/AgenticGoKitDocs/reference/api/agent/index.html#document">API Reference: Document Interface</a></li>
<li><a href="../../examples/">Examples: Document Processing</a></li>
<li><a href="/AgenticGoKitDocs/reference/api/configuration/index.html">Configuration Guide: Memory Settings</a></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Jul 25, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/AgenticGoKitDocs/index.html">
            <div class="logo-title">AgenticGoKit Docs</div>
          </a>
        </div>
        <search><form action="/AgenticGoKitDocs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/index.html"><a class="padding" href="/AgenticGoKitDocs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/readme/index.html">content</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/index.html"><input type="checkbox" id="R-section-8fc2fd7736125e87cab8840a86c2af5a" aria-controls="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" checked><label for="R-section-8fc2fd7736125e87cab8840a86c2af5a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu guides</span></label><a class="padding" href="/AgenticGoKitDocs/guides/index.html">guides</a><ul id="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/readme/index.html">guides</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/agentbasics/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/agentbasics/index.html">AgentBasics</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/examples/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/examples/index.html">Examples</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/configuration/index.html">Configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/customtools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/customtools/index.html">CustomTools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/providers/index.html">Providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html">MemoryProviderSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html">MemoryTroubleshooting</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html">EmbeddingModelGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/ragconfiguration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/ragconfiguration/index.html">RAGConfiguration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/toolintegration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/toolintegration/index.html">ToolIntegration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/pgvectorsetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/pgvectorsetup/index.html">PgVectorSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/weaviatesetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/weaviatesetup/index.html">WeaviateSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/performance/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/performance/index.html">Performance</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/errorhandling/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/errorhandling/index.html">ErrorHandling</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/deployment/index.html"><input type="checkbox" id="R-section-ecc839349395ef3c015a12132049dff2" aria-controls="R-subsections-ecc839349395ef3c015a12132049dff2" checked><label for="R-section-ecc839349395ef3c015a12132049dff2"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu deployment</span></label><a class="padding" href="/AgenticGoKitDocs/guides/deployment/index.html">deployment</a><ul id="R-subsections-ecc839349395ef3c015a12132049dff2" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/deployment/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/deployment/readme/index.html">deployment</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/development/index.html"><input type="checkbox" id="R-section-fff1f5eca5d0a93209b9c6262762c25a" aria-controls="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" checked><label for="R-section-fff1f5eca5d0a93209b9c6262762c25a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu development</span></label><a class="padding" href="/AgenticGoKitDocs/guides/development/index.html">development</a><ul id="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/readme/index.html">development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/best-practices/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/best-practices/index.html">best-practices</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/debugging/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/debugging/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/research-assistant/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/research-assistant/index.html">research-assistant</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/testing-agents/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/testing-agents/index.html">testing-agents</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/visualization/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/visualization/index.html">visualization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/web-search-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/web-search-integration/index.html">web-search-integration</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/framework-comparison/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/framework-comparison/index.html">framework-comparison</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memory/index.html">Memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html">ScaffoldMemoryGuide</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/setup/index.html"><input type="checkbox" id="R-section-0124aed9abb5064d53391168f3c95c22" aria-controls="R-subsections-0124aed9abb5064d53391168f3c95c22" checked><label for="R-section-0124aed9abb5064d53391168f3c95c22"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu setup</span></label><a class="padding" href="/AgenticGoKitDocs/guides/setup/index.html">setup</a><ul id="R-subsections-0124aed9abb5064d53391168f3c95c22" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/readme/index.html">setup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/llm-providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/llm-providers/index.html">llm-providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html">mcp-tools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html">orchestration-configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/vector-databases/index.html">vector-databases</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/troubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/troubleshooting/index.html">troubleshooting</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/contributors/index.html"><input type="checkbox" id="R-section-190d9b328fbda7e13ab386f7a5417de5" aria-controls="R-subsections-190d9b328fbda7e13ab386f7a5417de5" checked><label for="R-section-190d9b328fbda7e13ab386f7a5417de5"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu contributors</span></label><a class="padding" href="/AgenticGoKitDocs/contributors/index.html">contributors</a><ul id="R-subsections-190d9b328fbda7e13ab386f7a5417de5" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/readme/index.html">contributors</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/contributorguide/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/contributorguide/index.html">ContributorGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/codestyle/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/codestyle/index.html">CodeStyle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/corevsinternal/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/corevsinternal/index.html">CoreVsInternal</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/addingfeatures/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/addingfeatures/index.html">AddingFeatures</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/testing/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/testing/index.html">Testing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/docsstandards/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/docsstandards/index.html">DocsStandards</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/reference/index.html"><input type="checkbox" id="R-section-66002f201bef818664bb81aa67490c58" aria-controls="R-subsections-66002f201bef818664bb81aa67490c58" checked><label for="R-section-66002f201bef818664bb81aa67490c58"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu reference</span></label><a class="padding" href="/AgenticGoKitDocs/reference/index.html">reference</a><ul id="R-subsections-66002f201bef818664bb81aa67490c58" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/readme/index.html">reference</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/configuration/index.html">configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/cli/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/cli/index.html">cli</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/mcp/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/mcp/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/agent/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/agent/index.html">agent</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/memory/index.html">memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/orchestration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/orchestration/index.html">orchestration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/state-event/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/state-event/index.html">state-event</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/index.html"><input type="checkbox" id="R-section-e1e8c1e70c5500b49e8dda2dc550651a" aria-controls="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" checked><label for="R-section-e1e8c1e70c5500b49e8dda2dc550651a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu tutorials</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/index.html">tutorials</a><ul id="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/readme/index.html">tutorials</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/advanced/index.html"><input type="checkbox" id="R-section-d3def5cd76adc8096d0ff9fda6b8e479" aria-controls="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" checked><label for="R-section-d3def5cd76adc8096d0ff9fda6b8e479"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu advanced</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/index.html">advanced</a><ul id="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/readme/index.html">advanced</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html">circuit-breaker-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html">load-balancing-scaling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html">retry-policies</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html">testing-strategies</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/index.html"><input type="checkbox" id="R-section-212c6ccffb40ecdd78eb2136f98c4cac" aria-controls="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" checked><label for="R-section-212c6ccffb40ecdd78eb2136f98c4cac"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu core-concepts</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/index.html">core-concepts</a><ul id="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html">core-concepts</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html">agent-lifecycle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html">error-handling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html">message-passing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">orchestration-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html">state-management</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/debugging/index.html"><input type="checkbox" id="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" aria-controls="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" checked><label for="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu debugging</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/index.html">debugging</a><ul id="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/readme/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html">debugging-multi-agent-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html">logging-and-tracing</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/index.html"><input type="checkbox" id="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247" aria-controls="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" checked><label for="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu getting-started</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/index.html">getting-started</a><ul id="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html">getting-started</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html">memory-and-rag</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html">multi-agent-collaboration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html">production-deployment</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html">quickstart</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html">tool-integration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html">your-first-agent</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/mcp/index.html"><input type="checkbox" id="R-section-153aac44598009a99dd5a60317a3eecc" aria-controls="R-subsections-153aac44598009a99dd5a60317a3eecc" checked><label for="R-section-153aac44598009a99dd5a60317a3eecc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu mcp</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/index.html">mcp</a><ul id="R-subsections-153aac44598009a99dd5a60317a3eecc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">advanced-tool-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">tool-development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">tool-integration</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><input type="checkbox" id="R-section-9c1a65f2d7b3888241dcafa51a0710e7" aria-controls="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" checked><label for="R-section-9c1a65f2d7b3888241dcafa51a0710e7"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu memory-systems</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html">memory-systems</a><ul id="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">memory-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html">basic-memory</a></li>
            <li class="active " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">document-ingestion</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">knowledge-bases</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">memory-optimization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">rag-implementation</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">vector-databases</a></li></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/AgenticGoKitDocs/js/clipboard/clipboard.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/perfect-scrollbar/perfect-scrollbar.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/theme.js?1753430931" defer></script>
  </body>
</html>
