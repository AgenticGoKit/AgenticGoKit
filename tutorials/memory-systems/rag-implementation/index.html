<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head><script src="/AgenticGoKitDocs/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=AgenticGoKitDocs/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="description" content="RAG Implementation in AgenticGoKit Overview Retrieval-Augmented Generation (RAG) combines the power of large language models with external knowledge retrieval to provide more accurate, up-to-date, and contextually relevant responses. This tutorial covers implementing RAG systems in AgenticGoKit, from basic retrieval to advanced techniques.
RAG enables agents to access vast amounts of information while maintaining the conversational abilities of language models, making them more knowledgeable and reliable.
Prerequisites Understanding of Vector Databases Familiarity with Basic Memory Operations Knowledge of language model APIs Basic understanding of information retrieval concepts RAG Architecture Basic RAG Flow ┌─────────────┐ ┌──────────────┐ ┌─────────────────┐│ User Query │───▶│ Retrieval │───▶│ Context &#43; Query │└─────────────┘ │ System │ └─────────────────┘└──────────────┘ ││ ▼▼ ┌─────────────────┐┌──────────────┐ │ Language Model ││ Vector Store │ │ Generation │└──────────────┘ └─────────────────┘│▼┌─────────────────┐│ Enhanced ││ Response │└─────────────────┘Advanced RAG Components Query Processing: Understanding and reformulating user queries Retrieval: Finding relevant information from knowledge base Reranking: Improving relevance of retrieved results Context Building: Constructing effective prompts Generation: Producing responses with retrieved context Response Enhancement: Post-processing and validation Basic RAG Implementation 1. Simple RAG Agent package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;strings&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type BasicRAGAgent struct { name string memory core.Memory llm core.ModelProvider config RAGConfig } type RAGConfig struct { MaxRetrievalResults int ScoreThreshold float32 MaxContextLength int ContextTemplate string } func NewBasicRAGAgent(name string, memory core.Memory, llm core.ModelProvider) *BasicRAGAgent { return &amp;BasicRAGAgent{ name: name, memory: memory, llm: llm, config: RAGConfig{ MaxRetrievalResults: 5, ScoreThreshold: 0.7, MaxContextLength: 2000, ContextTemplate: `Based on the following information: %s Please answer the question: %s`, }, } } func (r *BasicRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract user query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) // Retrieve relevant context contextStr, sources, err := r.retrieveContext(ctx, queryStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := r.generateResponse(ctx, queryStr, contextStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store the interaction sessionID, _ := event.GetMetadataValue(core.SessionIDKey) err = r.storeInteraction(ctx, sessionID, queryStr, response, sources) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Return result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;sources&#34;, sources) outputState.Set(&#34;context_used&#34;, len(sources) &gt; 0) return core.AgentResult{OutputState: outputState}, nil } func (r *BasicRAGAgent) retrieveContext(ctx context.Context, query string) (string, []string, error) { // Search for relevant information results, err := r.memory.Search(ctx, query, core.WithLimit(r.config.MaxRetrievalResults), core.WithScoreThreshold(r.config.ScoreThreshold), ) if err != nil { return &#34;&#34;, nil, fmt.Errorf(&#34;search failed: %w&#34;, err) } if len(results) == 0 { return &#34;&#34;, nil, nil // No relevant context found } // Build context string var contextBuilder strings.Builder sources := make([]string, 0, len(results)) for i, result := range results { // Add numbered context item contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, result.Content)) // Track sources if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } else { sources = append(sources, fmt.Sprintf(&#34;Document %s&#34;, result.ID)) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; r.config.MaxContextLength { context = context[:r.config.MaxContextLength] &#43; &#34;...&#34; } return context, sources, nil } func (r *BasicRAGAgent) generateResponse(ctx context.Context, query, context string) (string, error) { var prompt string if context != &#34;&#34; { // Use context template prompt = fmt.Sprintf(r.config.ContextTemplate, context, query) } else { // Fallback to direct query prompt = fmt.Sprintf(&#34;Please answer the following question: %s&#34;, query) } // Generate response response, err := r.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;LLM generation failed: %w&#34;, err) } return response, nil } func (r *BasicRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, sources []string) error { // Store user query err := r.memory.Store(ctx, query, &#34;user-query&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-query&#34;, }), ) if err != nil { return err } // Store agent response with sources sourcesStr := strings.Join(sources, &#34;, &#34;) err = r.memory.Store(ctx, response, &#34;agent-response&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-response&#34;, &#34;sources_used&#34;: sourcesStr, &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(sources)), }), ) return err } func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Setup LLM provider llm, err := core.NewOpenAIAdapter( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-3.5-turbo&#34;, 2000, 0.7, ) if err != nil { log.Fatalf(&#34;Failed to create LLM: %v&#34;, err) } // Create RAG agent ragAgent := NewBasicRAGAgent(&#34;rag-assistant&#34;, memory, llm) // Test the agent ctx := context.Background() // First, populate some knowledge knowledge := []string{ &#34;AgenticGoKit is a Go framework for building multi-agent systems with support for LLM integration, memory systems, and orchestration patterns.&#34;, &#34;Vector databases like pgvector and Weaviate are used in AgenticGoKit for semantic search and RAG implementations.&#34;, &#34;The framework supports multiple orchestration patterns including route, collaborative, sequential, and loop modes.&#34;, } for _, info := range knowledge { memory.Store(ctx, info, &#34;knowledge&#34;, core.WithMetadata(map[string]string{ &#34;source&#34;: &#34;documentation&#34;, &#34;topic&#34;: &#34;agenticgokit&#34;, }), ) } // Test query event := core.NewEvent( &#34;rag-assistant&#34;, core.EventData{&#34;message&#34;: &#34;What is AgenticGoKit and what databases does it support?&#34;}, map[string]string{&#34;session_id&#34;: &#34;test-session&#34;}, ) state := core.NewState() state.Set(&#34;message&#34;, &#34;What is AgenticGoKit and what databases does it support?&#34;) result, err := ragAgent.Run(ctx, event, state) if err != nil { log.Fatalf(&#34;RAG agent failed: %v&#34;, err) } response, _ := result.OutputState.Get(&#34;response&#34;) sources, _ := result.OutputState.Get(&#34;sources&#34;) fmt.Printf(&#34;Response: %s\n&#34;, response) fmt.Printf(&#34;Sources: %v\n&#34;, sources) }Advanced RAG Techniques 1. Query Enhancement type QueryEnhancer struct { llm core.LLMProvider } func NewQueryEnhancer(llm core.LLMProvider) *QueryEnhancer { return &amp;QueryEnhancer{llm: llm} } func (qe *QueryEnhancer) EnhanceQuery(ctx context.Context, originalQuery string, conversationHistory []core.Message) (string, error) { // Build context from conversation history var historyBuilder strings.Builder for _, msg := range conversationHistory { historyBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } // Create enhancement prompt prompt := fmt.Sprintf(`Given the conversation history: %s The user&#39;s current query is: &#34;%s&#34; Please rewrite this query to be more specific and searchable, incorporating relevant context from the conversation history. The enhanced query should be optimized for semantic search. Enhanced query:`, historyBuilder.String(), originalQuery) enhancedQuery, err := qe.llm.Generate(ctx, prompt) if err != nil { // Fallback to original query return originalQuery, nil } return strings.TrimSpace(enhancedQuery), nil } // Multi-query generation for better retrieval func (qe *QueryEnhancer) GenerateMultipleQueries(ctx context.Context, originalQuery string) ([]string, error) { prompt := fmt.Sprintf(`Given the query: &#34;%s&#34; Generate 3 different ways to ask the same question that would help find relevant information: 1. 2. 3.`, originalQuery) response, err := qe.llm.Generate(ctx, prompt) if err != nil { return []string{originalQuery}, nil } // Parse the numbered list lines := strings.Split(response, &#34;\n&#34;) queries := make([]string, 0, 3) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;1.&#34;) || strings.HasPrefix(line, &#34;2.&#34;) || strings.HasPrefix(line, &#34;3.&#34;) { query := strings.TrimSpace(line[2:]) if query != &#34;&#34; { queries = append(queries, query) } } } // Always include original query if len(queries) == 0 { queries = append(queries, originalQuery) } return queries, nil }2. Advanced Retrieval with Reranking type AdvancedRetriever struct { memory core.Memory reranker *Reranker config RetrievalConfig } type RetrievalConfig struct { InitialRetrievalLimit int FinalResultLimit int ScoreThreshold float64 RerankingEnabled bool DiversityThreshold float64 } type Reranker struct { llm core.LLMProvider } func NewReranker(llm core.LLMProvider) *Reranker { return &amp;Reranker{llm: llm} } func (r *Reranker) Rerank(ctx context.Context, query string, results []core.MemoryResult) ([]core.MemoryResult, error) { if len(results) &lt;= 1 { return results, nil } // Create reranking prompt var resultsBuilder strings.Builder resultsBuilder.WriteString(&#34;Rank the following passages by relevance to the query:\n\n&#34;) resultsBuilder.WriteString(fmt.Sprintf(&#34;Query: %s\n\n&#34;, query)) for i, result := range results { resultsBuilder.WriteString(fmt.Sprintf(&#34;Passage %d: %s\n\n&#34;, i&#43;1, result.Content)) } resultsBuilder.WriteString(&#34;Please rank these passages from most relevant (1) to least relevant, providing only the numbers separated by commas (e.g., 3,1,4,2):&#34;) response, err := r.llm.Generate(ctx, resultsBuilder.String()) if err != nil { // Fallback to original order return results, nil } // Parse ranking ranking := r.parseRanking(response, len(results)) // Reorder results based on ranking rerankedResults := make([]core.MemoryResult, 0, len(results)) for _, idx := range ranking { if idx &gt;= 0 &amp;&amp; idx &lt; len(results) { rerankedResults = append(rerankedResults, results[idx]) } } // Add any missing results used := make(map[int]bool) for _, idx := range ranking { used[idx] = true } for i, result := range results { if !used[i] { rerankedResults = append(rerankedResults, result) } } return rerankedResults, nil } func (r *Reranker) parseRanking(response string, maxItems int) []int { // Clean and split the response response = strings.TrimSpace(response) parts := strings.Split(response, &#34;,&#34;) ranking := make([]int, 0, len(parts)) for _, part := range parts { part = strings.TrimSpace(part) if num, err := strconv.Atoi(part); err == nil &amp;&amp; num &gt;= 1 &amp;&amp; num &lt;= maxItems { ranking = append(ranking, num-1) // Convert to 0-based index } } return ranking } func (ar *AdvancedRetriever) Retrieve(ctx context.Context, query string) ([]core.MemoryResult, error) { // Initial retrieval with higher limit results, err := ar.memory.Search(ctx, query, core.WithLimit(ar.config.InitialRetrievalLimit), core.WithScoreThreshold(ar.config.ScoreThreshold*0.8), // Lower threshold initially ) if err != nil { return nil, fmt.Errorf(&#34;initial retrieval failed: %w&#34;, err) } if len(results) == 0 { return results, nil } // Apply reranking if enabled if ar.config.RerankingEnabled &amp;&amp; ar.reranker != nil { results, err = ar.reranker.Rerank(ctx, query, results) if err != nil { log.Printf(&#34;Reranking failed, using original order: %v&#34;, err) } } // Apply diversity filtering if ar.config.DiversityThreshold &gt; 0 { results = ar.applyDiversityFilter(results) } // Limit final results if len(results) &gt; ar.config.FinalResultLimit { results = results[:ar.config.FinalResultLimit] } return results, nil } func (ar *AdvancedRetriever) applyDiversityFilter(results []core.MemoryResult) []core.MemoryResult { if len(results) &lt;= 1 { return results } filtered := []core.MemoryResult{results[0]} // Always include the top result for _, candidate := range results[1:] { isDiverse := true for _, selected := range filtered { similarity := ar.calculateSimilarity(candidate.Content, selected.Content) if similarity &gt; ar.config.DiversityThreshold { isDiverse = false break } } if isDiverse { filtered = append(filtered, candidate) } } return filtered } func (ar *AdvancedRetriever) calculateSimilarity(text1, text2 string) float64 { // Simple similarity calculation (in production, use proper similarity metrics) words1 := strings.Fields(strings.ToLower(text1)) words2 := strings.Fields(strings.ToLower(text2)) wordSet1 := make(map[string]bool) for _, word := range words1 { wordSet1[word] = true } common := 0 for _, word := range words2 { if wordSet1[word] { common&#43;&#43; } } if len(words1) == 0 || len(words2) == 0 { return 0 } return float64(common) / float64(len(words1)&#43;len(words2)-common) // Jaccard similarity }3. Context-Aware Response Generation type ContextAwareGenerator struct { llm core.LLMProvider config GenerationConfig } type GenerationConfig struct { MaxContextLength int ResponseMaxLength int IncludeSources bool FactCheckingEnabled bool TemperatureAdjustment float32 } func NewContextAwareGenerator(llm core.LLMProvider, config GenerationConfig) *ContextAwareGenerator { return &amp;ContextAwareGenerator{ llm: llm, config: config, } } func (cag *ContextAwareGenerator) Generate(ctx context.Context, query string, retrievedContext []core.MemoryResult, conversationHistory []core.Message) (string, error) { // Build comprehensive context context := cag.buildContext(query, retrievedContext, conversationHistory) // Create generation prompt prompt := cag.createPrompt(query, context, retrievedContext) // Generate response response, err := cag.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Post-process response response = cag.postProcessResponse(response, retrievedContext) // Fact-check if enabled if cag.config.FactCheckingEnabled { response, err = cag.factCheck(ctx, response, retrievedContext) if err != nil { log.Printf(&#34;Fact-checking failed: %v&#34;, err) } } return response, nil } func (cag *ContextAwareGenerator) buildContext(query string, retrievedContext []core.MemoryResult, history []core.Message) string { var contextBuilder strings.Builder // Add conversation history if relevant if len(history) &gt; 0 { contextBuilder.WriteString(&#34;Recent conversation:\n&#34;) for _, msg := range history { contextBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } contextBuilder.WriteString(&#34;\n&#34;) } // Add retrieved context if len(retrievedContext) &gt; 0 { contextBuilder.WriteString(&#34;Relevant information:\n&#34;) for i, result := range retrievedContext { contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s&#34;, i&#43;1, result.Content)) // Add source information if available if source, ok := result.Metadata[&#34;source&#34;]; ok { contextBuilder.WriteString(fmt.Sprintf(&#34; (Source: %s)&#34;, source)) } contextBuilder.WriteString(&#34;\n&#34;) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; cag.config.MaxContextLength { context = context[:cag.config.MaxContextLength] &#43; &#34;...\n[Context truncated]&#34; } return context } func (cag *ContextAwareGenerator) createPrompt(query, context string, retrievedContext []core.MemoryResult) string { var promptBuilder strings.Builder promptBuilder.WriteString(&#34;You are a knowledgeable assistant. Use the provided context to answer the user&#39;s question accurately and helpfully.\n\n&#34;) if context != &#34;&#34; { promptBuilder.WriteString(&#34;Context:\n&#34;) promptBuilder.WriteString(context) promptBuilder.WriteString(&#34;\n&#34;) } promptBuilder.WriteString(fmt.Sprintf(&#34;Question: %s\n\n&#34;, query)) promptBuilder.WriteString(&#34;Instructions:\n&#34;) promptBuilder.WriteString(&#34;- Answer based on the provided context\n&#34;) promptBuilder.WriteString(&#34;- If the context doesn&#39;t contain enough information, say so\n&#34;) promptBuilder.WriteString(&#34;- Be accurate and cite sources when possible\n&#34;) if cag.config.IncludeSources &amp;&amp; len(retrievedContext) &gt; 0 { promptBuilder.WriteString(&#34;- Include source references in your response\n&#34;) } promptBuilder.WriteString(&#34;\nAnswer:&#34;) return promptBuilder.String() } func (cag *ContextAwareGenerator) postProcessResponse(response string, context []core.MemoryResult) string { // Clean up response response = strings.TrimSpace(response) // Add source citations if configured if cag.config.IncludeSources &amp;&amp; len(context) &gt; 0 { response = cag.addSourceCitations(response, context) } // Truncate if too long if len(response) &gt; cag.config.ResponseMaxLength { response = response[:cag.config.ResponseMaxLength] &#43; &#34;...&#34; } return response } func (cag *ContextAwareGenerator) addSourceCitations(response string, context []core.MemoryResult) string { if len(context) == 0 { return response } var sourcesBuilder strings.Builder sourcesBuilder.WriteString(&#34;\n\nSources:\n&#34;) for i, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] %s\n&#34;, i&#43;1, source)) } else { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] Internal knowledge base\n&#34;, i&#43;1)) } } return response &#43; sourcesBuilder.String() } func (cag *ContextAwareGenerator) factCheck(ctx context.Context, response string, context []core.MemoryResult) (string, error) { // Create fact-checking prompt var contextBuilder strings.Builder for _, result := range context { contextBuilder.WriteString(fmt.Sprintf(&#34;- %s\n&#34;, result.Content)) } prompt := fmt.Sprintf(`Please fact-check the following response against the provided context: Context: %s Response to check: %s Is the response factually accurate based on the context? If there are any inaccuracies, please provide a corrected version. Fact-check result:`, contextBuilder.String(), response) factCheckResult, err := cag.llm.Generate(ctx, prompt) if err != nil { return response, err // Return original response if fact-checking fails } // Simple heuristic: if the fact-check suggests corrections, use them if strings.Contains(strings.ToLower(factCheckResult), &#34;corrected version&#34;) || strings.Contains(strings.ToLower(factCheckResult), &#34;inaccurate&#34;) { // Extract corrected version (this is a simplified approach) lines := strings.Split(factCheckResult, &#34;\n&#34;) for i, line := range lines { if strings.Contains(strings.ToLower(line), &#34;corrected&#34;) &amp;&amp; i&#43;1 &lt; len(lines) { return strings.TrimSpace(lines[i&#43;1]), nil } } } return response, nil }RAG Agent Integration 1. Complete RAG Agent type ComprehensiveRAGAgent struct { name string memory core.Memory llm core.LLMProvider queryEnhancer *QueryEnhancer retriever *AdvancedRetriever generator *ContextAwareGenerator conversationMgr *ConversationManager } type ConversationManager struct { memory core.Memory } func NewConversationManager(memory core.Memory) *ConversationManager { return &amp;ConversationManager{memory: memory} } func (cm *ConversationManager) GetRecentHistory(ctx context.Context, sessionID string, limit int) ([]core.Message, error) { return cm.memory.GetHistory(ctx, limit, core.WithSession(sessionID), core.WithTimeRange(time.Now().Add(-24*time.Hour), time.Now()), ) } func NewComprehensiveRAGAgent(name string, memory core.Memory, llm core.LLMProvider) *ComprehensiveRAGAgent { return &amp;ComprehensiveRAGAgent{ name: name, memory: memory, llm: llm, queryEnhancer: NewQueryEnhancer(llm), retriever: &amp;AdvancedRetriever{ memory: memory, reranker: NewReranker(llm), config: RetrievalConfig{ InitialRetrievalLimit: 10, FinalResultLimit: 5, ScoreThreshold: 0.7, RerankingEnabled: true, DiversityThreshold: 0.8, }, }, generator: NewContextAwareGenerator(llm, GenerationConfig{ MaxContextLength: 3000, ResponseMaxLength: 1500, IncludeSources: true, FactCheckingEnabled: true, TemperatureAdjustment: 0.1, }), conversationMgr: NewConversationManager(memory), } } func (cra *ComprehensiveRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) sessionID := event.GetSessionID() // Get conversation history history, err := cra.conversationMgr.GetRecentHistory(ctx, sessionID, 5) if err != nil { log.Printf(&#34;Failed to get conversation history: %v&#34;, err) history = []core.Message{} // Continue without history } // Enhance query with conversation context enhancedQuery, err := cra.queryEnhancer.EnhanceQuery(ctx, queryStr, history) if err != nil { log.Printf(&#34;Query enhancement failed: %v&#34;, err) enhancedQuery = queryStr // Fallback to original } // Retrieve relevant context retrievedContext, err := cra.retriever.Retrieve(ctx, enhancedQuery) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := cra.generator.Generate(ctx, queryStr, retrievedContext, history) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store interaction err = cra.storeInteraction(ctx, sessionID, queryStr, response, retrievedContext) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Prepare result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;enhanced_query&#34;, enhancedQuery) outputState.Set(&#34;sources_count&#34;, len(retrievedContext)) outputState.Set(&#34;context_used&#34;, len(retrievedContext) &gt; 0) // Add source information sources := make([]string, 0, len(retrievedContext)) for _, result := range retrievedContext { if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } } outputState.Set(&#34;sources&#34;, sources) return core.AgentResult{OutputState: outputState}, nil } func (cra *ComprehensiveRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, context []core.MemoryResult) error { // Store user query err := cra.memory.Store(ctx, query, &#34;user-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, }), ) if err != nil { return err } // Store agent response with context metadata contextSources := make([]string, 0, len(context)) for _, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { contextSources = append(contextSources, source) } } err = cra.memory.Store(ctx, response, &#34;assistant-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, &#34;sources_used&#34;: strings.Join(contextSources, &#34;, &#34;), &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(context)), &#34;context_length&#34;: fmt.Sprintf(&#34;%d&#34;, len(strings.Join(contextSources, &#34; &#34;))), }), ) return err }RAG Performance Optimization 1. Caching Strategies type RAGCache struct { retrievalCache map[string][]core.MemoryResult responseCache map[string]string mu sync.RWMutex ttl time.Duration timestamps map[string]time.Time } func NewRAGCache(ttl time.Duration) *RAGCache { cache := &amp;RAGCache{ retrievalCache: make(map[string][]core.MemoryResult), responseCache: make(map[string]string), timestamps: make(map[string]time.Time), ttl: ttl, } // Start cleanup goroutine go cache.cleanup() return cache } func (rc *RAGCache) GetRetrievalResults(query string) ([]core.MemoryResult, bool) { rc.mu.RLock() defer rc.mu.RUnlock() if timestamp, exists := rc.timestamps[query]; exists { if time.Since(timestamp) &lt; rc.ttl { if results, exists := rc.retrievalCache[query]; exists { return results, true } } } return nil, false } func (rc *RAGCache) SetRetrievalResults(query string, results []core.MemoryResult) { rc.mu.Lock() defer rc.mu.Unlock() rc.retrievalCache[query] = results rc.timestamps[query] = time.Now() } func (rc *RAGCache) cleanup() { ticker := time.NewTicker(rc.ttl / 2) defer ticker.Stop() for range ticker.C { rc.mu.Lock() now := time.Now() for query, timestamp := range rc.timestamps { if now.Sub(timestamp) &gt; rc.ttl { delete(rc.retrievalCache, query) delete(rc.responseCache, query) delete(rc.timestamps, query) } } rc.mu.Unlock() } }2. Batch Processing type BatchRAGProcessor struct { agent *ComprehensiveRAGAgent batchSize int timeout time.Duration } func NewBatchRAGProcessor(agent *ComprehensiveRAGAgent, batchSize int, timeout time.Duration) *BatchRAGProcessor { return &amp;BatchRAGProcessor{ agent: agent, batchSize: batchSize, timeout: timeout, } } func (brp *BatchRAGProcessor) ProcessBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { responses := make([]string, len(queries)) // Process in batches for i := 0; i &lt; len(queries); i &#43;= brp.batchSize { end := i &#43; brp.batchSize if end &gt; len(queries) { end = len(queries) } batch := queries[i:end] batchResponses, err := brp.processBatch(ctx, batch, sessionID) if err != nil { return nil, fmt.Errorf(&#34;batch processing failed: %w&#34;, err) } copy(responses[i:], batchResponses) } return responses, nil } func (brp *BatchRAGProcessor) processBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { ctx, cancel := context.WithTimeout(ctx, brp.timeout) defer cancel() responses := make([]string, len(queries)) var wg sync.WaitGroup var mu sync.Mutex var firstError error for i, query := range queries { wg.Add(1) go func(index int, q string) { defer wg.Done() event := core.NewEvent( brp.agent.name, core.EventData{&#34;message&#34;: q}, map[string]string{&#34;session_id&#34;: sessionID}, ) state := core.NewState() state.Set(&#34;message&#34;, q) result, err := brp.agent.Run(ctx, event, state) mu.Lock() defer mu.Unlock() if err != nil &amp;&amp; firstError == nil { firstError = err } else if err == nil { if response, ok := result.OutputState.Get(&#34;response&#34;); ok { responses[index] = response.(string) } } }(i, query) } wg.Wait() if firstError != nil { return nil, firstError } return responses, nil }RAG Evaluation and Monitoring 1. RAG Metrics type RAGMetrics struct { RetrievalLatency []time.Duration GenerationLatency []time.Duration RetrievalAccuracy float64 ResponseQuality float64 SourceUtilization map[string]int mu sync.RWMutex } func NewRAGMetrics() *RAGMetrics { return &amp;RAGMetrics{ SourceUtilization: make(map[string]int), } } func (rm *RAGMetrics) RecordRetrieval(latency time.Duration, resultsCount int, accuracy float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.RetrievalLatency = append(rm.RetrievalLatency, latency) rm.RetrievalAccuracy = (rm.RetrievalAccuracy &#43; accuracy) / 2 // Simple moving average } func (rm *RAGMetrics) RecordGeneration(latency time.Duration, quality float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.GenerationLatency = append(rm.GenerationLatency, latency) rm.ResponseQuality = (rm.ResponseQuality &#43; quality) / 2 } func (rm *RAGMetrics) RecordSourceUsage(sources []string) { rm.mu.Lock() defer rm.mu.Unlock() for _, source := range sources { rm.SourceUtilization[source]&#43;&#43; } } func (rm *RAGMetrics) GetAverageRetrievalLatency() time.Duration { rm.mu.RLock() defer rm.mu.RUnlock() if len(rm.RetrievalLatency) == 0 { return 0 } var total time.Duration for _, latency := range rm.RetrievalLatency { total &#43;= latency } return total / time.Duration(len(rm.RetrievalLatency)) }2. Quality Assessment type RAGQualityAssessor struct { llm core.LLMProvider } func NewRAGQualityAssessor(llm core.LLMProvider) *RAGQualityAssessor { return &amp;RAGQualityAssessor{llm: llm} } func (rqa *RAGQualityAssessor) AssessResponse(ctx context.Context, query, response string, sources []core.MemoryResult) (float64, error) { // Build assessment prompt var sourcesBuilder strings.Builder for i, source := range sources { sourcesBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, source.Content)) } prompt := fmt.Sprintf(`Please assess the quality of this RAG response on a scale of 0.0 to 1.0: Query: %s Sources used: %s Response: %s Assessment criteria: - Accuracy: Is the response factually correct based on the sources? - Relevance: Does the response directly address the query? - Completeness: Does the response provide sufficient information? - Coherence: Is the response well-structured and clear? Please provide only a numerical score between 0.0 and 1.0:`, query, sourcesBuilder.String(), response) scoreStr, err := rqa.llm.Generate(ctx, prompt) if err != nil { return 0.0, fmt.Errorf(&#34;quality assessment failed: %w&#34;, err) } // Parse score scoreStr = strings.TrimSpace(scoreStr) score, err := strconv.ParseFloat(scoreStr, 64) if err != nil { return 0.0, fmt.Errorf(&#34;failed to parse quality score: %w&#34;, err) } // Clamp score to valid range if score &lt; 0.0 { score = 0.0 } else if score &gt; 1.0 { score = 1.0 } return score, nil }Best Practices 1. RAG System Design Chunk Size Optimization: Balance context and specificity Embedding Quality: Use appropriate embedding models for your domain Retrieval Tuning: Optimize similarity thresholds and result limits Context Management: Manage context length to avoid token limits Source Attribution: Always track and cite information sources 2. Performance Optimization Caching: Cache frequent queries and embeddings Batch Processing: Process multiple queries efficiently Index Optimization: Use appropriate vector database indexes Async Processing: Use asynchronous operations where possible 3. Quality Assurance Evaluation Metrics: Implement comprehensive evaluation Human Feedback: Collect and incorporate user feedback Continuous Monitoring: Monitor system performance and quality A/B Testing: Test different RAG configurations Conclusion RAG implementation in AgenticGoKit enables agents to provide accurate, contextual, and up-to-date responses by combining retrieval and generation. Key takeaways:">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="rag-implementation :: AgenticGoKit Docs">
    <meta name="twitter:description" content="RAG Implementation in AgenticGoKit Overview Retrieval-Augmented Generation (RAG) combines the power of large language models with external knowledge retrieval to provide more accurate, up-to-date, and contextually relevant responses. This tutorial covers implementing RAG systems in AgenticGoKit, from basic retrieval to advanced techniques.
RAG enables agents to access vast amounts of information while maintaining the conversational abilities of language models, making them more knowledgeable and reliable.
Prerequisites Understanding of Vector Databases Familiarity with Basic Memory Operations Knowledge of language model APIs Basic understanding of information retrieval concepts RAG Architecture Basic RAG Flow ┌─────────────┐ ┌──────────────┐ ┌─────────────────┐│ User Query │───▶│ Retrieval │───▶│ Context &#43; Query │└─────────────┘ │ System │ └─────────────────┘└──────────────┘ ││ ▼▼ ┌─────────────────┐┌──────────────┐ │ Language Model ││ Vector Store │ │ Generation │└──────────────┘ └─────────────────┘│▼┌─────────────────┐│ Enhanced ││ Response │└─────────────────┘Advanced RAG Components Query Processing: Understanding and reformulating user queries Retrieval: Finding relevant information from knowledge base Reranking: Improving relevance of retrieved results Context Building: Constructing effective prompts Generation: Producing responses with retrieved context Response Enhancement: Post-processing and validation Basic RAG Implementation 1. Simple RAG Agent package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;strings&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type BasicRAGAgent struct { name string memory core.Memory llm core.ModelProvider config RAGConfig } type RAGConfig struct { MaxRetrievalResults int ScoreThreshold float32 MaxContextLength int ContextTemplate string } func NewBasicRAGAgent(name string, memory core.Memory, llm core.ModelProvider) *BasicRAGAgent { return &amp;BasicRAGAgent{ name: name, memory: memory, llm: llm, config: RAGConfig{ MaxRetrievalResults: 5, ScoreThreshold: 0.7, MaxContextLength: 2000, ContextTemplate: `Based on the following information: %s Please answer the question: %s`, }, } } func (r *BasicRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract user query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) // Retrieve relevant context contextStr, sources, err := r.retrieveContext(ctx, queryStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := r.generateResponse(ctx, queryStr, contextStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store the interaction sessionID, _ := event.GetMetadataValue(core.SessionIDKey) err = r.storeInteraction(ctx, sessionID, queryStr, response, sources) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Return result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;sources&#34;, sources) outputState.Set(&#34;context_used&#34;, len(sources) &gt; 0) return core.AgentResult{OutputState: outputState}, nil } func (r *BasicRAGAgent) retrieveContext(ctx context.Context, query string) (string, []string, error) { // Search for relevant information results, err := r.memory.Search(ctx, query, core.WithLimit(r.config.MaxRetrievalResults), core.WithScoreThreshold(r.config.ScoreThreshold), ) if err != nil { return &#34;&#34;, nil, fmt.Errorf(&#34;search failed: %w&#34;, err) } if len(results) == 0 { return &#34;&#34;, nil, nil // No relevant context found } // Build context string var contextBuilder strings.Builder sources := make([]string, 0, len(results)) for i, result := range results { // Add numbered context item contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, result.Content)) // Track sources if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } else { sources = append(sources, fmt.Sprintf(&#34;Document %s&#34;, result.ID)) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; r.config.MaxContextLength { context = context[:r.config.MaxContextLength] &#43; &#34;...&#34; } return context, sources, nil } func (r *BasicRAGAgent) generateResponse(ctx context.Context, query, context string) (string, error) { var prompt string if context != &#34;&#34; { // Use context template prompt = fmt.Sprintf(r.config.ContextTemplate, context, query) } else { // Fallback to direct query prompt = fmt.Sprintf(&#34;Please answer the following question: %s&#34;, query) } // Generate response response, err := r.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;LLM generation failed: %w&#34;, err) } return response, nil } func (r *BasicRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, sources []string) error { // Store user query err := r.memory.Store(ctx, query, &#34;user-query&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-query&#34;, }), ) if err != nil { return err } // Store agent response with sources sourcesStr := strings.Join(sources, &#34;, &#34;) err = r.memory.Store(ctx, response, &#34;agent-response&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-response&#34;, &#34;sources_used&#34;: sourcesStr, &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(sources)), }), ) return err } func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Setup LLM provider llm, err := core.NewOpenAIAdapter( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-3.5-turbo&#34;, 2000, 0.7, ) if err != nil { log.Fatalf(&#34;Failed to create LLM: %v&#34;, err) } // Create RAG agent ragAgent := NewBasicRAGAgent(&#34;rag-assistant&#34;, memory, llm) // Test the agent ctx := context.Background() // First, populate some knowledge knowledge := []string{ &#34;AgenticGoKit is a Go framework for building multi-agent systems with support for LLM integration, memory systems, and orchestration patterns.&#34;, &#34;Vector databases like pgvector and Weaviate are used in AgenticGoKit for semantic search and RAG implementations.&#34;, &#34;The framework supports multiple orchestration patterns including route, collaborative, sequential, and loop modes.&#34;, } for _, info := range knowledge { memory.Store(ctx, info, &#34;knowledge&#34;, core.WithMetadata(map[string]string{ &#34;source&#34;: &#34;documentation&#34;, &#34;topic&#34;: &#34;agenticgokit&#34;, }), ) } // Test query event := core.NewEvent( &#34;rag-assistant&#34;, core.EventData{&#34;message&#34;: &#34;What is AgenticGoKit and what databases does it support?&#34;}, map[string]string{&#34;session_id&#34;: &#34;test-session&#34;}, ) state := core.NewState() state.Set(&#34;message&#34;, &#34;What is AgenticGoKit and what databases does it support?&#34;) result, err := ragAgent.Run(ctx, event, state) if err != nil { log.Fatalf(&#34;RAG agent failed: %v&#34;, err) } response, _ := result.OutputState.Get(&#34;response&#34;) sources, _ := result.OutputState.Get(&#34;sources&#34;) fmt.Printf(&#34;Response: %s\n&#34;, response) fmt.Printf(&#34;Sources: %v\n&#34;, sources) }Advanced RAG Techniques 1. Query Enhancement type QueryEnhancer struct { llm core.LLMProvider } func NewQueryEnhancer(llm core.LLMProvider) *QueryEnhancer { return &amp;QueryEnhancer{llm: llm} } func (qe *QueryEnhancer) EnhanceQuery(ctx context.Context, originalQuery string, conversationHistory []core.Message) (string, error) { // Build context from conversation history var historyBuilder strings.Builder for _, msg := range conversationHistory { historyBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } // Create enhancement prompt prompt := fmt.Sprintf(`Given the conversation history: %s The user&#39;s current query is: &#34;%s&#34; Please rewrite this query to be more specific and searchable, incorporating relevant context from the conversation history. The enhanced query should be optimized for semantic search. Enhanced query:`, historyBuilder.String(), originalQuery) enhancedQuery, err := qe.llm.Generate(ctx, prompt) if err != nil { // Fallback to original query return originalQuery, nil } return strings.TrimSpace(enhancedQuery), nil } // Multi-query generation for better retrieval func (qe *QueryEnhancer) GenerateMultipleQueries(ctx context.Context, originalQuery string) ([]string, error) { prompt := fmt.Sprintf(`Given the query: &#34;%s&#34; Generate 3 different ways to ask the same question that would help find relevant information: 1. 2. 3.`, originalQuery) response, err := qe.llm.Generate(ctx, prompt) if err != nil { return []string{originalQuery}, nil } // Parse the numbered list lines := strings.Split(response, &#34;\n&#34;) queries := make([]string, 0, 3) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;1.&#34;) || strings.HasPrefix(line, &#34;2.&#34;) || strings.HasPrefix(line, &#34;3.&#34;) { query := strings.TrimSpace(line[2:]) if query != &#34;&#34; { queries = append(queries, query) } } } // Always include original query if len(queries) == 0 { queries = append(queries, originalQuery) } return queries, nil }2. Advanced Retrieval with Reranking type AdvancedRetriever struct { memory core.Memory reranker *Reranker config RetrievalConfig } type RetrievalConfig struct { InitialRetrievalLimit int FinalResultLimit int ScoreThreshold float64 RerankingEnabled bool DiversityThreshold float64 } type Reranker struct { llm core.LLMProvider } func NewReranker(llm core.LLMProvider) *Reranker { return &amp;Reranker{llm: llm} } func (r *Reranker) Rerank(ctx context.Context, query string, results []core.MemoryResult) ([]core.MemoryResult, error) { if len(results) &lt;= 1 { return results, nil } // Create reranking prompt var resultsBuilder strings.Builder resultsBuilder.WriteString(&#34;Rank the following passages by relevance to the query:\n\n&#34;) resultsBuilder.WriteString(fmt.Sprintf(&#34;Query: %s\n\n&#34;, query)) for i, result := range results { resultsBuilder.WriteString(fmt.Sprintf(&#34;Passage %d: %s\n\n&#34;, i&#43;1, result.Content)) } resultsBuilder.WriteString(&#34;Please rank these passages from most relevant (1) to least relevant, providing only the numbers separated by commas (e.g., 3,1,4,2):&#34;) response, err := r.llm.Generate(ctx, resultsBuilder.String()) if err != nil { // Fallback to original order return results, nil } // Parse ranking ranking := r.parseRanking(response, len(results)) // Reorder results based on ranking rerankedResults := make([]core.MemoryResult, 0, len(results)) for _, idx := range ranking { if idx &gt;= 0 &amp;&amp; idx &lt; len(results) { rerankedResults = append(rerankedResults, results[idx]) } } // Add any missing results used := make(map[int]bool) for _, idx := range ranking { used[idx] = true } for i, result := range results { if !used[i] { rerankedResults = append(rerankedResults, result) } } return rerankedResults, nil } func (r *Reranker) parseRanking(response string, maxItems int) []int { // Clean and split the response response = strings.TrimSpace(response) parts := strings.Split(response, &#34;,&#34;) ranking := make([]int, 0, len(parts)) for _, part := range parts { part = strings.TrimSpace(part) if num, err := strconv.Atoi(part); err == nil &amp;&amp; num &gt;= 1 &amp;&amp; num &lt;= maxItems { ranking = append(ranking, num-1) // Convert to 0-based index } } return ranking } func (ar *AdvancedRetriever) Retrieve(ctx context.Context, query string) ([]core.MemoryResult, error) { // Initial retrieval with higher limit results, err := ar.memory.Search(ctx, query, core.WithLimit(ar.config.InitialRetrievalLimit), core.WithScoreThreshold(ar.config.ScoreThreshold*0.8), // Lower threshold initially ) if err != nil { return nil, fmt.Errorf(&#34;initial retrieval failed: %w&#34;, err) } if len(results) == 0 { return results, nil } // Apply reranking if enabled if ar.config.RerankingEnabled &amp;&amp; ar.reranker != nil { results, err = ar.reranker.Rerank(ctx, query, results) if err != nil { log.Printf(&#34;Reranking failed, using original order: %v&#34;, err) } } // Apply diversity filtering if ar.config.DiversityThreshold &gt; 0 { results = ar.applyDiversityFilter(results) } // Limit final results if len(results) &gt; ar.config.FinalResultLimit { results = results[:ar.config.FinalResultLimit] } return results, nil } func (ar *AdvancedRetriever) applyDiversityFilter(results []core.MemoryResult) []core.MemoryResult { if len(results) &lt;= 1 { return results } filtered := []core.MemoryResult{results[0]} // Always include the top result for _, candidate := range results[1:] { isDiverse := true for _, selected := range filtered { similarity := ar.calculateSimilarity(candidate.Content, selected.Content) if similarity &gt; ar.config.DiversityThreshold { isDiverse = false break } } if isDiverse { filtered = append(filtered, candidate) } } return filtered } func (ar *AdvancedRetriever) calculateSimilarity(text1, text2 string) float64 { // Simple similarity calculation (in production, use proper similarity metrics) words1 := strings.Fields(strings.ToLower(text1)) words2 := strings.Fields(strings.ToLower(text2)) wordSet1 := make(map[string]bool) for _, word := range words1 { wordSet1[word] = true } common := 0 for _, word := range words2 { if wordSet1[word] { common&#43;&#43; } } if len(words1) == 0 || len(words2) == 0 { return 0 } return float64(common) / float64(len(words1)&#43;len(words2)-common) // Jaccard similarity }3. Context-Aware Response Generation type ContextAwareGenerator struct { llm core.LLMProvider config GenerationConfig } type GenerationConfig struct { MaxContextLength int ResponseMaxLength int IncludeSources bool FactCheckingEnabled bool TemperatureAdjustment float32 } func NewContextAwareGenerator(llm core.LLMProvider, config GenerationConfig) *ContextAwareGenerator { return &amp;ContextAwareGenerator{ llm: llm, config: config, } } func (cag *ContextAwareGenerator) Generate(ctx context.Context, query string, retrievedContext []core.MemoryResult, conversationHistory []core.Message) (string, error) { // Build comprehensive context context := cag.buildContext(query, retrievedContext, conversationHistory) // Create generation prompt prompt := cag.createPrompt(query, context, retrievedContext) // Generate response response, err := cag.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Post-process response response = cag.postProcessResponse(response, retrievedContext) // Fact-check if enabled if cag.config.FactCheckingEnabled { response, err = cag.factCheck(ctx, response, retrievedContext) if err != nil { log.Printf(&#34;Fact-checking failed: %v&#34;, err) } } return response, nil } func (cag *ContextAwareGenerator) buildContext(query string, retrievedContext []core.MemoryResult, history []core.Message) string { var contextBuilder strings.Builder // Add conversation history if relevant if len(history) &gt; 0 { contextBuilder.WriteString(&#34;Recent conversation:\n&#34;) for _, msg := range history { contextBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } contextBuilder.WriteString(&#34;\n&#34;) } // Add retrieved context if len(retrievedContext) &gt; 0 { contextBuilder.WriteString(&#34;Relevant information:\n&#34;) for i, result := range retrievedContext { contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s&#34;, i&#43;1, result.Content)) // Add source information if available if source, ok := result.Metadata[&#34;source&#34;]; ok { contextBuilder.WriteString(fmt.Sprintf(&#34; (Source: %s)&#34;, source)) } contextBuilder.WriteString(&#34;\n&#34;) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; cag.config.MaxContextLength { context = context[:cag.config.MaxContextLength] &#43; &#34;...\n[Context truncated]&#34; } return context } func (cag *ContextAwareGenerator) createPrompt(query, context string, retrievedContext []core.MemoryResult) string { var promptBuilder strings.Builder promptBuilder.WriteString(&#34;You are a knowledgeable assistant. Use the provided context to answer the user&#39;s question accurately and helpfully.\n\n&#34;) if context != &#34;&#34; { promptBuilder.WriteString(&#34;Context:\n&#34;) promptBuilder.WriteString(context) promptBuilder.WriteString(&#34;\n&#34;) } promptBuilder.WriteString(fmt.Sprintf(&#34;Question: %s\n\n&#34;, query)) promptBuilder.WriteString(&#34;Instructions:\n&#34;) promptBuilder.WriteString(&#34;- Answer based on the provided context\n&#34;) promptBuilder.WriteString(&#34;- If the context doesn&#39;t contain enough information, say so\n&#34;) promptBuilder.WriteString(&#34;- Be accurate and cite sources when possible\n&#34;) if cag.config.IncludeSources &amp;&amp; len(retrievedContext) &gt; 0 { promptBuilder.WriteString(&#34;- Include source references in your response\n&#34;) } promptBuilder.WriteString(&#34;\nAnswer:&#34;) return promptBuilder.String() } func (cag *ContextAwareGenerator) postProcessResponse(response string, context []core.MemoryResult) string { // Clean up response response = strings.TrimSpace(response) // Add source citations if configured if cag.config.IncludeSources &amp;&amp; len(context) &gt; 0 { response = cag.addSourceCitations(response, context) } // Truncate if too long if len(response) &gt; cag.config.ResponseMaxLength { response = response[:cag.config.ResponseMaxLength] &#43; &#34;...&#34; } return response } func (cag *ContextAwareGenerator) addSourceCitations(response string, context []core.MemoryResult) string { if len(context) == 0 { return response } var sourcesBuilder strings.Builder sourcesBuilder.WriteString(&#34;\n\nSources:\n&#34;) for i, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] %s\n&#34;, i&#43;1, source)) } else { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] Internal knowledge base\n&#34;, i&#43;1)) } } return response &#43; sourcesBuilder.String() } func (cag *ContextAwareGenerator) factCheck(ctx context.Context, response string, context []core.MemoryResult) (string, error) { // Create fact-checking prompt var contextBuilder strings.Builder for _, result := range context { contextBuilder.WriteString(fmt.Sprintf(&#34;- %s\n&#34;, result.Content)) } prompt := fmt.Sprintf(`Please fact-check the following response against the provided context: Context: %s Response to check: %s Is the response factually accurate based on the context? If there are any inaccuracies, please provide a corrected version. Fact-check result:`, contextBuilder.String(), response) factCheckResult, err := cag.llm.Generate(ctx, prompt) if err != nil { return response, err // Return original response if fact-checking fails } // Simple heuristic: if the fact-check suggests corrections, use them if strings.Contains(strings.ToLower(factCheckResult), &#34;corrected version&#34;) || strings.Contains(strings.ToLower(factCheckResult), &#34;inaccurate&#34;) { // Extract corrected version (this is a simplified approach) lines := strings.Split(factCheckResult, &#34;\n&#34;) for i, line := range lines { if strings.Contains(strings.ToLower(line), &#34;corrected&#34;) &amp;&amp; i&#43;1 &lt; len(lines) { return strings.TrimSpace(lines[i&#43;1]), nil } } } return response, nil }RAG Agent Integration 1. Complete RAG Agent type ComprehensiveRAGAgent struct { name string memory core.Memory llm core.LLMProvider queryEnhancer *QueryEnhancer retriever *AdvancedRetriever generator *ContextAwareGenerator conversationMgr *ConversationManager } type ConversationManager struct { memory core.Memory } func NewConversationManager(memory core.Memory) *ConversationManager { return &amp;ConversationManager{memory: memory} } func (cm *ConversationManager) GetRecentHistory(ctx context.Context, sessionID string, limit int) ([]core.Message, error) { return cm.memory.GetHistory(ctx, limit, core.WithSession(sessionID), core.WithTimeRange(time.Now().Add(-24*time.Hour), time.Now()), ) } func NewComprehensiveRAGAgent(name string, memory core.Memory, llm core.LLMProvider) *ComprehensiveRAGAgent { return &amp;ComprehensiveRAGAgent{ name: name, memory: memory, llm: llm, queryEnhancer: NewQueryEnhancer(llm), retriever: &amp;AdvancedRetriever{ memory: memory, reranker: NewReranker(llm), config: RetrievalConfig{ InitialRetrievalLimit: 10, FinalResultLimit: 5, ScoreThreshold: 0.7, RerankingEnabled: true, DiversityThreshold: 0.8, }, }, generator: NewContextAwareGenerator(llm, GenerationConfig{ MaxContextLength: 3000, ResponseMaxLength: 1500, IncludeSources: true, FactCheckingEnabled: true, TemperatureAdjustment: 0.1, }), conversationMgr: NewConversationManager(memory), } } func (cra *ComprehensiveRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) sessionID := event.GetSessionID() // Get conversation history history, err := cra.conversationMgr.GetRecentHistory(ctx, sessionID, 5) if err != nil { log.Printf(&#34;Failed to get conversation history: %v&#34;, err) history = []core.Message{} // Continue without history } // Enhance query with conversation context enhancedQuery, err := cra.queryEnhancer.EnhanceQuery(ctx, queryStr, history) if err != nil { log.Printf(&#34;Query enhancement failed: %v&#34;, err) enhancedQuery = queryStr // Fallback to original } // Retrieve relevant context retrievedContext, err := cra.retriever.Retrieve(ctx, enhancedQuery) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := cra.generator.Generate(ctx, queryStr, retrievedContext, history) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store interaction err = cra.storeInteraction(ctx, sessionID, queryStr, response, retrievedContext) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Prepare result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;enhanced_query&#34;, enhancedQuery) outputState.Set(&#34;sources_count&#34;, len(retrievedContext)) outputState.Set(&#34;context_used&#34;, len(retrievedContext) &gt; 0) // Add source information sources := make([]string, 0, len(retrievedContext)) for _, result := range retrievedContext { if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } } outputState.Set(&#34;sources&#34;, sources) return core.AgentResult{OutputState: outputState}, nil } func (cra *ComprehensiveRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, context []core.MemoryResult) error { // Store user query err := cra.memory.Store(ctx, query, &#34;user-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, }), ) if err != nil { return err } // Store agent response with context metadata contextSources := make([]string, 0, len(context)) for _, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { contextSources = append(contextSources, source) } } err = cra.memory.Store(ctx, response, &#34;assistant-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, &#34;sources_used&#34;: strings.Join(contextSources, &#34;, &#34;), &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(context)), &#34;context_length&#34;: fmt.Sprintf(&#34;%d&#34;, len(strings.Join(contextSources, &#34; &#34;))), }), ) return err }RAG Performance Optimization 1. Caching Strategies type RAGCache struct { retrievalCache map[string][]core.MemoryResult responseCache map[string]string mu sync.RWMutex ttl time.Duration timestamps map[string]time.Time } func NewRAGCache(ttl time.Duration) *RAGCache { cache := &amp;RAGCache{ retrievalCache: make(map[string][]core.MemoryResult), responseCache: make(map[string]string), timestamps: make(map[string]time.Time), ttl: ttl, } // Start cleanup goroutine go cache.cleanup() return cache } func (rc *RAGCache) GetRetrievalResults(query string) ([]core.MemoryResult, bool) { rc.mu.RLock() defer rc.mu.RUnlock() if timestamp, exists := rc.timestamps[query]; exists { if time.Since(timestamp) &lt; rc.ttl { if results, exists := rc.retrievalCache[query]; exists { return results, true } } } return nil, false } func (rc *RAGCache) SetRetrievalResults(query string, results []core.MemoryResult) { rc.mu.Lock() defer rc.mu.Unlock() rc.retrievalCache[query] = results rc.timestamps[query] = time.Now() } func (rc *RAGCache) cleanup() { ticker := time.NewTicker(rc.ttl / 2) defer ticker.Stop() for range ticker.C { rc.mu.Lock() now := time.Now() for query, timestamp := range rc.timestamps { if now.Sub(timestamp) &gt; rc.ttl { delete(rc.retrievalCache, query) delete(rc.responseCache, query) delete(rc.timestamps, query) } } rc.mu.Unlock() } }2. Batch Processing type BatchRAGProcessor struct { agent *ComprehensiveRAGAgent batchSize int timeout time.Duration } func NewBatchRAGProcessor(agent *ComprehensiveRAGAgent, batchSize int, timeout time.Duration) *BatchRAGProcessor { return &amp;BatchRAGProcessor{ agent: agent, batchSize: batchSize, timeout: timeout, } } func (brp *BatchRAGProcessor) ProcessBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { responses := make([]string, len(queries)) // Process in batches for i := 0; i &lt; len(queries); i &#43;= brp.batchSize { end := i &#43; brp.batchSize if end &gt; len(queries) { end = len(queries) } batch := queries[i:end] batchResponses, err := brp.processBatch(ctx, batch, sessionID) if err != nil { return nil, fmt.Errorf(&#34;batch processing failed: %w&#34;, err) } copy(responses[i:], batchResponses) } return responses, nil } func (brp *BatchRAGProcessor) processBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { ctx, cancel := context.WithTimeout(ctx, brp.timeout) defer cancel() responses := make([]string, len(queries)) var wg sync.WaitGroup var mu sync.Mutex var firstError error for i, query := range queries { wg.Add(1) go func(index int, q string) { defer wg.Done() event := core.NewEvent( brp.agent.name, core.EventData{&#34;message&#34;: q}, map[string]string{&#34;session_id&#34;: sessionID}, ) state := core.NewState() state.Set(&#34;message&#34;, q) result, err := brp.agent.Run(ctx, event, state) mu.Lock() defer mu.Unlock() if err != nil &amp;&amp; firstError == nil { firstError = err } else if err == nil { if response, ok := result.OutputState.Get(&#34;response&#34;); ok { responses[index] = response.(string) } } }(i, query) } wg.Wait() if firstError != nil { return nil, firstError } return responses, nil }RAG Evaluation and Monitoring 1. RAG Metrics type RAGMetrics struct { RetrievalLatency []time.Duration GenerationLatency []time.Duration RetrievalAccuracy float64 ResponseQuality float64 SourceUtilization map[string]int mu sync.RWMutex } func NewRAGMetrics() *RAGMetrics { return &amp;RAGMetrics{ SourceUtilization: make(map[string]int), } } func (rm *RAGMetrics) RecordRetrieval(latency time.Duration, resultsCount int, accuracy float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.RetrievalLatency = append(rm.RetrievalLatency, latency) rm.RetrievalAccuracy = (rm.RetrievalAccuracy &#43; accuracy) / 2 // Simple moving average } func (rm *RAGMetrics) RecordGeneration(latency time.Duration, quality float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.GenerationLatency = append(rm.GenerationLatency, latency) rm.ResponseQuality = (rm.ResponseQuality &#43; quality) / 2 } func (rm *RAGMetrics) RecordSourceUsage(sources []string) { rm.mu.Lock() defer rm.mu.Unlock() for _, source := range sources { rm.SourceUtilization[source]&#43;&#43; } } func (rm *RAGMetrics) GetAverageRetrievalLatency() time.Duration { rm.mu.RLock() defer rm.mu.RUnlock() if len(rm.RetrievalLatency) == 0 { return 0 } var total time.Duration for _, latency := range rm.RetrievalLatency { total &#43;= latency } return total / time.Duration(len(rm.RetrievalLatency)) }2. Quality Assessment type RAGQualityAssessor struct { llm core.LLMProvider } func NewRAGQualityAssessor(llm core.LLMProvider) *RAGQualityAssessor { return &amp;RAGQualityAssessor{llm: llm} } func (rqa *RAGQualityAssessor) AssessResponse(ctx context.Context, query, response string, sources []core.MemoryResult) (float64, error) { // Build assessment prompt var sourcesBuilder strings.Builder for i, source := range sources { sourcesBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, source.Content)) } prompt := fmt.Sprintf(`Please assess the quality of this RAG response on a scale of 0.0 to 1.0: Query: %s Sources used: %s Response: %s Assessment criteria: - Accuracy: Is the response factually correct based on the sources? - Relevance: Does the response directly address the query? - Completeness: Does the response provide sufficient information? - Coherence: Is the response well-structured and clear? Please provide only a numerical score between 0.0 and 1.0:`, query, sourcesBuilder.String(), response) scoreStr, err := rqa.llm.Generate(ctx, prompt) if err != nil { return 0.0, fmt.Errorf(&#34;quality assessment failed: %w&#34;, err) } // Parse score scoreStr = strings.TrimSpace(scoreStr) score, err := strconv.ParseFloat(scoreStr, 64) if err != nil { return 0.0, fmt.Errorf(&#34;failed to parse quality score: %w&#34;, err) } // Clamp score to valid range if score &lt; 0.0 { score = 0.0 } else if score &gt; 1.0 { score = 1.0 } return score, nil }Best Practices 1. RAG System Design Chunk Size Optimization: Balance context and specificity Embedding Quality: Use appropriate embedding models for your domain Retrieval Tuning: Optimize similarity thresholds and result limits Context Management: Manage context length to avoid token limits Source Attribution: Always track and cite information sources 2. Performance Optimization Caching: Cache frequent queries and embeddings Batch Processing: Process multiple queries efficiently Index Optimization: Use appropriate vector database indexes Async Processing: Use asynchronous operations where possible 3. Quality Assurance Evaluation Metrics: Implement comprehensive evaluation Human Feedback: Collect and incorporate user feedback Continuous Monitoring: Monitor system performance and quality A/B Testing: Test different RAG configurations Conclusion RAG implementation in AgenticGoKit enables agents to provide accurate, contextual, and up-to-date responses by combining retrieval and generation. Key takeaways:">
    <meta property="og:url" content="http://localhost:1313/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">
    <meta property="og:site_name" content="AgenticGoKit Docs">
    <meta property="og:title" content="rag-implementation :: AgenticGoKit Docs">
    <meta property="og:description" content="RAG Implementation in AgenticGoKit Overview Retrieval-Augmented Generation (RAG) combines the power of large language models with external knowledge retrieval to provide more accurate, up-to-date, and contextually relevant responses. This tutorial covers implementing RAG systems in AgenticGoKit, from basic retrieval to advanced techniques.
RAG enables agents to access vast amounts of information while maintaining the conversational abilities of language models, making them more knowledgeable and reliable.
Prerequisites Understanding of Vector Databases Familiarity with Basic Memory Operations Knowledge of language model APIs Basic understanding of information retrieval concepts RAG Architecture Basic RAG Flow ┌─────────────┐ ┌──────────────┐ ┌─────────────────┐│ User Query │───▶│ Retrieval │───▶│ Context &#43; Query │└─────────────┘ │ System │ └─────────────────┘└──────────────┘ ││ ▼▼ ┌─────────────────┐┌──────────────┐ │ Language Model ││ Vector Store │ │ Generation │└──────────────┘ └─────────────────┘│▼┌─────────────────┐│ Enhanced ││ Response │└─────────────────┘Advanced RAG Components Query Processing: Understanding and reformulating user queries Retrieval: Finding relevant information from knowledge base Reranking: Improving relevance of retrieved results Context Building: Constructing effective prompts Generation: Producing responses with retrieved context Response Enhancement: Post-processing and validation Basic RAG Implementation 1. Simple RAG Agent package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;strings&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type BasicRAGAgent struct { name string memory core.Memory llm core.ModelProvider config RAGConfig } type RAGConfig struct { MaxRetrievalResults int ScoreThreshold float32 MaxContextLength int ContextTemplate string } func NewBasicRAGAgent(name string, memory core.Memory, llm core.ModelProvider) *BasicRAGAgent { return &amp;BasicRAGAgent{ name: name, memory: memory, llm: llm, config: RAGConfig{ MaxRetrievalResults: 5, ScoreThreshold: 0.7, MaxContextLength: 2000, ContextTemplate: `Based on the following information: %s Please answer the question: %s`, }, } } func (r *BasicRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract user query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) // Retrieve relevant context contextStr, sources, err := r.retrieveContext(ctx, queryStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := r.generateResponse(ctx, queryStr, contextStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store the interaction sessionID, _ := event.GetMetadataValue(core.SessionIDKey) err = r.storeInteraction(ctx, sessionID, queryStr, response, sources) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Return result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;sources&#34;, sources) outputState.Set(&#34;context_used&#34;, len(sources) &gt; 0) return core.AgentResult{OutputState: outputState}, nil } func (r *BasicRAGAgent) retrieveContext(ctx context.Context, query string) (string, []string, error) { // Search for relevant information results, err := r.memory.Search(ctx, query, core.WithLimit(r.config.MaxRetrievalResults), core.WithScoreThreshold(r.config.ScoreThreshold), ) if err != nil { return &#34;&#34;, nil, fmt.Errorf(&#34;search failed: %w&#34;, err) } if len(results) == 0 { return &#34;&#34;, nil, nil // No relevant context found } // Build context string var contextBuilder strings.Builder sources := make([]string, 0, len(results)) for i, result := range results { // Add numbered context item contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, result.Content)) // Track sources if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } else { sources = append(sources, fmt.Sprintf(&#34;Document %s&#34;, result.ID)) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; r.config.MaxContextLength { context = context[:r.config.MaxContextLength] &#43; &#34;...&#34; } return context, sources, nil } func (r *BasicRAGAgent) generateResponse(ctx context.Context, query, context string) (string, error) { var prompt string if context != &#34;&#34; { // Use context template prompt = fmt.Sprintf(r.config.ContextTemplate, context, query) } else { // Fallback to direct query prompt = fmt.Sprintf(&#34;Please answer the following question: %s&#34;, query) } // Generate response response, err := r.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;LLM generation failed: %w&#34;, err) } return response, nil } func (r *BasicRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, sources []string) error { // Store user query err := r.memory.Store(ctx, query, &#34;user-query&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-query&#34;, }), ) if err != nil { return err } // Store agent response with sources sourcesStr := strings.Join(sources, &#34;, &#34;) err = r.memory.Store(ctx, response, &#34;agent-response&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-response&#34;, &#34;sources_used&#34;: sourcesStr, &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(sources)), }), ) return err } func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Setup LLM provider llm, err := core.NewOpenAIAdapter( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-3.5-turbo&#34;, 2000, 0.7, ) if err != nil { log.Fatalf(&#34;Failed to create LLM: %v&#34;, err) } // Create RAG agent ragAgent := NewBasicRAGAgent(&#34;rag-assistant&#34;, memory, llm) // Test the agent ctx := context.Background() // First, populate some knowledge knowledge := []string{ &#34;AgenticGoKit is a Go framework for building multi-agent systems with support for LLM integration, memory systems, and orchestration patterns.&#34;, &#34;Vector databases like pgvector and Weaviate are used in AgenticGoKit for semantic search and RAG implementations.&#34;, &#34;The framework supports multiple orchestration patterns including route, collaborative, sequential, and loop modes.&#34;, } for _, info := range knowledge { memory.Store(ctx, info, &#34;knowledge&#34;, core.WithMetadata(map[string]string{ &#34;source&#34;: &#34;documentation&#34;, &#34;topic&#34;: &#34;agenticgokit&#34;, }), ) } // Test query event := core.NewEvent( &#34;rag-assistant&#34;, core.EventData{&#34;message&#34;: &#34;What is AgenticGoKit and what databases does it support?&#34;}, map[string]string{&#34;session_id&#34;: &#34;test-session&#34;}, ) state := core.NewState() state.Set(&#34;message&#34;, &#34;What is AgenticGoKit and what databases does it support?&#34;) result, err := ragAgent.Run(ctx, event, state) if err != nil { log.Fatalf(&#34;RAG agent failed: %v&#34;, err) } response, _ := result.OutputState.Get(&#34;response&#34;) sources, _ := result.OutputState.Get(&#34;sources&#34;) fmt.Printf(&#34;Response: %s\n&#34;, response) fmt.Printf(&#34;Sources: %v\n&#34;, sources) }Advanced RAG Techniques 1. Query Enhancement type QueryEnhancer struct { llm core.LLMProvider } func NewQueryEnhancer(llm core.LLMProvider) *QueryEnhancer { return &amp;QueryEnhancer{llm: llm} } func (qe *QueryEnhancer) EnhanceQuery(ctx context.Context, originalQuery string, conversationHistory []core.Message) (string, error) { // Build context from conversation history var historyBuilder strings.Builder for _, msg := range conversationHistory { historyBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } // Create enhancement prompt prompt := fmt.Sprintf(`Given the conversation history: %s The user&#39;s current query is: &#34;%s&#34; Please rewrite this query to be more specific and searchable, incorporating relevant context from the conversation history. The enhanced query should be optimized for semantic search. Enhanced query:`, historyBuilder.String(), originalQuery) enhancedQuery, err := qe.llm.Generate(ctx, prompt) if err != nil { // Fallback to original query return originalQuery, nil } return strings.TrimSpace(enhancedQuery), nil } // Multi-query generation for better retrieval func (qe *QueryEnhancer) GenerateMultipleQueries(ctx context.Context, originalQuery string) ([]string, error) { prompt := fmt.Sprintf(`Given the query: &#34;%s&#34; Generate 3 different ways to ask the same question that would help find relevant information: 1. 2. 3.`, originalQuery) response, err := qe.llm.Generate(ctx, prompt) if err != nil { return []string{originalQuery}, nil } // Parse the numbered list lines := strings.Split(response, &#34;\n&#34;) queries := make([]string, 0, 3) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;1.&#34;) || strings.HasPrefix(line, &#34;2.&#34;) || strings.HasPrefix(line, &#34;3.&#34;) { query := strings.TrimSpace(line[2:]) if query != &#34;&#34; { queries = append(queries, query) } } } // Always include original query if len(queries) == 0 { queries = append(queries, originalQuery) } return queries, nil }2. Advanced Retrieval with Reranking type AdvancedRetriever struct { memory core.Memory reranker *Reranker config RetrievalConfig } type RetrievalConfig struct { InitialRetrievalLimit int FinalResultLimit int ScoreThreshold float64 RerankingEnabled bool DiversityThreshold float64 } type Reranker struct { llm core.LLMProvider } func NewReranker(llm core.LLMProvider) *Reranker { return &amp;Reranker{llm: llm} } func (r *Reranker) Rerank(ctx context.Context, query string, results []core.MemoryResult) ([]core.MemoryResult, error) { if len(results) &lt;= 1 { return results, nil } // Create reranking prompt var resultsBuilder strings.Builder resultsBuilder.WriteString(&#34;Rank the following passages by relevance to the query:\n\n&#34;) resultsBuilder.WriteString(fmt.Sprintf(&#34;Query: %s\n\n&#34;, query)) for i, result := range results { resultsBuilder.WriteString(fmt.Sprintf(&#34;Passage %d: %s\n\n&#34;, i&#43;1, result.Content)) } resultsBuilder.WriteString(&#34;Please rank these passages from most relevant (1) to least relevant, providing only the numbers separated by commas (e.g., 3,1,4,2):&#34;) response, err := r.llm.Generate(ctx, resultsBuilder.String()) if err != nil { // Fallback to original order return results, nil } // Parse ranking ranking := r.parseRanking(response, len(results)) // Reorder results based on ranking rerankedResults := make([]core.MemoryResult, 0, len(results)) for _, idx := range ranking { if idx &gt;= 0 &amp;&amp; idx &lt; len(results) { rerankedResults = append(rerankedResults, results[idx]) } } // Add any missing results used := make(map[int]bool) for _, idx := range ranking { used[idx] = true } for i, result := range results { if !used[i] { rerankedResults = append(rerankedResults, result) } } return rerankedResults, nil } func (r *Reranker) parseRanking(response string, maxItems int) []int { // Clean and split the response response = strings.TrimSpace(response) parts := strings.Split(response, &#34;,&#34;) ranking := make([]int, 0, len(parts)) for _, part := range parts { part = strings.TrimSpace(part) if num, err := strconv.Atoi(part); err == nil &amp;&amp; num &gt;= 1 &amp;&amp; num &lt;= maxItems { ranking = append(ranking, num-1) // Convert to 0-based index } } return ranking } func (ar *AdvancedRetriever) Retrieve(ctx context.Context, query string) ([]core.MemoryResult, error) { // Initial retrieval with higher limit results, err := ar.memory.Search(ctx, query, core.WithLimit(ar.config.InitialRetrievalLimit), core.WithScoreThreshold(ar.config.ScoreThreshold*0.8), // Lower threshold initially ) if err != nil { return nil, fmt.Errorf(&#34;initial retrieval failed: %w&#34;, err) } if len(results) == 0 { return results, nil } // Apply reranking if enabled if ar.config.RerankingEnabled &amp;&amp; ar.reranker != nil { results, err = ar.reranker.Rerank(ctx, query, results) if err != nil { log.Printf(&#34;Reranking failed, using original order: %v&#34;, err) } } // Apply diversity filtering if ar.config.DiversityThreshold &gt; 0 { results = ar.applyDiversityFilter(results) } // Limit final results if len(results) &gt; ar.config.FinalResultLimit { results = results[:ar.config.FinalResultLimit] } return results, nil } func (ar *AdvancedRetriever) applyDiversityFilter(results []core.MemoryResult) []core.MemoryResult { if len(results) &lt;= 1 { return results } filtered := []core.MemoryResult{results[0]} // Always include the top result for _, candidate := range results[1:] { isDiverse := true for _, selected := range filtered { similarity := ar.calculateSimilarity(candidate.Content, selected.Content) if similarity &gt; ar.config.DiversityThreshold { isDiverse = false break } } if isDiverse { filtered = append(filtered, candidate) } } return filtered } func (ar *AdvancedRetriever) calculateSimilarity(text1, text2 string) float64 { // Simple similarity calculation (in production, use proper similarity metrics) words1 := strings.Fields(strings.ToLower(text1)) words2 := strings.Fields(strings.ToLower(text2)) wordSet1 := make(map[string]bool) for _, word := range words1 { wordSet1[word] = true } common := 0 for _, word := range words2 { if wordSet1[word] { common&#43;&#43; } } if len(words1) == 0 || len(words2) == 0 { return 0 } return float64(common) / float64(len(words1)&#43;len(words2)-common) // Jaccard similarity }3. Context-Aware Response Generation type ContextAwareGenerator struct { llm core.LLMProvider config GenerationConfig } type GenerationConfig struct { MaxContextLength int ResponseMaxLength int IncludeSources bool FactCheckingEnabled bool TemperatureAdjustment float32 } func NewContextAwareGenerator(llm core.LLMProvider, config GenerationConfig) *ContextAwareGenerator { return &amp;ContextAwareGenerator{ llm: llm, config: config, } } func (cag *ContextAwareGenerator) Generate(ctx context.Context, query string, retrievedContext []core.MemoryResult, conversationHistory []core.Message) (string, error) { // Build comprehensive context context := cag.buildContext(query, retrievedContext, conversationHistory) // Create generation prompt prompt := cag.createPrompt(query, context, retrievedContext) // Generate response response, err := cag.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Post-process response response = cag.postProcessResponse(response, retrievedContext) // Fact-check if enabled if cag.config.FactCheckingEnabled { response, err = cag.factCheck(ctx, response, retrievedContext) if err != nil { log.Printf(&#34;Fact-checking failed: %v&#34;, err) } } return response, nil } func (cag *ContextAwareGenerator) buildContext(query string, retrievedContext []core.MemoryResult, history []core.Message) string { var contextBuilder strings.Builder // Add conversation history if relevant if len(history) &gt; 0 { contextBuilder.WriteString(&#34;Recent conversation:\n&#34;) for _, msg := range history { contextBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } contextBuilder.WriteString(&#34;\n&#34;) } // Add retrieved context if len(retrievedContext) &gt; 0 { contextBuilder.WriteString(&#34;Relevant information:\n&#34;) for i, result := range retrievedContext { contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s&#34;, i&#43;1, result.Content)) // Add source information if available if source, ok := result.Metadata[&#34;source&#34;]; ok { contextBuilder.WriteString(fmt.Sprintf(&#34; (Source: %s)&#34;, source)) } contextBuilder.WriteString(&#34;\n&#34;) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; cag.config.MaxContextLength { context = context[:cag.config.MaxContextLength] &#43; &#34;...\n[Context truncated]&#34; } return context } func (cag *ContextAwareGenerator) createPrompt(query, context string, retrievedContext []core.MemoryResult) string { var promptBuilder strings.Builder promptBuilder.WriteString(&#34;You are a knowledgeable assistant. Use the provided context to answer the user&#39;s question accurately and helpfully.\n\n&#34;) if context != &#34;&#34; { promptBuilder.WriteString(&#34;Context:\n&#34;) promptBuilder.WriteString(context) promptBuilder.WriteString(&#34;\n&#34;) } promptBuilder.WriteString(fmt.Sprintf(&#34;Question: %s\n\n&#34;, query)) promptBuilder.WriteString(&#34;Instructions:\n&#34;) promptBuilder.WriteString(&#34;- Answer based on the provided context\n&#34;) promptBuilder.WriteString(&#34;- If the context doesn&#39;t contain enough information, say so\n&#34;) promptBuilder.WriteString(&#34;- Be accurate and cite sources when possible\n&#34;) if cag.config.IncludeSources &amp;&amp; len(retrievedContext) &gt; 0 { promptBuilder.WriteString(&#34;- Include source references in your response\n&#34;) } promptBuilder.WriteString(&#34;\nAnswer:&#34;) return promptBuilder.String() } func (cag *ContextAwareGenerator) postProcessResponse(response string, context []core.MemoryResult) string { // Clean up response response = strings.TrimSpace(response) // Add source citations if configured if cag.config.IncludeSources &amp;&amp; len(context) &gt; 0 { response = cag.addSourceCitations(response, context) } // Truncate if too long if len(response) &gt; cag.config.ResponseMaxLength { response = response[:cag.config.ResponseMaxLength] &#43; &#34;...&#34; } return response } func (cag *ContextAwareGenerator) addSourceCitations(response string, context []core.MemoryResult) string { if len(context) == 0 { return response } var sourcesBuilder strings.Builder sourcesBuilder.WriteString(&#34;\n\nSources:\n&#34;) for i, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] %s\n&#34;, i&#43;1, source)) } else { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] Internal knowledge base\n&#34;, i&#43;1)) } } return response &#43; sourcesBuilder.String() } func (cag *ContextAwareGenerator) factCheck(ctx context.Context, response string, context []core.MemoryResult) (string, error) { // Create fact-checking prompt var contextBuilder strings.Builder for _, result := range context { contextBuilder.WriteString(fmt.Sprintf(&#34;- %s\n&#34;, result.Content)) } prompt := fmt.Sprintf(`Please fact-check the following response against the provided context: Context: %s Response to check: %s Is the response factually accurate based on the context? If there are any inaccuracies, please provide a corrected version. Fact-check result:`, contextBuilder.String(), response) factCheckResult, err := cag.llm.Generate(ctx, prompt) if err != nil { return response, err // Return original response if fact-checking fails } // Simple heuristic: if the fact-check suggests corrections, use them if strings.Contains(strings.ToLower(factCheckResult), &#34;corrected version&#34;) || strings.Contains(strings.ToLower(factCheckResult), &#34;inaccurate&#34;) { // Extract corrected version (this is a simplified approach) lines := strings.Split(factCheckResult, &#34;\n&#34;) for i, line := range lines { if strings.Contains(strings.ToLower(line), &#34;corrected&#34;) &amp;&amp; i&#43;1 &lt; len(lines) { return strings.TrimSpace(lines[i&#43;1]), nil } } } return response, nil }RAG Agent Integration 1. Complete RAG Agent type ComprehensiveRAGAgent struct { name string memory core.Memory llm core.LLMProvider queryEnhancer *QueryEnhancer retriever *AdvancedRetriever generator *ContextAwareGenerator conversationMgr *ConversationManager } type ConversationManager struct { memory core.Memory } func NewConversationManager(memory core.Memory) *ConversationManager { return &amp;ConversationManager{memory: memory} } func (cm *ConversationManager) GetRecentHistory(ctx context.Context, sessionID string, limit int) ([]core.Message, error) { return cm.memory.GetHistory(ctx, limit, core.WithSession(sessionID), core.WithTimeRange(time.Now().Add(-24*time.Hour), time.Now()), ) } func NewComprehensiveRAGAgent(name string, memory core.Memory, llm core.LLMProvider) *ComprehensiveRAGAgent { return &amp;ComprehensiveRAGAgent{ name: name, memory: memory, llm: llm, queryEnhancer: NewQueryEnhancer(llm), retriever: &amp;AdvancedRetriever{ memory: memory, reranker: NewReranker(llm), config: RetrievalConfig{ InitialRetrievalLimit: 10, FinalResultLimit: 5, ScoreThreshold: 0.7, RerankingEnabled: true, DiversityThreshold: 0.8, }, }, generator: NewContextAwareGenerator(llm, GenerationConfig{ MaxContextLength: 3000, ResponseMaxLength: 1500, IncludeSources: true, FactCheckingEnabled: true, TemperatureAdjustment: 0.1, }), conversationMgr: NewConversationManager(memory), } } func (cra *ComprehensiveRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) sessionID := event.GetSessionID() // Get conversation history history, err := cra.conversationMgr.GetRecentHistory(ctx, sessionID, 5) if err != nil { log.Printf(&#34;Failed to get conversation history: %v&#34;, err) history = []core.Message{} // Continue without history } // Enhance query with conversation context enhancedQuery, err := cra.queryEnhancer.EnhanceQuery(ctx, queryStr, history) if err != nil { log.Printf(&#34;Query enhancement failed: %v&#34;, err) enhancedQuery = queryStr // Fallback to original } // Retrieve relevant context retrievedContext, err := cra.retriever.Retrieve(ctx, enhancedQuery) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := cra.generator.Generate(ctx, queryStr, retrievedContext, history) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store interaction err = cra.storeInteraction(ctx, sessionID, queryStr, response, retrievedContext) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Prepare result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;enhanced_query&#34;, enhancedQuery) outputState.Set(&#34;sources_count&#34;, len(retrievedContext)) outputState.Set(&#34;context_used&#34;, len(retrievedContext) &gt; 0) // Add source information sources := make([]string, 0, len(retrievedContext)) for _, result := range retrievedContext { if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } } outputState.Set(&#34;sources&#34;, sources) return core.AgentResult{OutputState: outputState}, nil } func (cra *ComprehensiveRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, context []core.MemoryResult) error { // Store user query err := cra.memory.Store(ctx, query, &#34;user-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, }), ) if err != nil { return err } // Store agent response with context metadata contextSources := make([]string, 0, len(context)) for _, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { contextSources = append(contextSources, source) } } err = cra.memory.Store(ctx, response, &#34;assistant-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, &#34;sources_used&#34;: strings.Join(contextSources, &#34;, &#34;), &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(context)), &#34;context_length&#34;: fmt.Sprintf(&#34;%d&#34;, len(strings.Join(contextSources, &#34; &#34;))), }), ) return err }RAG Performance Optimization 1. Caching Strategies type RAGCache struct { retrievalCache map[string][]core.MemoryResult responseCache map[string]string mu sync.RWMutex ttl time.Duration timestamps map[string]time.Time } func NewRAGCache(ttl time.Duration) *RAGCache { cache := &amp;RAGCache{ retrievalCache: make(map[string][]core.MemoryResult), responseCache: make(map[string]string), timestamps: make(map[string]time.Time), ttl: ttl, } // Start cleanup goroutine go cache.cleanup() return cache } func (rc *RAGCache) GetRetrievalResults(query string) ([]core.MemoryResult, bool) { rc.mu.RLock() defer rc.mu.RUnlock() if timestamp, exists := rc.timestamps[query]; exists { if time.Since(timestamp) &lt; rc.ttl { if results, exists := rc.retrievalCache[query]; exists { return results, true } } } return nil, false } func (rc *RAGCache) SetRetrievalResults(query string, results []core.MemoryResult) { rc.mu.Lock() defer rc.mu.Unlock() rc.retrievalCache[query] = results rc.timestamps[query] = time.Now() } func (rc *RAGCache) cleanup() { ticker := time.NewTicker(rc.ttl / 2) defer ticker.Stop() for range ticker.C { rc.mu.Lock() now := time.Now() for query, timestamp := range rc.timestamps { if now.Sub(timestamp) &gt; rc.ttl { delete(rc.retrievalCache, query) delete(rc.responseCache, query) delete(rc.timestamps, query) } } rc.mu.Unlock() } }2. Batch Processing type BatchRAGProcessor struct { agent *ComprehensiveRAGAgent batchSize int timeout time.Duration } func NewBatchRAGProcessor(agent *ComprehensiveRAGAgent, batchSize int, timeout time.Duration) *BatchRAGProcessor { return &amp;BatchRAGProcessor{ agent: agent, batchSize: batchSize, timeout: timeout, } } func (brp *BatchRAGProcessor) ProcessBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { responses := make([]string, len(queries)) // Process in batches for i := 0; i &lt; len(queries); i &#43;= brp.batchSize { end := i &#43; brp.batchSize if end &gt; len(queries) { end = len(queries) } batch := queries[i:end] batchResponses, err := brp.processBatch(ctx, batch, sessionID) if err != nil { return nil, fmt.Errorf(&#34;batch processing failed: %w&#34;, err) } copy(responses[i:], batchResponses) } return responses, nil } func (brp *BatchRAGProcessor) processBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { ctx, cancel := context.WithTimeout(ctx, brp.timeout) defer cancel() responses := make([]string, len(queries)) var wg sync.WaitGroup var mu sync.Mutex var firstError error for i, query := range queries { wg.Add(1) go func(index int, q string) { defer wg.Done() event := core.NewEvent( brp.agent.name, core.EventData{&#34;message&#34;: q}, map[string]string{&#34;session_id&#34;: sessionID}, ) state := core.NewState() state.Set(&#34;message&#34;, q) result, err := brp.agent.Run(ctx, event, state) mu.Lock() defer mu.Unlock() if err != nil &amp;&amp; firstError == nil { firstError = err } else if err == nil { if response, ok := result.OutputState.Get(&#34;response&#34;); ok { responses[index] = response.(string) } } }(i, query) } wg.Wait() if firstError != nil { return nil, firstError } return responses, nil }RAG Evaluation and Monitoring 1. RAG Metrics type RAGMetrics struct { RetrievalLatency []time.Duration GenerationLatency []time.Duration RetrievalAccuracy float64 ResponseQuality float64 SourceUtilization map[string]int mu sync.RWMutex } func NewRAGMetrics() *RAGMetrics { return &amp;RAGMetrics{ SourceUtilization: make(map[string]int), } } func (rm *RAGMetrics) RecordRetrieval(latency time.Duration, resultsCount int, accuracy float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.RetrievalLatency = append(rm.RetrievalLatency, latency) rm.RetrievalAccuracy = (rm.RetrievalAccuracy &#43; accuracy) / 2 // Simple moving average } func (rm *RAGMetrics) RecordGeneration(latency time.Duration, quality float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.GenerationLatency = append(rm.GenerationLatency, latency) rm.ResponseQuality = (rm.ResponseQuality &#43; quality) / 2 } func (rm *RAGMetrics) RecordSourceUsage(sources []string) { rm.mu.Lock() defer rm.mu.Unlock() for _, source := range sources { rm.SourceUtilization[source]&#43;&#43; } } func (rm *RAGMetrics) GetAverageRetrievalLatency() time.Duration { rm.mu.RLock() defer rm.mu.RUnlock() if len(rm.RetrievalLatency) == 0 { return 0 } var total time.Duration for _, latency := range rm.RetrievalLatency { total &#43;= latency } return total / time.Duration(len(rm.RetrievalLatency)) }2. Quality Assessment type RAGQualityAssessor struct { llm core.LLMProvider } func NewRAGQualityAssessor(llm core.LLMProvider) *RAGQualityAssessor { return &amp;RAGQualityAssessor{llm: llm} } func (rqa *RAGQualityAssessor) AssessResponse(ctx context.Context, query, response string, sources []core.MemoryResult) (float64, error) { // Build assessment prompt var sourcesBuilder strings.Builder for i, source := range sources { sourcesBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, source.Content)) } prompt := fmt.Sprintf(`Please assess the quality of this RAG response on a scale of 0.0 to 1.0: Query: %s Sources used: %s Response: %s Assessment criteria: - Accuracy: Is the response factually correct based on the sources? - Relevance: Does the response directly address the query? - Completeness: Does the response provide sufficient information? - Coherence: Is the response well-structured and clear? Please provide only a numerical score between 0.0 and 1.0:`, query, sourcesBuilder.String(), response) scoreStr, err := rqa.llm.Generate(ctx, prompt) if err != nil { return 0.0, fmt.Errorf(&#34;quality assessment failed: %w&#34;, err) } // Parse score scoreStr = strings.TrimSpace(scoreStr) score, err := strconv.ParseFloat(scoreStr, 64) if err != nil { return 0.0, fmt.Errorf(&#34;failed to parse quality score: %w&#34;, err) } // Clamp score to valid range if score &lt; 0.0 { score = 0.0 } else if score &gt; 1.0 { score = 1.0 } return score, nil }Best Practices 1. RAG System Design Chunk Size Optimization: Balance context and specificity Embedding Quality: Use appropriate embedding models for your domain Retrieval Tuning: Optimize similarity thresholds and result limits Context Management: Manage context length to avoid token limits Source Attribution: Always track and cite information sources 2. Performance Optimization Caching: Cache frequent queries and embeddings Batch Processing: Process multiple queries efficiently Index Optimization: Use appropriate vector database indexes Async Processing: Use asynchronous operations where possible 3. Quality Assurance Evaluation Metrics: Implement comprehensive evaluation Human Feedback: Collect and incorporate user feedback Continuous Monitoring: Monitor system performance and quality A/B Testing: Test different RAG configurations Conclusion RAG implementation in AgenticGoKit enables agents to provide accurate, contextual, and up-to-date responses by combining retrieval and generation. Key takeaways:">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="tutorials">
    <meta property="article:published_time" content="2025-07-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="name" content="rag-implementation :: AgenticGoKit Docs">
    <meta itemprop="description" content="RAG Implementation in AgenticGoKit Overview Retrieval-Augmented Generation (RAG) combines the power of large language models with external knowledge retrieval to provide more accurate, up-to-date, and contextually relevant responses. This tutorial covers implementing RAG systems in AgenticGoKit, from basic retrieval to advanced techniques.
RAG enables agents to access vast amounts of information while maintaining the conversational abilities of language models, making them more knowledgeable and reliable.
Prerequisites Understanding of Vector Databases Familiarity with Basic Memory Operations Knowledge of language model APIs Basic understanding of information retrieval concepts RAG Architecture Basic RAG Flow ┌─────────────┐ ┌──────────────┐ ┌─────────────────┐│ User Query │───▶│ Retrieval │───▶│ Context &#43; Query │└─────────────┘ │ System │ └─────────────────┘└──────────────┘ ││ ▼▼ ┌─────────────────┐┌──────────────┐ │ Language Model ││ Vector Store │ │ Generation │└──────────────┘ └─────────────────┘│▼┌─────────────────┐│ Enhanced ││ Response │└─────────────────┘Advanced RAG Components Query Processing: Understanding and reformulating user queries Retrieval: Finding relevant information from knowledge base Reranking: Improving relevance of retrieved results Context Building: Constructing effective prompts Generation: Producing responses with retrieved context Response Enhancement: Post-processing and validation Basic RAG Implementation 1. Simple RAG Agent package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;strings&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type BasicRAGAgent struct { name string memory core.Memory llm core.ModelProvider config RAGConfig } type RAGConfig struct { MaxRetrievalResults int ScoreThreshold float32 MaxContextLength int ContextTemplate string } func NewBasicRAGAgent(name string, memory core.Memory, llm core.ModelProvider) *BasicRAGAgent { return &amp;BasicRAGAgent{ name: name, memory: memory, llm: llm, config: RAGConfig{ MaxRetrievalResults: 5, ScoreThreshold: 0.7, MaxContextLength: 2000, ContextTemplate: `Based on the following information: %s Please answer the question: %s`, }, } } func (r *BasicRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract user query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) // Retrieve relevant context contextStr, sources, err := r.retrieveContext(ctx, queryStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := r.generateResponse(ctx, queryStr, contextStr) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store the interaction sessionID, _ := event.GetMetadataValue(core.SessionIDKey) err = r.storeInteraction(ctx, sessionID, queryStr, response, sources) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Return result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;sources&#34;, sources) outputState.Set(&#34;context_used&#34;, len(sources) &gt; 0) return core.AgentResult{OutputState: outputState}, nil } func (r *BasicRAGAgent) retrieveContext(ctx context.Context, query string) (string, []string, error) { // Search for relevant information results, err := r.memory.Search(ctx, query, core.WithLimit(r.config.MaxRetrievalResults), core.WithScoreThreshold(r.config.ScoreThreshold), ) if err != nil { return &#34;&#34;, nil, fmt.Errorf(&#34;search failed: %w&#34;, err) } if len(results) == 0 { return &#34;&#34;, nil, nil // No relevant context found } // Build context string var contextBuilder strings.Builder sources := make([]string, 0, len(results)) for i, result := range results { // Add numbered context item contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, result.Content)) // Track sources if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } else { sources = append(sources, fmt.Sprintf(&#34;Document %s&#34;, result.ID)) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; r.config.MaxContextLength { context = context[:r.config.MaxContextLength] &#43; &#34;...&#34; } return context, sources, nil } func (r *BasicRAGAgent) generateResponse(ctx context.Context, query, context string) (string, error) { var prompt string if context != &#34;&#34; { // Use context template prompt = fmt.Sprintf(r.config.ContextTemplate, context, query) } else { // Fallback to direct query prompt = fmt.Sprintf(&#34;Please answer the following question: %s&#34;, query) } // Generate response response, err := r.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;LLM generation failed: %w&#34;, err) } return response, nil } func (r *BasicRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, sources []string) error { // Store user query err := r.memory.Store(ctx, query, &#34;user-query&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-query&#34;, }), ) if err != nil { return err } // Store agent response with sources sourcesStr := strings.Join(sources, &#34;, &#34;) err = r.memory.Store(ctx, response, &#34;agent-response&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;interaction_type&#34;: &#34;rag-response&#34;, &#34;sources_used&#34;: sourcesStr, &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(sources)), }), ) return err } func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Setup LLM provider llm, err := core.NewOpenAIAdapter( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-3.5-turbo&#34;, 2000, 0.7, ) if err != nil { log.Fatalf(&#34;Failed to create LLM: %v&#34;, err) } // Create RAG agent ragAgent := NewBasicRAGAgent(&#34;rag-assistant&#34;, memory, llm) // Test the agent ctx := context.Background() // First, populate some knowledge knowledge := []string{ &#34;AgenticGoKit is a Go framework for building multi-agent systems with support for LLM integration, memory systems, and orchestration patterns.&#34;, &#34;Vector databases like pgvector and Weaviate are used in AgenticGoKit for semantic search and RAG implementations.&#34;, &#34;The framework supports multiple orchestration patterns including route, collaborative, sequential, and loop modes.&#34;, } for _, info := range knowledge { memory.Store(ctx, info, &#34;knowledge&#34;, core.WithMetadata(map[string]string{ &#34;source&#34;: &#34;documentation&#34;, &#34;topic&#34;: &#34;agenticgokit&#34;, }), ) } // Test query event := core.NewEvent( &#34;rag-assistant&#34;, core.EventData{&#34;message&#34;: &#34;What is AgenticGoKit and what databases does it support?&#34;}, map[string]string{&#34;session_id&#34;: &#34;test-session&#34;}, ) state := core.NewState() state.Set(&#34;message&#34;, &#34;What is AgenticGoKit and what databases does it support?&#34;) result, err := ragAgent.Run(ctx, event, state) if err != nil { log.Fatalf(&#34;RAG agent failed: %v&#34;, err) } response, _ := result.OutputState.Get(&#34;response&#34;) sources, _ := result.OutputState.Get(&#34;sources&#34;) fmt.Printf(&#34;Response: %s\n&#34;, response) fmt.Printf(&#34;Sources: %v\n&#34;, sources) }Advanced RAG Techniques 1. Query Enhancement type QueryEnhancer struct { llm core.LLMProvider } func NewQueryEnhancer(llm core.LLMProvider) *QueryEnhancer { return &amp;QueryEnhancer{llm: llm} } func (qe *QueryEnhancer) EnhanceQuery(ctx context.Context, originalQuery string, conversationHistory []core.Message) (string, error) { // Build context from conversation history var historyBuilder strings.Builder for _, msg := range conversationHistory { historyBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } // Create enhancement prompt prompt := fmt.Sprintf(`Given the conversation history: %s The user&#39;s current query is: &#34;%s&#34; Please rewrite this query to be more specific and searchable, incorporating relevant context from the conversation history. The enhanced query should be optimized for semantic search. Enhanced query:`, historyBuilder.String(), originalQuery) enhancedQuery, err := qe.llm.Generate(ctx, prompt) if err != nil { // Fallback to original query return originalQuery, nil } return strings.TrimSpace(enhancedQuery), nil } // Multi-query generation for better retrieval func (qe *QueryEnhancer) GenerateMultipleQueries(ctx context.Context, originalQuery string) ([]string, error) { prompt := fmt.Sprintf(`Given the query: &#34;%s&#34; Generate 3 different ways to ask the same question that would help find relevant information: 1. 2. 3.`, originalQuery) response, err := qe.llm.Generate(ctx, prompt) if err != nil { return []string{originalQuery}, nil } // Parse the numbered list lines := strings.Split(response, &#34;\n&#34;) queries := make([]string, 0, 3) for _, line := range lines { line = strings.TrimSpace(line) if strings.HasPrefix(line, &#34;1.&#34;) || strings.HasPrefix(line, &#34;2.&#34;) || strings.HasPrefix(line, &#34;3.&#34;) { query := strings.TrimSpace(line[2:]) if query != &#34;&#34; { queries = append(queries, query) } } } // Always include original query if len(queries) == 0 { queries = append(queries, originalQuery) } return queries, nil }2. Advanced Retrieval with Reranking type AdvancedRetriever struct { memory core.Memory reranker *Reranker config RetrievalConfig } type RetrievalConfig struct { InitialRetrievalLimit int FinalResultLimit int ScoreThreshold float64 RerankingEnabled bool DiversityThreshold float64 } type Reranker struct { llm core.LLMProvider } func NewReranker(llm core.LLMProvider) *Reranker { return &amp;Reranker{llm: llm} } func (r *Reranker) Rerank(ctx context.Context, query string, results []core.MemoryResult) ([]core.MemoryResult, error) { if len(results) &lt;= 1 { return results, nil } // Create reranking prompt var resultsBuilder strings.Builder resultsBuilder.WriteString(&#34;Rank the following passages by relevance to the query:\n\n&#34;) resultsBuilder.WriteString(fmt.Sprintf(&#34;Query: %s\n\n&#34;, query)) for i, result := range results { resultsBuilder.WriteString(fmt.Sprintf(&#34;Passage %d: %s\n\n&#34;, i&#43;1, result.Content)) } resultsBuilder.WriteString(&#34;Please rank these passages from most relevant (1) to least relevant, providing only the numbers separated by commas (e.g., 3,1,4,2):&#34;) response, err := r.llm.Generate(ctx, resultsBuilder.String()) if err != nil { // Fallback to original order return results, nil } // Parse ranking ranking := r.parseRanking(response, len(results)) // Reorder results based on ranking rerankedResults := make([]core.MemoryResult, 0, len(results)) for _, idx := range ranking { if idx &gt;= 0 &amp;&amp; idx &lt; len(results) { rerankedResults = append(rerankedResults, results[idx]) } } // Add any missing results used := make(map[int]bool) for _, idx := range ranking { used[idx] = true } for i, result := range results { if !used[i] { rerankedResults = append(rerankedResults, result) } } return rerankedResults, nil } func (r *Reranker) parseRanking(response string, maxItems int) []int { // Clean and split the response response = strings.TrimSpace(response) parts := strings.Split(response, &#34;,&#34;) ranking := make([]int, 0, len(parts)) for _, part := range parts { part = strings.TrimSpace(part) if num, err := strconv.Atoi(part); err == nil &amp;&amp; num &gt;= 1 &amp;&amp; num &lt;= maxItems { ranking = append(ranking, num-1) // Convert to 0-based index } } return ranking } func (ar *AdvancedRetriever) Retrieve(ctx context.Context, query string) ([]core.MemoryResult, error) { // Initial retrieval with higher limit results, err := ar.memory.Search(ctx, query, core.WithLimit(ar.config.InitialRetrievalLimit), core.WithScoreThreshold(ar.config.ScoreThreshold*0.8), // Lower threshold initially ) if err != nil { return nil, fmt.Errorf(&#34;initial retrieval failed: %w&#34;, err) } if len(results) == 0 { return results, nil } // Apply reranking if enabled if ar.config.RerankingEnabled &amp;&amp; ar.reranker != nil { results, err = ar.reranker.Rerank(ctx, query, results) if err != nil { log.Printf(&#34;Reranking failed, using original order: %v&#34;, err) } } // Apply diversity filtering if ar.config.DiversityThreshold &gt; 0 { results = ar.applyDiversityFilter(results) } // Limit final results if len(results) &gt; ar.config.FinalResultLimit { results = results[:ar.config.FinalResultLimit] } return results, nil } func (ar *AdvancedRetriever) applyDiversityFilter(results []core.MemoryResult) []core.MemoryResult { if len(results) &lt;= 1 { return results } filtered := []core.MemoryResult{results[0]} // Always include the top result for _, candidate := range results[1:] { isDiverse := true for _, selected := range filtered { similarity := ar.calculateSimilarity(candidate.Content, selected.Content) if similarity &gt; ar.config.DiversityThreshold { isDiverse = false break } } if isDiverse { filtered = append(filtered, candidate) } } return filtered } func (ar *AdvancedRetriever) calculateSimilarity(text1, text2 string) float64 { // Simple similarity calculation (in production, use proper similarity metrics) words1 := strings.Fields(strings.ToLower(text1)) words2 := strings.Fields(strings.ToLower(text2)) wordSet1 := make(map[string]bool) for _, word := range words1 { wordSet1[word] = true } common := 0 for _, word := range words2 { if wordSet1[word] { common&#43;&#43; } } if len(words1) == 0 || len(words2) == 0 { return 0 } return float64(common) / float64(len(words1)&#43;len(words2)-common) // Jaccard similarity }3. Context-Aware Response Generation type ContextAwareGenerator struct { llm core.LLMProvider config GenerationConfig } type GenerationConfig struct { MaxContextLength int ResponseMaxLength int IncludeSources bool FactCheckingEnabled bool TemperatureAdjustment float32 } func NewContextAwareGenerator(llm core.LLMProvider, config GenerationConfig) *ContextAwareGenerator { return &amp;ContextAwareGenerator{ llm: llm, config: config, } } func (cag *ContextAwareGenerator) Generate(ctx context.Context, query string, retrievedContext []core.MemoryResult, conversationHistory []core.Message) (string, error) { // Build comprehensive context context := cag.buildContext(query, retrievedContext, conversationHistory) // Create generation prompt prompt := cag.createPrompt(query, context, retrievedContext) // Generate response response, err := cag.llm.Generate(ctx, prompt) if err != nil { return &#34;&#34;, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Post-process response response = cag.postProcessResponse(response, retrievedContext) // Fact-check if enabled if cag.config.FactCheckingEnabled { response, err = cag.factCheck(ctx, response, retrievedContext) if err != nil { log.Printf(&#34;Fact-checking failed: %v&#34;, err) } } return response, nil } func (cag *ContextAwareGenerator) buildContext(query string, retrievedContext []core.MemoryResult, history []core.Message) string { var contextBuilder strings.Builder // Add conversation history if relevant if len(history) &gt; 0 { contextBuilder.WriteString(&#34;Recent conversation:\n&#34;) for _, msg := range history { contextBuilder.WriteString(fmt.Sprintf(&#34;%s: %s\n&#34;, msg.Role, msg.Content)) } contextBuilder.WriteString(&#34;\n&#34;) } // Add retrieved context if len(retrievedContext) &gt; 0 { contextBuilder.WriteString(&#34;Relevant information:\n&#34;) for i, result := range retrievedContext { contextBuilder.WriteString(fmt.Sprintf(&#34;%d. %s&#34;, i&#43;1, result.Content)) // Add source information if available if source, ok := result.Metadata[&#34;source&#34;]; ok { contextBuilder.WriteString(fmt.Sprintf(&#34; (Source: %s)&#34;, source)) } contextBuilder.WriteString(&#34;\n&#34;) } } context := contextBuilder.String() // Truncate if too long if len(context) &gt; cag.config.MaxContextLength { context = context[:cag.config.MaxContextLength] &#43; &#34;...\n[Context truncated]&#34; } return context } func (cag *ContextAwareGenerator) createPrompt(query, context string, retrievedContext []core.MemoryResult) string { var promptBuilder strings.Builder promptBuilder.WriteString(&#34;You are a knowledgeable assistant. Use the provided context to answer the user&#39;s question accurately and helpfully.\n\n&#34;) if context != &#34;&#34; { promptBuilder.WriteString(&#34;Context:\n&#34;) promptBuilder.WriteString(context) promptBuilder.WriteString(&#34;\n&#34;) } promptBuilder.WriteString(fmt.Sprintf(&#34;Question: %s\n\n&#34;, query)) promptBuilder.WriteString(&#34;Instructions:\n&#34;) promptBuilder.WriteString(&#34;- Answer based on the provided context\n&#34;) promptBuilder.WriteString(&#34;- If the context doesn&#39;t contain enough information, say so\n&#34;) promptBuilder.WriteString(&#34;- Be accurate and cite sources when possible\n&#34;) if cag.config.IncludeSources &amp;&amp; len(retrievedContext) &gt; 0 { promptBuilder.WriteString(&#34;- Include source references in your response\n&#34;) } promptBuilder.WriteString(&#34;\nAnswer:&#34;) return promptBuilder.String() } func (cag *ContextAwareGenerator) postProcessResponse(response string, context []core.MemoryResult) string { // Clean up response response = strings.TrimSpace(response) // Add source citations if configured if cag.config.IncludeSources &amp;&amp; len(context) &gt; 0 { response = cag.addSourceCitations(response, context) } // Truncate if too long if len(response) &gt; cag.config.ResponseMaxLength { response = response[:cag.config.ResponseMaxLength] &#43; &#34;...&#34; } return response } func (cag *ContextAwareGenerator) addSourceCitations(response string, context []core.MemoryResult) string { if len(context) == 0 { return response } var sourcesBuilder strings.Builder sourcesBuilder.WriteString(&#34;\n\nSources:\n&#34;) for i, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] %s\n&#34;, i&#43;1, source)) } else { sourcesBuilder.WriteString(fmt.Sprintf(&#34;[%d] Internal knowledge base\n&#34;, i&#43;1)) } } return response &#43; sourcesBuilder.String() } func (cag *ContextAwareGenerator) factCheck(ctx context.Context, response string, context []core.MemoryResult) (string, error) { // Create fact-checking prompt var contextBuilder strings.Builder for _, result := range context { contextBuilder.WriteString(fmt.Sprintf(&#34;- %s\n&#34;, result.Content)) } prompt := fmt.Sprintf(`Please fact-check the following response against the provided context: Context: %s Response to check: %s Is the response factually accurate based on the context? If there are any inaccuracies, please provide a corrected version. Fact-check result:`, contextBuilder.String(), response) factCheckResult, err := cag.llm.Generate(ctx, prompt) if err != nil { return response, err // Return original response if fact-checking fails } // Simple heuristic: if the fact-check suggests corrections, use them if strings.Contains(strings.ToLower(factCheckResult), &#34;corrected version&#34;) || strings.Contains(strings.ToLower(factCheckResult), &#34;inaccurate&#34;) { // Extract corrected version (this is a simplified approach) lines := strings.Split(factCheckResult, &#34;\n&#34;) for i, line := range lines { if strings.Contains(strings.ToLower(line), &#34;corrected&#34;) &amp;&amp; i&#43;1 &lt; len(lines) { return strings.TrimSpace(lines[i&#43;1]), nil } } } return response, nil }RAG Agent Integration 1. Complete RAG Agent type ComprehensiveRAGAgent struct { name string memory core.Memory llm core.LLMProvider queryEnhancer *QueryEnhancer retriever *AdvancedRetriever generator *ContextAwareGenerator conversationMgr *ConversationManager } type ConversationManager struct { memory core.Memory } func NewConversationManager(memory core.Memory) *ConversationManager { return &amp;ConversationManager{memory: memory} } func (cm *ConversationManager) GetRecentHistory(ctx context.Context, sessionID string, limit int) ([]core.Message, error) { return cm.memory.GetHistory(ctx, limit, core.WithSession(sessionID), core.WithTimeRange(time.Now().Add(-24*time.Hour), time.Now()), ) } func NewComprehensiveRAGAgent(name string, memory core.Memory, llm core.LLMProvider) *ComprehensiveRAGAgent { return &amp;ComprehensiveRAGAgent{ name: name, memory: memory, llm: llm, queryEnhancer: NewQueryEnhancer(llm), retriever: &amp;AdvancedRetriever{ memory: memory, reranker: NewReranker(llm), config: RetrievalConfig{ InitialRetrievalLimit: 10, FinalResultLimit: 5, ScoreThreshold: 0.7, RerankingEnabled: true, DiversityThreshold: 0.8, }, }, generator: NewContextAwareGenerator(llm, GenerationConfig{ MaxContextLength: 3000, ResponseMaxLength: 1500, IncludeSources: true, FactCheckingEnabled: true, TemperatureAdjustment: 0.1, }), conversationMgr: NewConversationManager(memory), } } func (cra *ComprehensiveRAGAgent) Run(ctx context.Context, event core.Event, state core.State) (core.AgentResult, error) { // Extract query query, ok := state.Get(&#34;message&#34;) if !ok { return core.AgentResult{}, fmt.Errorf(&#34;no message in state&#34;) } queryStr := query.(string) sessionID := event.GetSessionID() // Get conversation history history, err := cra.conversationMgr.GetRecentHistory(ctx, sessionID, 5) if err != nil { log.Printf(&#34;Failed to get conversation history: %v&#34;, err) history = []core.Message{} // Continue without history } // Enhance query with conversation context enhancedQuery, err := cra.queryEnhancer.EnhanceQuery(ctx, queryStr, history) if err != nil { log.Printf(&#34;Query enhancement failed: %v&#34;, err) enhancedQuery = queryStr // Fallback to original } // Retrieve relevant context retrievedContext, err := cra.retriever.Retrieve(ctx, enhancedQuery) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;retrieval failed: %w&#34;, err) } // Generate response with context response, err := cra.generator.Generate(ctx, queryStr, retrievedContext, history) if err != nil { return core.AgentResult{}, fmt.Errorf(&#34;generation failed: %w&#34;, err) } // Store interaction err = cra.storeInteraction(ctx, sessionID, queryStr, response, retrievedContext) if err != nil { log.Printf(&#34;Failed to store interaction: %v&#34;, err) } // Prepare result outputState := state.Clone() outputState.Set(&#34;response&#34;, response) outputState.Set(&#34;enhanced_query&#34;, enhancedQuery) outputState.Set(&#34;sources_count&#34;, len(retrievedContext)) outputState.Set(&#34;context_used&#34;, len(retrievedContext) &gt; 0) // Add source information sources := make([]string, 0, len(retrievedContext)) for _, result := range retrievedContext { if source, ok := result.Metadata[&#34;source&#34;]; ok { sources = append(sources, source) } } outputState.Set(&#34;sources&#34;, sources) return core.AgentResult{OutputState: outputState}, nil } func (cra *ComprehensiveRAGAgent) storeInteraction(ctx context.Context, sessionID, query, response string, context []core.MemoryResult) error { // Store user query err := cra.memory.Store(ctx, query, &#34;user-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, }), ) if err != nil { return err } // Store agent response with context metadata contextSources := make([]string, 0, len(context)) for _, result := range context { if source, ok := result.Metadata[&#34;source&#34;]; ok { contextSources = append(contextSources, source) } } err = cra.memory.Store(ctx, response, &#34;assistant-message&#34;, core.WithSession(sessionID), core.WithTimestamp(time.Now()), core.WithMetadata(map[string]string{ &#34;agent_type&#34;: &#34;comprehensive-rag&#34;, &#34;sources_used&#34;: strings.Join(contextSources, &#34;, &#34;), &#34;sources_count&#34;: fmt.Sprintf(&#34;%d&#34;, len(context)), &#34;context_length&#34;: fmt.Sprintf(&#34;%d&#34;, len(strings.Join(contextSources, &#34; &#34;))), }), ) return err }RAG Performance Optimization 1. Caching Strategies type RAGCache struct { retrievalCache map[string][]core.MemoryResult responseCache map[string]string mu sync.RWMutex ttl time.Duration timestamps map[string]time.Time } func NewRAGCache(ttl time.Duration) *RAGCache { cache := &amp;RAGCache{ retrievalCache: make(map[string][]core.MemoryResult), responseCache: make(map[string]string), timestamps: make(map[string]time.Time), ttl: ttl, } // Start cleanup goroutine go cache.cleanup() return cache } func (rc *RAGCache) GetRetrievalResults(query string) ([]core.MemoryResult, bool) { rc.mu.RLock() defer rc.mu.RUnlock() if timestamp, exists := rc.timestamps[query]; exists { if time.Since(timestamp) &lt; rc.ttl { if results, exists := rc.retrievalCache[query]; exists { return results, true } } } return nil, false } func (rc *RAGCache) SetRetrievalResults(query string, results []core.MemoryResult) { rc.mu.Lock() defer rc.mu.Unlock() rc.retrievalCache[query] = results rc.timestamps[query] = time.Now() } func (rc *RAGCache) cleanup() { ticker := time.NewTicker(rc.ttl / 2) defer ticker.Stop() for range ticker.C { rc.mu.Lock() now := time.Now() for query, timestamp := range rc.timestamps { if now.Sub(timestamp) &gt; rc.ttl { delete(rc.retrievalCache, query) delete(rc.responseCache, query) delete(rc.timestamps, query) } } rc.mu.Unlock() } }2. Batch Processing type BatchRAGProcessor struct { agent *ComprehensiveRAGAgent batchSize int timeout time.Duration } func NewBatchRAGProcessor(agent *ComprehensiveRAGAgent, batchSize int, timeout time.Duration) *BatchRAGProcessor { return &amp;BatchRAGProcessor{ agent: agent, batchSize: batchSize, timeout: timeout, } } func (brp *BatchRAGProcessor) ProcessBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { responses := make([]string, len(queries)) // Process in batches for i := 0; i &lt; len(queries); i &#43;= brp.batchSize { end := i &#43; brp.batchSize if end &gt; len(queries) { end = len(queries) } batch := queries[i:end] batchResponses, err := brp.processBatch(ctx, batch, sessionID) if err != nil { return nil, fmt.Errorf(&#34;batch processing failed: %w&#34;, err) } copy(responses[i:], batchResponses) } return responses, nil } func (brp *BatchRAGProcessor) processBatch(ctx context.Context, queries []string, sessionID string) ([]string, error) { ctx, cancel := context.WithTimeout(ctx, brp.timeout) defer cancel() responses := make([]string, len(queries)) var wg sync.WaitGroup var mu sync.Mutex var firstError error for i, query := range queries { wg.Add(1) go func(index int, q string) { defer wg.Done() event := core.NewEvent( brp.agent.name, core.EventData{&#34;message&#34;: q}, map[string]string{&#34;session_id&#34;: sessionID}, ) state := core.NewState() state.Set(&#34;message&#34;, q) result, err := brp.agent.Run(ctx, event, state) mu.Lock() defer mu.Unlock() if err != nil &amp;&amp; firstError == nil { firstError = err } else if err == nil { if response, ok := result.OutputState.Get(&#34;response&#34;); ok { responses[index] = response.(string) } } }(i, query) } wg.Wait() if firstError != nil { return nil, firstError } return responses, nil }RAG Evaluation and Monitoring 1. RAG Metrics type RAGMetrics struct { RetrievalLatency []time.Duration GenerationLatency []time.Duration RetrievalAccuracy float64 ResponseQuality float64 SourceUtilization map[string]int mu sync.RWMutex } func NewRAGMetrics() *RAGMetrics { return &amp;RAGMetrics{ SourceUtilization: make(map[string]int), } } func (rm *RAGMetrics) RecordRetrieval(latency time.Duration, resultsCount int, accuracy float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.RetrievalLatency = append(rm.RetrievalLatency, latency) rm.RetrievalAccuracy = (rm.RetrievalAccuracy &#43; accuracy) / 2 // Simple moving average } func (rm *RAGMetrics) RecordGeneration(latency time.Duration, quality float64) { rm.mu.Lock() defer rm.mu.Unlock() rm.GenerationLatency = append(rm.GenerationLatency, latency) rm.ResponseQuality = (rm.ResponseQuality &#43; quality) / 2 } func (rm *RAGMetrics) RecordSourceUsage(sources []string) { rm.mu.Lock() defer rm.mu.Unlock() for _, source := range sources { rm.SourceUtilization[source]&#43;&#43; } } func (rm *RAGMetrics) GetAverageRetrievalLatency() time.Duration { rm.mu.RLock() defer rm.mu.RUnlock() if len(rm.RetrievalLatency) == 0 { return 0 } var total time.Duration for _, latency := range rm.RetrievalLatency { total &#43;= latency } return total / time.Duration(len(rm.RetrievalLatency)) }2. Quality Assessment type RAGQualityAssessor struct { llm core.LLMProvider } func NewRAGQualityAssessor(llm core.LLMProvider) *RAGQualityAssessor { return &amp;RAGQualityAssessor{llm: llm} } func (rqa *RAGQualityAssessor) AssessResponse(ctx context.Context, query, response string, sources []core.MemoryResult) (float64, error) { // Build assessment prompt var sourcesBuilder strings.Builder for i, source := range sources { sourcesBuilder.WriteString(fmt.Sprintf(&#34;%d. %s\n&#34;, i&#43;1, source.Content)) } prompt := fmt.Sprintf(`Please assess the quality of this RAG response on a scale of 0.0 to 1.0: Query: %s Sources used: %s Response: %s Assessment criteria: - Accuracy: Is the response factually correct based on the sources? - Relevance: Does the response directly address the query? - Completeness: Does the response provide sufficient information? - Coherence: Is the response well-structured and clear? Please provide only a numerical score between 0.0 and 1.0:`, query, sourcesBuilder.String(), response) scoreStr, err := rqa.llm.Generate(ctx, prompt) if err != nil { return 0.0, fmt.Errorf(&#34;quality assessment failed: %w&#34;, err) } // Parse score scoreStr = strings.TrimSpace(scoreStr) score, err := strconv.ParseFloat(scoreStr, 64) if err != nil { return 0.0, fmt.Errorf(&#34;failed to parse quality score: %w&#34;, err) } // Clamp score to valid range if score &lt; 0.0 { score = 0.0 } else if score &gt; 1.0 { score = 1.0 } return score, nil }Best Practices 1. RAG System Design Chunk Size Optimization: Balance context and specificity Embedding Quality: Use appropriate embedding models for your domain Retrieval Tuning: Optimize similarity thresholds and result limits Context Management: Manage context length to avoid token limits Source Attribution: Always track and cite information sources 2. Performance Optimization Caching: Cache frequent queries and embeddings Batch Processing: Process multiple queries efficiently Index Optimization: Use appropriate vector database indexes Async Processing: Use asynchronous operations where possible 3. Quality Assurance Evaluation Metrics: Implement comprehensive evaluation Human Feedback: Collect and incorporate user feedback Continuous Monitoring: Monitor system performance and quality A/B Testing: Test different RAG configurations Conclusion RAG implementation in AgenticGoKit enables agents to provide accurate, contextual, and up-to-date responses by combining retrieval and generation. Key takeaways:">
    <meta itemprop="datePublished" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="dateModified" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="wordCount" content="3597">
    <title>rag-implementation :: AgenticGoKit Docs</title>
    <link href="/AgenticGoKitDocs/css/auto-complete/auto-complete.min.css?1753430931" rel="stylesheet">
    <script src="/AgenticGoKitDocs/js/auto-complete/auto-complete.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search-lunr.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/AgenticGoKitDocs/searchindex.en.js?1753430931";
    </script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.stemmer.support.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.multi.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.en.min.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet"></noscript>
    <link href="/AgenticGoKitDocs/css/perfect-scrollbar/perfect-scrollbar.min.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/theme.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/format-html.css?1753430931" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/tutorials\/memory-systems\/rag-implementation\/index.html';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='http:\/\/localhost:1313\/AgenticGoKitDocs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'blue' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
  </head>
  <body class="mobile-support html" data-url="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#prerequisites">Prerequisites</a></li>
    <li><a href="#rag-architecture">RAG Architecture</a>
      <ul>
        <li><a href="#basic-rag-flow">Basic RAG Flow</a></li>
        <li><a href="#advanced-rag-components">Advanced RAG Components</a></li>
      </ul>
    </li>
    <li><a href="#basic-rag-implementation">Basic RAG Implementation</a>
      <ul>
        <li><a href="#1-simple-rag-agent">1. Simple RAG Agent</a></li>
      </ul>
    </li>
    <li><a href="#advanced-rag-techniques">Advanced RAG Techniques</a>
      <ul>
        <li><a href="#1-query-enhancement">1. Query Enhancement</a></li>
        <li><a href="#2-advanced-retrieval-with-reranking">2. Advanced Retrieval with Reranking</a></li>
        <li><a href="#3-context-aware-response-generation">3. Context-Aware Response Generation</a></li>
      </ul>
    </li>
    <li><a href="#rag-agent-integration">RAG Agent Integration</a>
      <ul>
        <li><a href="#1-complete-rag-agent">1. Complete RAG Agent</a></li>
      </ul>
    </li>
    <li><a href="#rag-performance-optimization">RAG Performance Optimization</a>
      <ul>
        <li><a href="#1-caching-strategies">1. Caching Strategies</a></li>
        <li><a href="#2-batch-processing">2. Batch Processing</a></li>
      </ul>
    </li>
    <li><a href="#rag-evaluation-and-monitoring">RAG Evaluation and Monitoring</a>
      <ul>
        <li><a href="#1-rag-metrics">1. RAG Metrics</a></li>
        <li><a href="#2-quality-assessment">2. Quality Assessment</a></li>
      </ul>
    </li>
    <li><a href="#best-practices">Best Practices</a>
      <ul>
        <li><a href="#1-rag-system-design">1. RAG System Design</a></li>
        <li><a href="#2-performance-optimization">2. Performance Optimization</a></li>
        <li><a href="#3-quality-assurance">3. Quality Assurance</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#next-steps">Next Steps</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/index.html"><span itemprop="name">content</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/index.html"><span itemprop="name">tutorials</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><span itemprop="name">memory-systems</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">rag-implementation</span><meta itemprop="position" content="4"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html" title="memory-optimization (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html" title="vector-databases (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable tutorials" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="rag-implementation">rag-implementation</h1>

<h1 id="rag-implementation-in-agenticgokit">RAG Implementation in AgenticGoKit</h1>
<h2 id="overview">Overview</h2>
<p>Retrieval-Augmented Generation (RAG) combines the power of large language models with external knowledge retrieval to provide more accurate, up-to-date, and contextually relevant responses. This tutorial covers implementing RAG systems in AgenticGoKit, from basic retrieval to advanced techniques.</p>
<p>RAG enables agents to access vast amounts of information while maintaining the conversational abilities of language models, making them more knowledgeable and reliable.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Understanding of <a href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">Vector Databases</a></li>
<li>Familiarity with <a href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html">Basic Memory Operations</a></li>
<li>Knowledge of language model APIs</li>
<li>Basic understanding of information retrieval concepts</li>
</ul>
<h2 id="rag-architecture">RAG Architecture</h2>
<h3 id="basic-rag-flow">Basic RAG Flow</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>┌─────────────┐    ┌──────────────┐    ┌─────────────────┐
│ User Query  │───▶│   Retrieval  │───▶│ Context + Query │
└─────────────┘    │   System     │    └─────────────────┘
                   └──────────────┘             │
                           │                    ▼
                           ▼            ┌─────────────────┐
                   ┌──────────────┐    │ Language Model  │
                   │ Vector Store │    │   Generation    │
                   └──────────────┘    └─────────────────┘
                                               │
                                               ▼
                                       ┌─────────────────┐
                                       │ Enhanced        │
                                       │ Response        │
                                       └─────────────────┘</code></pre></div>
<h3 id="advanced-rag-components">Advanced RAG Components</h3>
<ol>
<li><strong>Query Processing</strong>: Understanding and reformulating user queries</li>
<li><strong>Retrieval</strong>: Finding relevant information from knowledge base</li>
<li><strong>Reranking</strong>: Improving relevance of retrieved results</li>
<li><strong>Context Building</strong>: Constructing effective prompts</li>
<li><strong>Generation</strong>: Producing responses with retrieved context</li>
<li><strong>Response Enhancement</strong>: Post-processing and validation</li>
</ol>
<h2 id="basic-rag-implementation">Basic RAG Implementation</h2>
<h3 id="1-simple-rag-agent">1. Simple RAG Agent</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/kunalkushwaha/agenticgokit/core&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BasicRAGAgent</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span>    <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ModelProvider</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span> <span style="color:#a6e22e">RAGConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RAGConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxRetrievalResults</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ScoreThreshold</span>      <span style="color:#66d9ef">float32</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxContextLength</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ContextTemplate</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewBasicRAGAgent</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ModelProvider</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">BasicRAGAgent</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">BasicRAGAgent</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:   <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>: <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">llm</span>:    <span style="color:#a6e22e">llm</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">RAGConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">MaxRetrievalResults</span>: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ScoreThreshold</span>:      <span style="color:#ae81ff">0.7</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">MaxContextLength</span>:    <span style="color:#ae81ff">2000</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ContextTemplate</span>: <span style="color:#e6db74">`Based on the following information:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">%s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Please answer the question: %s`</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BasicRAGAgent</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">event</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">state</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">State</span>) (<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract user query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;message&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;no message in state&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queryStr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">query</span>.(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Retrieve relevant context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">contextStr</span>, <span style="color:#a6e22e">sources</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">retrieveContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">queryStr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;retrieval failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Generate response with context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">generateResponse</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">queryStr</span>, <span style="color:#a6e22e">contextStr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;generation failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store the interaction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sessionID</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">GetMetadataValue</span>(<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">SessionIDKey</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">storeInteraction</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">sessionID</span>, <span style="color:#a6e22e">queryStr</span>, <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">sources</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to store interaction: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Return result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;response&#34;</span>, <span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;sources&#34;</span>, <span style="color:#a6e22e">sources</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;context_used&#34;</span>, len(<span style="color:#a6e22e">sources</span>) &gt; <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{<span style="color:#a6e22e">OutputState</span>: <span style="color:#a6e22e">outputState</span>}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BasicRAGAgent</span>) <span style="color:#a6e22e">retrieveContext</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, []<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Search for relevant information</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithLimit</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxRetrievalResults</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithScoreThreshold</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ScoreThreshold</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;search failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">results</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// No relevant context found</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Build context string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">contextBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sources</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">results</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add numbered context item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d. %s\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Track sources</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;source&#34;</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sources</span> = append(<span style="color:#a6e22e">sources</span>, <span style="color:#a6e22e">source</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sources</span> = append(<span style="color:#a6e22e">sources</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Document %s&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">ID</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">String</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Truncate if too long</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">context</span>) &gt; <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxContextLength</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">context</span> = <span style="color:#a6e22e">context</span>[:<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxContextLength</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;...&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">sources</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BasicRAGAgent</span>) <span style="color:#a6e22e">generateResponse</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">context</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">prompt</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">context</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Use context template</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prompt</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ContextTemplate</span>, <span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Fallback to direct query</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prompt</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Please answer the following question: %s&#34;</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Generate response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;LLM generation failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BasicRAGAgent</span>) <span style="color:#a6e22e">storeInteraction</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">sessionID</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">sources</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store user query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>, <span style="color:#e6db74">&#34;user-query&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSession</span>(<span style="color:#a6e22e">sessionID</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;interaction_type&#34;</span>: <span style="color:#e6db74">&#34;rag-query&#34;</span>,
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store agent response with sources</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sourcesStr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">sources</span>, <span style="color:#e6db74">&#34;, &#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">response</span>, <span style="color:#e6db74">&#34;agent-response&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSession</span>(<span style="color:#a6e22e">sessionID</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;interaction_type&#34;</span>: <span style="color:#e6db74">&#34;rag-response&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;sources_used&#34;</span>:     <span style="color:#a6e22e">sourcesStr</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;sources_count&#34;</span>:    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, len(<span style="color:#a6e22e">sources</span>)),
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setup memory with vector database</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewMemory</span>(<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentMemoryConfig</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Provider</span>:   <span style="color:#e6db74">&#34;pgvector&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Connection</span>: <span style="color:#e6db74">&#34;postgres://user:pass@localhost:5432/agentdb&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">EnableRAG</span>:  <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Dimensions</span>: <span style="color:#ae81ff">1536</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Embedding</span>: <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">EmbeddingConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Provider</span>:   <span style="color:#e6db74">&#34;openai&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Model</span>:      <span style="color:#e6db74">&#34;text-embedding-3-small&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">APIKey</span>:     <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;OPENAI_API_KEY&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Dimensions</span>: <span style="color:#ae81ff">1536</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Failed to create memory: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setup LLM provider</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewOpenAIAdapter</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;OPENAI_API_KEY&#34;</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;gpt-3.5-turbo&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">2000</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0.7</span>,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Failed to create LLM: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create RAG agent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ragAgent</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewBasicRAGAgent</span>(<span style="color:#e6db74">&#34;rag-assistant&#34;</span>, <span style="color:#a6e22e">memory</span>, <span style="color:#a6e22e">llm</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Test the agent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// First, populate some knowledge</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">knowledge</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;AgenticGoKit is a Go framework for building multi-agent systems with support for LLM integration, memory systems, and orchestration patterns.&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Vector databases like pgvector and Weaviate are used in AgenticGoKit for semantic search and RAG implementations.&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;The framework supports multiple orchestration patterns including route, collaborative, sequential, and loop modes.&#34;</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">info</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">knowledge</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">info</span>, <span style="color:#e6db74">&#34;knowledge&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;source&#34;</span>: <span style="color:#e6db74">&#34;documentation&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;topic&#34;</span>:  <span style="color:#e6db74">&#34;agenticgokit&#34;</span>,
</span></span><span style="display:flex;"><span>            }),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Test query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">event</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewEvent</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;rag-assistant&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">EventData</span>{<span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#e6db74">&#34;What is AgenticGoKit and what databases does it support?&#34;</span>},
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;session_id&#34;</span>: <span style="color:#e6db74">&#34;test-session&#34;</span>},
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewState</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;message&#34;</span>, <span style="color:#e6db74">&#34;What is AgenticGoKit and what databases does it support?&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ragAgent</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">state</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;RAG agent failed: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">OutputState</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;response&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sources</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">OutputState</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;sources&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Response: %s\n&#34;</span>, <span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Sources: %v\n&#34;</span>, <span style="color:#a6e22e">sources</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="advanced-rag-techniques">Advanced RAG Techniques</h2>
<h3 id="1-query-enhancement">1. Query Enhancement</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">QueryEnhancer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewQueryEnhancer</span>(<span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryEnhancer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">QueryEnhancer</span>{<span style="color:#a6e22e">llm</span>: <span style="color:#a6e22e">llm</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">qe</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryEnhancer</span>) <span style="color:#a6e22e">EnhanceQuery</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">originalQuery</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">conversationHistory</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Message</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Build context from conversation history</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">historyBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">conversationHistory</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">historyBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s: %s\n&#34;</span>, <span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">Role</span>, <span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create enhancement prompt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">`Given the conversation history:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">%s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The user&#39;s current query is: &#34;%s&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Please rewrite this query to be more specific and searchable, incorporating relevant context from the conversation history. The enhanced query should be optimized for semantic search.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Enhanced query:`</span>, <span style="color:#a6e22e">historyBuilder</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">originalQuery</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">enhancedQuery</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">qe</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Fallback to original query</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">originalQuery</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">enhancedQuery</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Multi-query generation for better retrieval</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">qe</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryEnhancer</span>) <span style="color:#a6e22e">GenerateMultipleQueries</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">originalQuery</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">`Given the query: &#34;%s&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Generate 3 different ways to ask the same question that would help find relevant information:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">2.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">3.`</span>, <span style="color:#a6e22e">originalQuery</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">qe</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">string</span>{<span style="color:#a6e22e">originalQuery</span>}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the numbered list</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">response</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queries</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;1.&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;2.&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;3.&#34;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">query</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">line</span>[<span style="color:#ae81ff">2</span>:])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">query</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queries</span> = append(<span style="color:#a6e22e">queries</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Always include original query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">queries</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queries</span> = append(<span style="color:#a6e22e">queries</span>, <span style="color:#a6e22e">originalQuery</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">queries</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-advanced-retrieval-with-reranking">2. Advanced Retrieval with Reranking</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AdvancedRetriever</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>   <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reranker</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reranker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span>   <span style="color:#a6e22e">RetrievalConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RetrievalConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitialRetrievalLimit</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FinalResultLimit</span>      <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ScoreThreshold</span>        <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RerankingEnabled</span>      <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DiversityThreshold</span>    <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reranker</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewReranker</span>(<span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Reranker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Reranker</span>{<span style="color:#a6e22e">llm</span>: <span style="color:#a6e22e">llm</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reranker</span>) <span style="color:#a6e22e">Rerank</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">results</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) ([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">results</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create reranking prompt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">resultsBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resultsBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Rank the following passages by relevance to the query:\n\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resultsBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Query: %s\n\n&#34;</span>, <span style="color:#a6e22e">query</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resultsBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Passage %d: %s\n\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resultsBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Please rank these passages from most relevant (1) to least relevant, providing only the numbers separated by commas (e.g., 3,1,4,2):&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">resultsBuilder</span>.<span style="color:#a6e22e">String</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Fallback to original order</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse ranking</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ranking</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">parseRanking</span>(<span style="color:#a6e22e">response</span>, len(<span style="color:#a6e22e">results</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Reorder results based on ranking</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rerankedResults</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">results</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">idx</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ranking</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">idx</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">idx</span> &lt; len(<span style="color:#a6e22e">results</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">rerankedResults</span> = append(<span style="color:#a6e22e">rerankedResults</span>, <span style="color:#a6e22e">results</span>[<span style="color:#a6e22e">idx</span>])
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add any missing results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">used</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">idx</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ranking</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">used</span>[<span style="color:#a6e22e">idx</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">used</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">rerankedResults</span> = append(<span style="color:#a6e22e">rerankedResults</span>, <span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rerankedResults</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reranker</span>) <span style="color:#a6e22e">parseRanking</span>(<span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">maxItems</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clean and split the response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">response</span>, <span style="color:#e6db74">&#34;,&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ranking</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">parts</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">part</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">parts</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">part</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">part</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">num</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">part</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">maxItems</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ranking</span> = append(<span style="color:#a6e22e">ranking</span>, <span style="color:#a6e22e">num</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// Convert to 0-based index</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ranking</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ar</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AdvancedRetriever</span>) <span style="color:#a6e22e">Retrieve</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initial retrieval with higher limit</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithLimit</span>(<span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">InitialRetrievalLimit</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithScoreThreshold</span>(<span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ScoreThreshold</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0.8</span>), <span style="color:#75715e">// Lower threshold initially</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;initial retrieval failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">results</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Apply reranking if enabled</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">RerankingEnabled</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">reranker</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">reranker</span>.<span style="color:#a6e22e">Rerank</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Reranking failed, using original order: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Apply diversity filtering</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">DiversityThreshold</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">results</span> = <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">applyDiversityFilter</span>(<span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Limit final results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">results</span>) &gt; <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">FinalResultLimit</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">results</span> = <span style="color:#a6e22e">results</span>[:<span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">FinalResultLimit</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ar</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AdvancedRetriever</span>) <span style="color:#a6e22e">applyDiversityFilter</span>(<span style="color:#a6e22e">results</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">results</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">filtered</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>{<span style="color:#a6e22e">results</span>[<span style="color:#ae81ff">0</span>]} <span style="color:#75715e">// Always include the top result</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">candidate</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span>[<span style="color:#ae81ff">1</span>:] {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">isDiverse</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">selected</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filtered</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">similarity</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">calculateSimilarity</span>(<span style="color:#a6e22e">candidate</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#a6e22e">selected</span>.<span style="color:#a6e22e">Content</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">similarity</span> &gt; <span style="color:#a6e22e">ar</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">DiversityThreshold</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">isDiverse</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isDiverse</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">filtered</span> = append(<span style="color:#a6e22e">filtered</span>, <span style="color:#a6e22e">candidate</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">filtered</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ar</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AdvancedRetriever</span>) <span style="color:#a6e22e">calculateSimilarity</span>(<span style="color:#a6e22e">text1</span>, <span style="color:#a6e22e">text2</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple similarity calculation (in production, use proper similarity metrics)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">words1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Fields</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">text1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">words2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Fields</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">text2</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wordSet1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">word</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">words1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wordSet1</span>[<span style="color:#a6e22e">word</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">common</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">word</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">words2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">wordSet1</span>[<span style="color:#a6e22e">word</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">common</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">words1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">words2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> float64(<span style="color:#a6e22e">common</span>) <span style="color:#f92672">/</span> float64(len(<span style="color:#a6e22e">words1</span>)<span style="color:#f92672">+</span>len(<span style="color:#a6e22e">words2</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">common</span>) <span style="color:#75715e">// Jaccard similarity</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="3-context-aware-response-generation">3. Context-Aware Response Generation</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ContextAwareGenerator</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span>    <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span> <span style="color:#a6e22e">GenerationConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GenerationConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxContextLength</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ResponseMaxLength</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IncludeSources</span>      <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FactCheckingEnabled</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">TemperatureAdjustment</span> <span style="color:#66d9ef">float32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewContextAwareGenerator</span>(<span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>, <span style="color:#a6e22e">config</span> <span style="color:#a6e22e">GenerationConfig</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ContextAwareGenerator</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">llm</span>:    <span style="color:#a6e22e">llm</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">config</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">retrievedContext</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#a6e22e">conversationHistory</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Message</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Build comprehensive context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">buildContext</span>(<span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">retrievedContext</span>, <span style="color:#a6e22e">conversationHistory</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create generation prompt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">createPrompt</span>(<span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">retrievedContext</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Generate response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;generation failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Post-process response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span> = <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">postProcessResponse</span>(<span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">retrievedContext</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Fact-check if enabled</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">FactCheckingEnabled</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">factCheck</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">retrievedContext</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Fact-checking failed: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">buildContext</span>(<span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">retrievedContext</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#a6e22e">history</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Message</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">contextBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add conversation history if relevant</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">history</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Recent conversation:\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">history</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s: %s\n&#34;</span>, <span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">Role</span>, <span style="color:#a6e22e">msg</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add retrieved context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">retrievedContext</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Relevant information:\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">retrievedContext</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d. %s&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Add source information if available</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;source&#34;</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34; (Source: %s)&#34;</span>, <span style="color:#a6e22e">source</span>))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">String</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Truncate if too long</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">context</span>) &gt; <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxContextLength</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">context</span> = <span style="color:#a6e22e">context</span>[:<span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxContextLength</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;...\n[Context truncated]&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">context</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">createPrompt</span>(<span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">context</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">retrievedContext</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">promptBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;You are a knowledgeable assistant. Use the provided context to answer the user&#39;s question accurately and helpfully.\n\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">context</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Context:\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">context</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Question: %s\n\n&#34;</span>, <span style="color:#a6e22e">query</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Instructions:\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;- Answer based on the provided context\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;- If the context doesn&#39;t contain enough information, say so\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;- Be accurate and cite sources when possible\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">IncludeSources</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">retrievedContext</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;- Include source references in your response\n&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\nAnswer:&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promptBuilder</span>.<span style="color:#a6e22e">String</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">postProcessResponse</span>(<span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">context</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clean up response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add source citations if configured</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">IncludeSources</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">context</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">response</span> = <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">addSourceCitations</span>(<span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">context</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Truncate if too long</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">response</span>) &gt; <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ResponseMaxLength</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">response</span> = <span style="color:#a6e22e">response</span>[:<span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ResponseMaxLength</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;...&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">addSourceCitations</span>(<span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">context</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">context</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sourcesBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;\n\nSources:\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">context</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;source&#34;</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[%d] %s\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">source</span>))
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[%d] Internal knowledge base\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">String</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cag</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>) <span style="color:#a6e22e">factCheck</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">context</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create fact-checking prompt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">contextBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">context</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;- %s\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">`Please fact-check the following response against the provided context:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Context:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">%s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Response to check:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">%s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Is the response factually accurate based on the context? If there are any inaccuracies, please provide a corrected version.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Fact-check result:`</span>, <span style="color:#a6e22e">contextBuilder</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">factCheckResult</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cag</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#75715e">// Return original response if fact-checking fails</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simple heuristic: if the fact-check suggests corrections, use them</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">factCheckResult</span>), <span style="color:#e6db74">&#34;corrected version&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">factCheckResult</span>), <span style="color:#e6db74">&#34;inaccurate&#34;</span>) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Extract corrected version (this is a simplified approach)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">factCheckResult</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">line</span>), <span style="color:#e6db74">&#34;corrected&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> &lt; len(<span style="color:#a6e22e">lines</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">lines</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="rag-agent-integration">RAG Agent Integration</h2>
<h3 id="1-complete-rag-agent">1. Complete RAG Agent</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ComprehensiveRAGAgent</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>              <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>            <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span>               <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queryEnhancer</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">QueryEnhancer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">retriever</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">AdvancedRetriever</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">generator</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">ContextAwareGenerator</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">conversationMgr</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">ConversationManager</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ConversationManager</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewConversationManager</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ConversationManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ConversationManager</span>{<span style="color:#a6e22e">memory</span>: <span style="color:#a6e22e">memory</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConversationManager</span>) <span style="color:#a6e22e">GetRecentHistory</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">sessionID</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">limit</span> <span style="color:#66d9ef">int</span>) ([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Message</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cm</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">GetHistory</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">limit</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSession</span>(<span style="color:#a6e22e">sessionID</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimeRange</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Add</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">24</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Hour</span>), <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewComprehensiveRAGAgent</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>, <span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:            <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>:          <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">llm</span>:             <span style="color:#a6e22e">llm</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queryEnhancer</span>:   <span style="color:#a6e22e">NewQueryEnhancer</span>(<span style="color:#a6e22e">llm</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">retriever</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">AdvancedRetriever</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">memory</span>:   <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">reranker</span>: <span style="color:#a6e22e">NewReranker</span>(<span style="color:#a6e22e">llm</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">RetrievalConfig</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">InitialRetrievalLimit</span>: <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">FinalResultLimit</span>:      <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">ScoreThreshold</span>:        <span style="color:#ae81ff">0.7</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">RerankingEnabled</span>:      <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">DiversityThreshold</span>:    <span style="color:#ae81ff">0.8</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">generator</span>: <span style="color:#a6e22e">NewContextAwareGenerator</span>(<span style="color:#a6e22e">llm</span>, <span style="color:#a6e22e">GenerationConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">MaxContextLength</span>:      <span style="color:#ae81ff">3000</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ResponseMaxLength</span>:     <span style="color:#ae81ff">1500</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">IncludeSources</span>:        <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">FactCheckingEnabled</span>:   <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">TemperatureAdjustment</span>: <span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">conversationMgr</span>: <span style="color:#a6e22e">NewConversationManager</span>(<span style="color:#a6e22e">memory</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cra</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">event</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">state</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">State</span>) (<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;message&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;no message in state&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queryStr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">query</span>.(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sessionID</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">GetSessionID</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get conversation history</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">history</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">conversationMgr</span>.<span style="color:#a6e22e">GetRecentHistory</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">sessionID</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to get conversation history: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">history</span> = []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Message</span>{} <span style="color:#75715e">// Continue without history</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Enhance query with conversation context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">enhancedQuery</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">queryEnhancer</span>.<span style="color:#a6e22e">EnhanceQuery</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">queryStr</span>, <span style="color:#a6e22e">history</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Query enhancement failed: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">enhancedQuery</span> = <span style="color:#a6e22e">queryStr</span> <span style="color:#75715e">// Fallback to original</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Retrieve relevant context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">retrievedContext</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">retriever</span>.<span style="color:#a6e22e">Retrieve</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">enhancedQuery</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;retrieval failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Generate response with context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">queryStr</span>, <span style="color:#a6e22e">retrievedContext</span>, <span style="color:#a6e22e">history</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{}, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;generation failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store interaction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">storeInteraction</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">sessionID</span>, <span style="color:#a6e22e">queryStr</span>, <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">retrievedContext</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to store interaction: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prepare result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;response&#34;</span>, <span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;enhanced_query&#34;</span>, <span style="color:#a6e22e">enhancedQuery</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;sources_count&#34;</span>, len(<span style="color:#a6e22e">retrievedContext</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;context_used&#34;</span>, len(<span style="color:#a6e22e">retrievedContext</span>) &gt; <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add source information</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sources</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">retrievedContext</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">retrievedContext</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;source&#34;</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sources</span> = append(<span style="color:#a6e22e">sources</span>, <span style="color:#a6e22e">source</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outputState</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;sources&#34;</span>, <span style="color:#a6e22e">sources</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentResult</span>{<span style="color:#a6e22e">OutputState</span>: <span style="color:#a6e22e">outputState</span>}, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cra</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span>) <span style="color:#a6e22e">storeInteraction</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">sessionID</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">context</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store user query</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>, <span style="color:#e6db74">&#34;user-message&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSession</span>(<span style="color:#a6e22e">sessionID</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;agent_type&#34;</span>: <span style="color:#e6db74">&#34;comprehensive-rag&#34;</span>,
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store agent response with context metadata</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">contextSources</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">context</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">context</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;source&#34;</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">contextSources</span> = append(<span style="color:#a6e22e">contextSources</span>, <span style="color:#a6e22e">source</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">cra</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">response</span>, <span style="color:#e6db74">&#34;assistant-message&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithSession</span>(<span style="color:#a6e22e">sessionID</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;agent_type&#34;</span>:     <span style="color:#e6db74">&#34;comprehensive-rag&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;sources_used&#34;</span>:   <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">contextSources</span>, <span style="color:#e6db74">&#34;, &#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;sources_count&#34;</span>:  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, len(<span style="color:#a6e22e">context</span>)),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;context_length&#34;</span>: <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, len(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">contextSources</span>, <span style="color:#e6db74">&#34; &#34;</span>))),
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="rag-performance-optimization">RAG Performance Optimization</h2>
<h3 id="1-caching-strategies">1. Caching Strategies</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RAGCache</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">retrievalCache</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">responseCache</span>  <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>             <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ttl</span>            <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">timestamps</span>     <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewRAGCache</span>(<span style="color:#a6e22e">ttl</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGCache</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cache</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RAGCache</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">retrievalCache</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">responseCache</span>:  make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">timestamps</span>:     make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ttl</span>:            <span style="color:#a6e22e">ttl</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Start cleanup goroutine</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">cleanup</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGCache</span>) <span style="color:#a6e22e">GetRetrievalResults</span>(<span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">timestamp</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">timestamps</span>[<span style="color:#a6e22e">query</span>]; <span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">timestamp</span>) &lt; <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">ttl</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">retrievalCache</span>[<span style="color:#a6e22e">query</span>]; <span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGCache</span>) <span style="color:#a6e22e">SetRetrievalResults</span>(<span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">results</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">retrievalCache</span>[<span style="color:#a6e22e">query</span>] = <span style="color:#a6e22e">results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">timestamps</span>[<span style="color:#a6e22e">query</span>] = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGCache</span>) <span style="color:#a6e22e">cleanup</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ticker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTicker</span>(<span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">ttl</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">Stop</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">timestamp</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">timestamps</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">timestamp</span>) &gt; <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">ttl</span> {
</span></span><span style="display:flex;"><span>                delete(<span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">retrievalCache</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>                delete(<span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">responseCache</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>                delete(<span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">timestamps</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-batch-processing">2. Batch Processing</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BatchRAGProcessor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">agent</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">batchSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">timeout</span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewBatchRAGProcessor</span>(<span style="color:#a6e22e">agent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ComprehensiveRAGAgent</span>, <span style="color:#a6e22e">batchSize</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">timeout</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchRAGProcessor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">BatchRAGProcessor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">agent</span>:     <span style="color:#a6e22e">agent</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batchSize</span>: <span style="color:#a6e22e">batchSize</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">timeout</span>:   <span style="color:#a6e22e">timeout</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">brp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchRAGProcessor</span>) <span style="color:#a6e22e">ProcessBatch</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">queries</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">sessionID</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">responses</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">queries</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process in batches</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">queries</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">batchSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">batchSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">queries</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">queries</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queries</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">end</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batchResponses</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">processBatch</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">batch</span>, <span style="color:#a6e22e">sessionID</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;batch processing failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        copy(<span style="color:#a6e22e">responses</span>[<span style="color:#a6e22e">i</span>:], <span style="color:#a6e22e">batchResponses</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">responses</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">brp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BatchRAGProcessor</span>) <span style="color:#a6e22e">processBatch</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">queries</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">sessionID</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">timeout</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">responses</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">queries</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">firstError</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">query</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">queries</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">q</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">event</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewEvent</span>(
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">agent</span>.<span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">EventData</span>{<span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#a6e22e">q</span>},
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;session_id&#34;</span>: <span style="color:#a6e22e">sessionID</span>},
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewState</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;message&#34;</span>, <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">brp</span>.<span style="color:#a6e22e">agent</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">state</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">firstError</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">firstError</span> = <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">OutputState</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;response&#34;</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">responses</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#a6e22e">response</span>.(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">query</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">firstError</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">firstError</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">responses</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="rag-evaluation-and-monitoring">RAG Evaluation and Monitoring</h2>
<h3 id="1-rag-metrics">1. RAG Metrics</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RAGMetrics</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RetrievalLatency</span>    []<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">GenerationLatency</span>   []<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RetrievalAccuracy</span>   <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ResponseQuality</span>     <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SourceUtilization</span>   <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>                  <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewRAGMetrics</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGMetrics</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RAGMetrics</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SourceUtilization</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGMetrics</span>) <span style="color:#a6e22e">RecordRetrieval</span>(<span style="color:#a6e22e">latency</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">resultsCount</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">accuracy</span> <span style="color:#66d9ef">float64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalLatency</span> = append(<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalLatency</span>, <span style="color:#a6e22e">latency</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalAccuracy</span> = (<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalAccuracy</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">accuracy</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e">// Simple moving average</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGMetrics</span>) <span style="color:#a6e22e">RecordGeneration</span>(<span style="color:#a6e22e">latency</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">quality</span> <span style="color:#66d9ef">float64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">GenerationLatency</span> = append(<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">GenerationLatency</span>, <span style="color:#a6e22e">latency</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">ResponseQuality</span> = (<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">ResponseQuality</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">quality</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGMetrics</span>) <span style="color:#a6e22e">RecordSourceUsage</span>(<span style="color:#a6e22e">sources</span> []<span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">source</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sources</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">SourceUtilization</span>[<span style="color:#a6e22e">source</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGMetrics</span>) <span style="color:#a6e22e">GetAverageRetrievalLatency</span>() <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalLatency</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">total</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">latency</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalLatency</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">latency</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">total</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(len(<span style="color:#a6e22e">rm</span>.<span style="color:#a6e22e">RetrievalLatency</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-quality-assessment">2. Quality Assessment</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RAGQualityAssessor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewRAGQualityAssessor</span>(<span style="color:#a6e22e">llm</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">LLMProvider</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGQualityAssessor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RAGQualityAssessor</span>{<span style="color:#a6e22e">llm</span>: <span style="color:#a6e22e">llm</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rqa</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RAGQualityAssessor</span>) <span style="color:#a6e22e">AssessResponse</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">response</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">sources</span> []<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>) (<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Build assessment prompt</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sourcesBuilder</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">source</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sources</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d. %s\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">source</span>.<span style="color:#a6e22e">Content</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">`Please assess the quality of this RAG response on a scale of 0.0 to 1.0:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Query: %s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Sources used:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">%s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Response: %s
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Assessment criteria:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- Accuracy: Is the response factually correct based on the sources?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- Relevance: Does the response directly address the query?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- Completeness: Does the response provide sufficient information?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- Coherence: Is the response well-structured and clear?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Please provide only a numerical score between 0.0 and 1.0:`</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">sourcesBuilder</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">response</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scoreStr</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rqa</span>.<span style="color:#a6e22e">llm</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">prompt</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;quality assessment failed: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse score</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scoreStr</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">scoreStr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">score</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseFloat</span>(<span style="color:#a6e22e">scoreStr</span>, <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to parse quality score: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clamp score to valid range</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> &lt; <span style="color:#ae81ff">0.0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> &gt; <span style="color:#ae81ff">1.0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">score</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="best-practices">Best Practices</h2>
<h3 id="1-rag-system-design">1. RAG System Design</h3>
<ul>
<li><strong>Chunk Size Optimization</strong>: Balance context and specificity</li>
<li><strong>Embedding Quality</strong>: Use appropriate embedding models for your domain</li>
<li><strong>Retrieval Tuning</strong>: Optimize similarity thresholds and result limits</li>
<li><strong>Context Management</strong>: Manage context length to avoid token limits</li>
<li><strong>Source Attribution</strong>: Always track and cite information sources</li>
</ul>
<h3 id="2-performance-optimization">2. Performance Optimization</h3>
<ul>
<li><strong>Caching</strong>: Cache frequent queries and embeddings</li>
<li><strong>Batch Processing</strong>: Process multiple queries efficiently</li>
<li><strong>Index Optimization</strong>: Use appropriate vector database indexes</li>
<li><strong>Async Processing</strong>: Use asynchronous operations where possible</li>
</ul>
<h3 id="3-quality-assurance">3. Quality Assurance</h3>
<ul>
<li><strong>Evaluation Metrics</strong>: Implement comprehensive evaluation</li>
<li><strong>Human Feedback</strong>: Collect and incorporate user feedback</li>
<li><strong>Continuous Monitoring</strong>: Monitor system performance and quality</li>
<li><strong>A/B Testing</strong>: Test different RAG configurations</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>RAG implementation in AgenticGoKit enables agents to provide accurate, contextual, and up-to-date responses by combining retrieval and generation. Key takeaways:</p>
<ul>
<li>Start with basic RAG and gradually add advanced features</li>
<li>Optimize retrieval quality through query enhancement and reranking</li>
<li>Implement proper caching and performance monitoring</li>
<li>Continuously evaluate and improve system quality</li>
</ul>
<p>RAG transforms agents from static responders to dynamic, knowledgeable assistants that can access and utilize vast amounts of information effectively.</p>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">Knowledge Bases</a> - Build comprehensive knowledge systems</li>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">Memory Optimization</a> - Advanced performance tuning</li>
<li><a href="/AgenticGoKitDocs/guides/deployment/readme/index.html">Production Deployment</a> - Deploy RAG systems at scale</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://arxiv.org/abs/2005.11401" rel="external" target="_blank">RAG Research Papers</a></li>
<li><a href="https://github.com/pgvector/pgvector" rel="external" target="_blank">Vector Database Comparison</a></li>
<li><a href="https://huggingface.co/spaces/mteb/leaderboard" rel="external" target="_blank">Embedding Model Evaluation</a></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Jul 25, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/AgenticGoKitDocs/index.html">
            <div class="logo-title">AgenticGoKit Docs</div>
          </a>
        </div>
        <search><form action="/AgenticGoKitDocs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/index.html"><a class="padding" href="/AgenticGoKitDocs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/readme/index.html">content</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/index.html"><input type="checkbox" id="R-section-8fc2fd7736125e87cab8840a86c2af5a" aria-controls="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" checked><label for="R-section-8fc2fd7736125e87cab8840a86c2af5a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu guides</span></label><a class="padding" href="/AgenticGoKitDocs/guides/index.html">guides</a><ul id="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/readme/index.html">guides</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/agentbasics/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/agentbasics/index.html">AgentBasics</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/examples/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/examples/index.html">Examples</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/configuration/index.html">Configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/customtools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/customtools/index.html">CustomTools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/providers/index.html">Providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html">MemoryProviderSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html">MemoryTroubleshooting</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html">EmbeddingModelGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/ragconfiguration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/ragconfiguration/index.html">RAGConfiguration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/toolintegration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/toolintegration/index.html">ToolIntegration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/pgvectorsetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/pgvectorsetup/index.html">PgVectorSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/weaviatesetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/weaviatesetup/index.html">WeaviateSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/performance/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/performance/index.html">Performance</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/errorhandling/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/errorhandling/index.html">ErrorHandling</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/deployment/index.html"><input type="checkbox" id="R-section-ecc839349395ef3c015a12132049dff2" aria-controls="R-subsections-ecc839349395ef3c015a12132049dff2" checked><label for="R-section-ecc839349395ef3c015a12132049dff2"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu deployment</span></label><a class="padding" href="/AgenticGoKitDocs/guides/deployment/index.html">deployment</a><ul id="R-subsections-ecc839349395ef3c015a12132049dff2" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/deployment/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/deployment/readme/index.html">deployment</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/development/index.html"><input type="checkbox" id="R-section-fff1f5eca5d0a93209b9c6262762c25a" aria-controls="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" checked><label for="R-section-fff1f5eca5d0a93209b9c6262762c25a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu development</span></label><a class="padding" href="/AgenticGoKitDocs/guides/development/index.html">development</a><ul id="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/readme/index.html">development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/best-practices/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/best-practices/index.html">best-practices</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/debugging/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/debugging/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/research-assistant/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/research-assistant/index.html">research-assistant</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/testing-agents/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/testing-agents/index.html">testing-agents</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/visualization/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/visualization/index.html">visualization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/web-search-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/web-search-integration/index.html">web-search-integration</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/framework-comparison/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/framework-comparison/index.html">framework-comparison</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memory/index.html">Memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html">ScaffoldMemoryGuide</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/setup/index.html"><input type="checkbox" id="R-section-0124aed9abb5064d53391168f3c95c22" aria-controls="R-subsections-0124aed9abb5064d53391168f3c95c22" checked><label for="R-section-0124aed9abb5064d53391168f3c95c22"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu setup</span></label><a class="padding" href="/AgenticGoKitDocs/guides/setup/index.html">setup</a><ul id="R-subsections-0124aed9abb5064d53391168f3c95c22" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/readme/index.html">setup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/llm-providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/llm-providers/index.html">llm-providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html">mcp-tools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html">orchestration-configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/vector-databases/index.html">vector-databases</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/troubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/troubleshooting/index.html">troubleshooting</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/contributors/index.html"><input type="checkbox" id="R-section-190d9b328fbda7e13ab386f7a5417de5" aria-controls="R-subsections-190d9b328fbda7e13ab386f7a5417de5" checked><label for="R-section-190d9b328fbda7e13ab386f7a5417de5"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu contributors</span></label><a class="padding" href="/AgenticGoKitDocs/contributors/index.html">contributors</a><ul id="R-subsections-190d9b328fbda7e13ab386f7a5417de5" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/readme/index.html">contributors</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/contributorguide/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/contributorguide/index.html">ContributorGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/codestyle/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/codestyle/index.html">CodeStyle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/corevsinternal/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/corevsinternal/index.html">CoreVsInternal</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/addingfeatures/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/addingfeatures/index.html">AddingFeatures</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/testing/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/testing/index.html">Testing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/docsstandards/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/docsstandards/index.html">DocsStandards</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/reference/index.html"><input type="checkbox" id="R-section-66002f201bef818664bb81aa67490c58" aria-controls="R-subsections-66002f201bef818664bb81aa67490c58" checked><label for="R-section-66002f201bef818664bb81aa67490c58"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu reference</span></label><a class="padding" href="/AgenticGoKitDocs/reference/index.html">reference</a><ul id="R-subsections-66002f201bef818664bb81aa67490c58" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/readme/index.html">reference</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/configuration/index.html">configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/cli/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/cli/index.html">cli</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/mcp/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/mcp/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/agent/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/agent/index.html">agent</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/memory/index.html">memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/orchestration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/orchestration/index.html">orchestration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/state-event/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/state-event/index.html">state-event</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/index.html"><input type="checkbox" id="R-section-e1e8c1e70c5500b49e8dda2dc550651a" aria-controls="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" checked><label for="R-section-e1e8c1e70c5500b49e8dda2dc550651a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu tutorials</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/index.html">tutorials</a><ul id="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/readme/index.html">tutorials</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/advanced/index.html"><input type="checkbox" id="R-section-d3def5cd76adc8096d0ff9fda6b8e479" aria-controls="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" checked><label for="R-section-d3def5cd76adc8096d0ff9fda6b8e479"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu advanced</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/index.html">advanced</a><ul id="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/readme/index.html">advanced</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html">circuit-breaker-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html">load-balancing-scaling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html">retry-policies</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html">testing-strategies</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/index.html"><input type="checkbox" id="R-section-212c6ccffb40ecdd78eb2136f98c4cac" aria-controls="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" checked><label for="R-section-212c6ccffb40ecdd78eb2136f98c4cac"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu core-concepts</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/index.html">core-concepts</a><ul id="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html">core-concepts</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html">agent-lifecycle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html">error-handling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html">message-passing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">orchestration-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html">state-management</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/debugging/index.html"><input type="checkbox" id="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" aria-controls="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" checked><label for="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu debugging</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/index.html">debugging</a><ul id="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/readme/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html">debugging-multi-agent-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html">logging-and-tracing</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/index.html"><input type="checkbox" id="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247" aria-controls="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" checked><label for="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu getting-started</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/index.html">getting-started</a><ul id="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html">getting-started</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html">memory-and-rag</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html">multi-agent-collaboration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html">production-deployment</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html">quickstart</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html">tool-integration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html">your-first-agent</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/mcp/index.html"><input type="checkbox" id="R-section-153aac44598009a99dd5a60317a3eecc" aria-controls="R-subsections-153aac44598009a99dd5a60317a3eecc" checked><label for="R-section-153aac44598009a99dd5a60317a3eecc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu mcp</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/index.html">mcp</a><ul id="R-subsections-153aac44598009a99dd5a60317a3eecc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">advanced-tool-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">tool-development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">tool-integration</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><input type="checkbox" id="R-section-9c1a65f2d7b3888241dcafa51a0710e7" aria-controls="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" checked><label for="R-section-9c1a65f2d7b3888241dcafa51a0710e7"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu memory-systems</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html">memory-systems</a><ul id="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">memory-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html">basic-memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">document-ingestion</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">knowledge-bases</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">memory-optimization</a></li>
            <li class="active " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">rag-implementation</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">vector-databases</a></li></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/AgenticGoKitDocs/js/clipboard/clipboard.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/perfect-scrollbar/perfect-scrollbar.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/theme.js?1753430931" defer></script>
  </body>
</html>
