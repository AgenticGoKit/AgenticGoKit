<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head><script src="/AgenticGoKitDocs/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=AgenticGoKitDocs/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="description" content="Knowledge Bases in AgenticGoKit Overview Knowledge bases are structured repositories of information that enable agents to access, search, and reason over large collections of documents and data. This tutorial covers building comprehensive knowledge bases with AgenticGoKit, including document ingestion, chunking strategies, metadata management, and search optimization.
Knowledge bases transform raw information into accessible, searchable knowledge that agents can use to provide accurate and contextual responses.
Prerequisites Understanding of RAG Implementation Familiarity with Vector Databases Knowledge of document processing and text extraction Basic understanding of information retrieval concepts Knowledge Base Architecture Components Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Documents │───▶│ Ingestion │───▶│ Processing ││ (PDF, MD, │ │ Pipeline │ │ Pipeline ││ HTML, etc.) │ └──────────────────┘ └─────────────────┘└─────────────────┘ │▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Search &amp; │◀───│ Vector Store │◀───│ Chunking &amp; ││ Retrieval │ │ (pgvector/ │ │ Embedding │└─────────────────┘ │ Weaviate) │ └─────────────────┘└──────────────────┘Knowledge Base Layers Storage Layer: Vector database with metadata Processing Layer: Document parsing and chunking Embedding Layer: Vector representation generation Retrieval Layer: Search and ranking algorithms Management Layer: Updates, versioning, and maintenance Document Ingestion Pipeline 1. Basic Document Processor package main import ( &#34;context&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;path/filepath&#34; &#34;strings&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type DocumentProcessor struct { memory core.Memory parsers map[string]DocumentParser chunker *DocumentChunker config ProcessingConfig } type ProcessingConfig struct { ChunkSize int ChunkOverlap int MaxFileSize int64 SupportedFormats []string BatchSize int } type DocumentParser interface { Parse(filePath string) (*Document, error) SupportedExtensions() []string } type Document struct { ID string Title string Content string Metadata map[string]string Source string CreatedAt time.Time UpdatedAt time.Time } func NewDocumentProcessor(memory core.Memory) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, parsers: make(map[string]DocumentParser), chunker: NewDocumentChunker(ChunkingConfig{ ChunkSize: 1000, ChunkOverlap: 200, Strategy: &#34;semantic&#34;, }), config: ProcessingConfig{ ChunkSize: 1000, ChunkOverlap: 200, MaxFileSize: 10 * 1024 * 1024, // 10MB SupportedFormats: []string{&#34;.txt&#34;, &#34;.md&#34;, &#34;.pdf&#34;, &#34;.html&#34;}, BatchSize: 10, }, } // Register parsers dp.registerParsers() return dp } func (dp *DocumentProcessor) registerParsers() { dp.parsers[&#34;.txt&#34;] = &amp;TextParser{} dp.parsers[&#34;.md&#34;] = &amp;MarkdownParser{} dp.parsers[&#34;.pdf&#34;] = &amp;PDFParser{} dp.parsers[&#34;.html&#34;] = &amp;HTMLParser{} } func (dp *DocumentProcessor) ProcessFile(ctx context.Context, filePath string) error { // Check file size fileInfo, err := os.Stat(filePath) if err != nil { return fmt.Errorf(&#34;failed to stat file: %w&#34;, err) } if fileInfo.Size() &gt; dp.config.MaxFileSize { return fmt.Errorf(&#34;file too large: %d bytes&#34;, fileInfo.Size()) } // Get parser for file extension ext := strings.ToLower(filepath.Ext(filePath)) parser, exists := dp.parsers[ext] if !exists { return fmt.Errorf(&#34;unsupported file format: %s&#34;, ext) } // Parse document doc, err := parser.Parse(filePath) if err != nil { return fmt.Errorf(&#34;failed to parse document: %w&#34;, err) } // Add file metadata doc.Metadata[&#34;file_path&#34;] = filePath doc.Metadata[&#34;file_size&#34;] = fmt.Sprintf(&#34;%d&#34;, fileInfo.Size()) doc.Metadata[&#34;processed_at&#34;] = time.Now().Format(time.RFC3339) // Process document return dp.ProcessDocument(ctx, doc) } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc *Document) error { // Chunk the document chunks, err := dp.chunker.ChunkDocument(doc) if err != nil { return fmt.Errorf(&#34;failed to chunk document: %w&#34;, err) } log.Printf(&#34;Processing document &#39;%s&#39; with %d chunks&#34;, doc.Title, len(chunks)) // Store chunks in batches for i := 0; i &lt; len(chunks); i &#43;= dp.config.BatchSize { end := i &#43; dp.config.BatchSize if end &gt; len(chunks) { end = len(chunks) } batch := chunks[i:end] err := dp.storeBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to store batch: %w&#34;, err) } } log.Printf(&#34;Successfully processed document &#39;%s&#39;&#34;, doc.Title) return nil } func (dp *DocumentProcessor) storeBatch(ctx context.Context, chunks []*DocumentChunk) error { for _, chunk := range chunks { err := dp.memory.Store(ctx, chunk.Content, &#34;document-chunk&#34;, core.WithMetadata(chunk.Metadata), core.WithTimestamp(chunk.CreatedAt), ) if err != nil { return fmt.Errorf(&#34;failed to store chunk %s: %w&#34;, chunk.ID, err) } } return nil } // Simple text parser type TextParser struct{} func (tp *TextParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } return &amp;Document{ ID: generateDocumentID(filePath), Title: filepath.Base(filePath), Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;text&#34;, &#34;parser&#34;: &#34;text&#34;, }, }, nil } func (tp *TextParser) SupportedExtensions() []string { return []string{&#34;.txt&#34;} } // Markdown parser type MarkdownParser struct{} func (mp *MarkdownParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } // Extract title from first heading lines := strings.Split(string(content), &#34;\n&#34;) title := filepath.Base(filePath) for _, line := range lines { if strings.HasPrefix(line, &#34;# &#34;) { title = strings.TrimPrefix(line, &#34;# &#34;) break } } return &amp;Document{ ID: generateDocumentID(filePath), Title: title, Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;markdown&#34;, &#34;parser&#34;: &#34;markdown&#34;, }, }, nil } func (mp *MarkdownParser) SupportedExtensions() []string { return []string{&#34;.md&#34;, &#34;.markdown&#34;} } func generateDocumentID(filePath string) string { // Generate unique ID based on file path hash := sha256.Sum256([]byte(filePath &#43; time.Now().String())) return fmt.Sprintf(&#34;%x&#34;, hash)[:16] }Document Chunking Strategies 1. Document Chunker type DocumentChunker struct { config ChunkingConfig } type ChunkingConfig struct { ChunkSize int ChunkOverlap int Strategy string // &#34;fixed&#34;, &#34;semantic&#34;, &#34;sentence&#34;, &#34;paragraph&#34; MinChunkSize int MaxChunkSize int } type DocumentChunk struct { ID string DocumentID string Content string ChunkIndex int StartOffset int EndOffset int Metadata map[string]string CreatedAt time.Time } func NewDocumentChunker(config ChunkingConfig) *DocumentChunker { return &amp;DocumentChunker{config: config} } func (dc *DocumentChunker) ChunkDocument(doc *Document) ([]*DocumentChunk, error) { switch dc.config.Strategy { case &#34;fixed&#34;: return dc.fixedSizeChunking(doc) case &#34;semantic&#34;: return dc.semanticChunking(doc) case &#34;sentence&#34;: return dc.sentenceChunking(doc) case &#34;paragraph&#34;: return dc.paragraphChunking(doc) default: return dc.fixedSizeChunking(doc) } } func (dc *DocumentChunker) fixedSizeChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content chunks := make([]*DocumentChunk, 0) for i := 0; i &lt; len(content); i &#43;= dc.config.ChunkSize - dc.config.ChunkOverlap { end := i &#43; dc.config.ChunkSize if end &gt; len(content) { end = len(content) } chunkContent := content[i:end] // Skip chunks that are too small if len(chunkContent) &lt; dc.config.MinChunkSize { continue } chunk := &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, len(chunks)), DocumentID: doc.ID, Content: chunkContent, ChunkIndex: len(chunks), StartOffset: i, EndOffset: end, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: &#34;fixed&#34;, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, len(chunks)), }, } chunks = append(chunks, chunk) if end &gt;= len(content) { break } } return chunks, nil } func (dc *DocumentChunker) semanticChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content // Split by double newlines (paragraphs) paragraphs := strings.Split(content, &#34;\n\n&#34;) chunks := make([]*DocumentChunk, 0) currentChunk := &#34;&#34; startOffset := 0 for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed chunk size if len(currentChunk)&#43;len(paragraph)&#43;2 &gt; dc.config.ChunkSize &amp;&amp; currentChunk != &#34;&#34; { // Create chunk from current content chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) // Start new chunk with overlap overlapSize := min(dc.config.ChunkOverlap, len(currentChunk)) currentChunk = currentChunk[len(currentChunk)-overlapSize:] &#43; &#34;\n\n&#34; &#43; paragraph startOffset = startOffset &#43; len(currentChunk) - overlapSize } else { // Add paragraph to current chunk if currentChunk != &#34;&#34; { currentChunk &#43;= &#34;\n\n&#34; } currentChunk &#43;= paragraph } } // Add final chunk if there&#39;s content if currentChunk != &#34;&#34; &amp;&amp; len(currentChunk) &gt;= dc.config.MinChunkSize { chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) } return chunks, nil } func (dc *DocumentChunker) createChunk(doc *Document, content string, index, startOffset, endOffset int) *DocumentChunk { return &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, index), DocumentID: doc.ID, Content: content, ChunkIndex: index, StartOffset: startOffset, EndOffset: endOffset, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: dc.config.Strategy, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, index), }, } } func min(a, b int) int { if a &lt; b { return a } return b }Knowledge Base Management 1. Knowledge Base Manager type KnowledgeBaseManager struct { memory core.Memory processor *DocumentProcessor config ManagerConfig } type ManagerConfig struct { AutoIndexing bool IndexingInterval time.Duration BackupEnabled bool BackupInterval time.Duration } func NewKnowledgeBaseManager(memory core.Memory) *KnowledgeBaseManager { processor := NewDocumentProcessor(memory) return &amp;KnowledgeBaseManager{ memory: memory, processor: processor, config: ManagerConfig{ AutoIndexing: true, IndexingInterval: 1 * time.Hour, BackupEnabled: true, BackupInterval: 24 * time.Hour, }, } } func (kbm *KnowledgeBaseManager) AddDocument(ctx context.Context, filePath string) error { return kbm.processor.ProcessFile(ctx, filePath) } func (kbm *KnowledgeBaseManager) AddDocumentFromContent(ctx context.Context, title, content string, metadata map[string]string) error { doc := &amp;Document{ ID: generateDocumentID(title &#43; content), Title: title, Content: content, Source: &#34;direct-input&#34;, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: metadata, } return kbm.processor.ProcessDocument(ctx, doc) } func (kbm *KnowledgeBaseManager) Search(ctx context.Context, query string, options ...core.SearchOption) ([]core.MemoryResult, error) { return kbm.memory.Search(ctx, query, options...) } func (kbm *KnowledgeBaseManager) GetStats(ctx context.Context) (*KnowledgeBaseStats, error) { memoryStats, err := kbm.memory.GetStats(ctx) if err != nil { return nil, err } return &amp;KnowledgeBaseStats{ TotalDocuments: memoryStats.ItemCount, TotalChunks: memoryStats.ItemCount, IndexSize: memoryStats.SizeBytes, LastUpdated: time.Now(), }, nil } type KnowledgeBaseStats struct { TotalDocuments int64 `json:&#34;total_documents&#34;` TotalChunks int64 `json:&#34;total_chunks&#34;` IndexSize int64 `json:&#34;index_size_bytes&#34;` LastUpdated time.Time `json:&#34;last_updated&#34;` }Usage Example Complete Knowledge Base Example func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Create knowledge base manager kbManager := NewKnowledgeBaseManager(memory) ctx := context.Background() // Add documents to knowledge base documents := []string{ &#34;./docs/tutorial1.md&#34;, &#34;./docs/tutorial2.md&#34;, &#34;./docs/api-reference.md&#34;, } for _, docPath := range documents { err := kbManager.AddDocument(ctx, docPath) if err != nil { log.Printf(&#34;Failed to add document %s: %v&#34;, docPath, err) } else { log.Printf(&#34;Successfully added document: %s&#34;, docPath) } } // Add content directly err = kbManager.AddDocumentFromContent(ctx, &#34;AgenticGoKit Overview&#34;, &#34;AgenticGoKit is a Go framework for building multi-agent systems...&#34;, map[string]string{ &#34;category&#34;: &#34;overview&#34;, &#34;author&#34;: &#34;AgenticGoKit Team&#34;, }, ) if err != nil { log.Printf(&#34;Failed to add content: %v&#34;, err) } // Search the knowledge base results, err := kbManager.Search(ctx, &#34;How to build multi-agent systems?&#34;, core.WithLimit(5), core.WithScoreThreshold(0.7), ) if err != nil { log.Printf(&#34;Search failed: %v&#34;, err) } else { fmt.Printf(&#34;Found %d results:\n&#34;, len(results)) for i, result := range results { fmt.Printf(&#34;%d. %s (Score: %.3f)\n&#34;, i&#43;1, result.Content[:100]&#43;&#34;...&#34;, result.Score) } } // Get knowledge base statistics stats, err := kbManager.GetStats(ctx) if err != nil { log.Printf(&#34;Failed to get stats: %v&#34;, err) } else { fmt.Printf(&#34;Knowledge Base Stats:\n&#34;) fmt.Printf(&#34; Documents: %d\n&#34;, stats.TotalDocuments) fmt.Printf(&#34; Chunks: %d\n&#34;, stats.TotalChunks) fmt.Printf(&#34; Index Size: %d MB\n&#34;, stats.IndexSize/1024/1024) } }Best Practices 1. Document Processing Format Support: Implement parsers for all relevant document formats Error Handling: Gracefully handle parsing errors and corrupted files Batch Processing: Process multiple documents efficiently Progress Tracking: Provide feedback on processing progress Validation: Validate documents before processing 2. Chunking Strategy Content-Aware: Use semantic chunking for better context preservation Overlap Management: Balance overlap size with storage efficiency Size Optimization: Optimize chunk size for your embedding model Metadata Preservation: Maintain document context in chunks Quality Control: Validate chunk quality and coherence 3. Search Optimization Index Tuning: Optimize vector database indexes Query Enhancement: Improve query understanding Result Ranking: Implement effective ranking algorithms Caching: Cache frequent searches Performance Monitoring: Track search performance metrics Conclusion Knowledge bases in AgenticGoKit provide the foundation for intelligent information retrieval and RAG systems. Key takeaways:">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="knowledge-bases :: AgenticGoKit Docs">
    <meta name="twitter:description" content="Knowledge Bases in AgenticGoKit Overview Knowledge bases are structured repositories of information that enable agents to access, search, and reason over large collections of documents and data. This tutorial covers building comprehensive knowledge bases with AgenticGoKit, including document ingestion, chunking strategies, metadata management, and search optimization.
Knowledge bases transform raw information into accessible, searchable knowledge that agents can use to provide accurate and contextual responses.
Prerequisites Understanding of RAG Implementation Familiarity with Vector Databases Knowledge of document processing and text extraction Basic understanding of information retrieval concepts Knowledge Base Architecture Components Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Documents │───▶│ Ingestion │───▶│ Processing ││ (PDF, MD, │ │ Pipeline │ │ Pipeline ││ HTML, etc.) │ └──────────────────┘ └─────────────────┘└─────────────────┘ │▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Search &amp; │◀───│ Vector Store │◀───│ Chunking &amp; ││ Retrieval │ │ (pgvector/ │ │ Embedding │└─────────────────┘ │ Weaviate) │ └─────────────────┘└──────────────────┘Knowledge Base Layers Storage Layer: Vector database with metadata Processing Layer: Document parsing and chunking Embedding Layer: Vector representation generation Retrieval Layer: Search and ranking algorithms Management Layer: Updates, versioning, and maintenance Document Ingestion Pipeline 1. Basic Document Processor package main import ( &#34;context&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;path/filepath&#34; &#34;strings&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type DocumentProcessor struct { memory core.Memory parsers map[string]DocumentParser chunker *DocumentChunker config ProcessingConfig } type ProcessingConfig struct { ChunkSize int ChunkOverlap int MaxFileSize int64 SupportedFormats []string BatchSize int } type DocumentParser interface { Parse(filePath string) (*Document, error) SupportedExtensions() []string } type Document struct { ID string Title string Content string Metadata map[string]string Source string CreatedAt time.Time UpdatedAt time.Time } func NewDocumentProcessor(memory core.Memory) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, parsers: make(map[string]DocumentParser), chunker: NewDocumentChunker(ChunkingConfig{ ChunkSize: 1000, ChunkOverlap: 200, Strategy: &#34;semantic&#34;, }), config: ProcessingConfig{ ChunkSize: 1000, ChunkOverlap: 200, MaxFileSize: 10 * 1024 * 1024, // 10MB SupportedFormats: []string{&#34;.txt&#34;, &#34;.md&#34;, &#34;.pdf&#34;, &#34;.html&#34;}, BatchSize: 10, }, } // Register parsers dp.registerParsers() return dp } func (dp *DocumentProcessor) registerParsers() { dp.parsers[&#34;.txt&#34;] = &amp;TextParser{} dp.parsers[&#34;.md&#34;] = &amp;MarkdownParser{} dp.parsers[&#34;.pdf&#34;] = &amp;PDFParser{} dp.parsers[&#34;.html&#34;] = &amp;HTMLParser{} } func (dp *DocumentProcessor) ProcessFile(ctx context.Context, filePath string) error { // Check file size fileInfo, err := os.Stat(filePath) if err != nil { return fmt.Errorf(&#34;failed to stat file: %w&#34;, err) } if fileInfo.Size() &gt; dp.config.MaxFileSize { return fmt.Errorf(&#34;file too large: %d bytes&#34;, fileInfo.Size()) } // Get parser for file extension ext := strings.ToLower(filepath.Ext(filePath)) parser, exists := dp.parsers[ext] if !exists { return fmt.Errorf(&#34;unsupported file format: %s&#34;, ext) } // Parse document doc, err := parser.Parse(filePath) if err != nil { return fmt.Errorf(&#34;failed to parse document: %w&#34;, err) } // Add file metadata doc.Metadata[&#34;file_path&#34;] = filePath doc.Metadata[&#34;file_size&#34;] = fmt.Sprintf(&#34;%d&#34;, fileInfo.Size()) doc.Metadata[&#34;processed_at&#34;] = time.Now().Format(time.RFC3339) // Process document return dp.ProcessDocument(ctx, doc) } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc *Document) error { // Chunk the document chunks, err := dp.chunker.ChunkDocument(doc) if err != nil { return fmt.Errorf(&#34;failed to chunk document: %w&#34;, err) } log.Printf(&#34;Processing document &#39;%s&#39; with %d chunks&#34;, doc.Title, len(chunks)) // Store chunks in batches for i := 0; i &lt; len(chunks); i &#43;= dp.config.BatchSize { end := i &#43; dp.config.BatchSize if end &gt; len(chunks) { end = len(chunks) } batch := chunks[i:end] err := dp.storeBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to store batch: %w&#34;, err) } } log.Printf(&#34;Successfully processed document &#39;%s&#39;&#34;, doc.Title) return nil } func (dp *DocumentProcessor) storeBatch(ctx context.Context, chunks []*DocumentChunk) error { for _, chunk := range chunks { err := dp.memory.Store(ctx, chunk.Content, &#34;document-chunk&#34;, core.WithMetadata(chunk.Metadata), core.WithTimestamp(chunk.CreatedAt), ) if err != nil { return fmt.Errorf(&#34;failed to store chunk %s: %w&#34;, chunk.ID, err) } } return nil } // Simple text parser type TextParser struct{} func (tp *TextParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } return &amp;Document{ ID: generateDocumentID(filePath), Title: filepath.Base(filePath), Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;text&#34;, &#34;parser&#34;: &#34;text&#34;, }, }, nil } func (tp *TextParser) SupportedExtensions() []string { return []string{&#34;.txt&#34;} } // Markdown parser type MarkdownParser struct{} func (mp *MarkdownParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } // Extract title from first heading lines := strings.Split(string(content), &#34;\n&#34;) title := filepath.Base(filePath) for _, line := range lines { if strings.HasPrefix(line, &#34;# &#34;) { title = strings.TrimPrefix(line, &#34;# &#34;) break } } return &amp;Document{ ID: generateDocumentID(filePath), Title: title, Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;markdown&#34;, &#34;parser&#34;: &#34;markdown&#34;, }, }, nil } func (mp *MarkdownParser) SupportedExtensions() []string { return []string{&#34;.md&#34;, &#34;.markdown&#34;} } func generateDocumentID(filePath string) string { // Generate unique ID based on file path hash := sha256.Sum256([]byte(filePath &#43; time.Now().String())) return fmt.Sprintf(&#34;%x&#34;, hash)[:16] }Document Chunking Strategies 1. Document Chunker type DocumentChunker struct { config ChunkingConfig } type ChunkingConfig struct { ChunkSize int ChunkOverlap int Strategy string // &#34;fixed&#34;, &#34;semantic&#34;, &#34;sentence&#34;, &#34;paragraph&#34; MinChunkSize int MaxChunkSize int } type DocumentChunk struct { ID string DocumentID string Content string ChunkIndex int StartOffset int EndOffset int Metadata map[string]string CreatedAt time.Time } func NewDocumentChunker(config ChunkingConfig) *DocumentChunker { return &amp;DocumentChunker{config: config} } func (dc *DocumentChunker) ChunkDocument(doc *Document) ([]*DocumentChunk, error) { switch dc.config.Strategy { case &#34;fixed&#34;: return dc.fixedSizeChunking(doc) case &#34;semantic&#34;: return dc.semanticChunking(doc) case &#34;sentence&#34;: return dc.sentenceChunking(doc) case &#34;paragraph&#34;: return dc.paragraphChunking(doc) default: return dc.fixedSizeChunking(doc) } } func (dc *DocumentChunker) fixedSizeChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content chunks := make([]*DocumentChunk, 0) for i := 0; i &lt; len(content); i &#43;= dc.config.ChunkSize - dc.config.ChunkOverlap { end := i &#43; dc.config.ChunkSize if end &gt; len(content) { end = len(content) } chunkContent := content[i:end] // Skip chunks that are too small if len(chunkContent) &lt; dc.config.MinChunkSize { continue } chunk := &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, len(chunks)), DocumentID: doc.ID, Content: chunkContent, ChunkIndex: len(chunks), StartOffset: i, EndOffset: end, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: &#34;fixed&#34;, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, len(chunks)), }, } chunks = append(chunks, chunk) if end &gt;= len(content) { break } } return chunks, nil } func (dc *DocumentChunker) semanticChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content // Split by double newlines (paragraphs) paragraphs := strings.Split(content, &#34;\n\n&#34;) chunks := make([]*DocumentChunk, 0) currentChunk := &#34;&#34; startOffset := 0 for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed chunk size if len(currentChunk)&#43;len(paragraph)&#43;2 &gt; dc.config.ChunkSize &amp;&amp; currentChunk != &#34;&#34; { // Create chunk from current content chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) // Start new chunk with overlap overlapSize := min(dc.config.ChunkOverlap, len(currentChunk)) currentChunk = currentChunk[len(currentChunk)-overlapSize:] &#43; &#34;\n\n&#34; &#43; paragraph startOffset = startOffset &#43; len(currentChunk) - overlapSize } else { // Add paragraph to current chunk if currentChunk != &#34;&#34; { currentChunk &#43;= &#34;\n\n&#34; } currentChunk &#43;= paragraph } } // Add final chunk if there&#39;s content if currentChunk != &#34;&#34; &amp;&amp; len(currentChunk) &gt;= dc.config.MinChunkSize { chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) } return chunks, nil } func (dc *DocumentChunker) createChunk(doc *Document, content string, index, startOffset, endOffset int) *DocumentChunk { return &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, index), DocumentID: doc.ID, Content: content, ChunkIndex: index, StartOffset: startOffset, EndOffset: endOffset, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: dc.config.Strategy, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, index), }, } } func min(a, b int) int { if a &lt; b { return a } return b }Knowledge Base Management 1. Knowledge Base Manager type KnowledgeBaseManager struct { memory core.Memory processor *DocumentProcessor config ManagerConfig } type ManagerConfig struct { AutoIndexing bool IndexingInterval time.Duration BackupEnabled bool BackupInterval time.Duration } func NewKnowledgeBaseManager(memory core.Memory) *KnowledgeBaseManager { processor := NewDocumentProcessor(memory) return &amp;KnowledgeBaseManager{ memory: memory, processor: processor, config: ManagerConfig{ AutoIndexing: true, IndexingInterval: 1 * time.Hour, BackupEnabled: true, BackupInterval: 24 * time.Hour, }, } } func (kbm *KnowledgeBaseManager) AddDocument(ctx context.Context, filePath string) error { return kbm.processor.ProcessFile(ctx, filePath) } func (kbm *KnowledgeBaseManager) AddDocumentFromContent(ctx context.Context, title, content string, metadata map[string]string) error { doc := &amp;Document{ ID: generateDocumentID(title &#43; content), Title: title, Content: content, Source: &#34;direct-input&#34;, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: metadata, } return kbm.processor.ProcessDocument(ctx, doc) } func (kbm *KnowledgeBaseManager) Search(ctx context.Context, query string, options ...core.SearchOption) ([]core.MemoryResult, error) { return kbm.memory.Search(ctx, query, options...) } func (kbm *KnowledgeBaseManager) GetStats(ctx context.Context) (*KnowledgeBaseStats, error) { memoryStats, err := kbm.memory.GetStats(ctx) if err != nil { return nil, err } return &amp;KnowledgeBaseStats{ TotalDocuments: memoryStats.ItemCount, TotalChunks: memoryStats.ItemCount, IndexSize: memoryStats.SizeBytes, LastUpdated: time.Now(), }, nil } type KnowledgeBaseStats struct { TotalDocuments int64 `json:&#34;total_documents&#34;` TotalChunks int64 `json:&#34;total_chunks&#34;` IndexSize int64 `json:&#34;index_size_bytes&#34;` LastUpdated time.Time `json:&#34;last_updated&#34;` }Usage Example Complete Knowledge Base Example func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Create knowledge base manager kbManager := NewKnowledgeBaseManager(memory) ctx := context.Background() // Add documents to knowledge base documents := []string{ &#34;./docs/tutorial1.md&#34;, &#34;./docs/tutorial2.md&#34;, &#34;./docs/api-reference.md&#34;, } for _, docPath := range documents { err := kbManager.AddDocument(ctx, docPath) if err != nil { log.Printf(&#34;Failed to add document %s: %v&#34;, docPath, err) } else { log.Printf(&#34;Successfully added document: %s&#34;, docPath) } } // Add content directly err = kbManager.AddDocumentFromContent(ctx, &#34;AgenticGoKit Overview&#34;, &#34;AgenticGoKit is a Go framework for building multi-agent systems...&#34;, map[string]string{ &#34;category&#34;: &#34;overview&#34;, &#34;author&#34;: &#34;AgenticGoKit Team&#34;, }, ) if err != nil { log.Printf(&#34;Failed to add content: %v&#34;, err) } // Search the knowledge base results, err := kbManager.Search(ctx, &#34;How to build multi-agent systems?&#34;, core.WithLimit(5), core.WithScoreThreshold(0.7), ) if err != nil { log.Printf(&#34;Search failed: %v&#34;, err) } else { fmt.Printf(&#34;Found %d results:\n&#34;, len(results)) for i, result := range results { fmt.Printf(&#34;%d. %s (Score: %.3f)\n&#34;, i&#43;1, result.Content[:100]&#43;&#34;...&#34;, result.Score) } } // Get knowledge base statistics stats, err := kbManager.GetStats(ctx) if err != nil { log.Printf(&#34;Failed to get stats: %v&#34;, err) } else { fmt.Printf(&#34;Knowledge Base Stats:\n&#34;) fmt.Printf(&#34; Documents: %d\n&#34;, stats.TotalDocuments) fmt.Printf(&#34; Chunks: %d\n&#34;, stats.TotalChunks) fmt.Printf(&#34; Index Size: %d MB\n&#34;, stats.IndexSize/1024/1024) } }Best Practices 1. Document Processing Format Support: Implement parsers for all relevant document formats Error Handling: Gracefully handle parsing errors and corrupted files Batch Processing: Process multiple documents efficiently Progress Tracking: Provide feedback on processing progress Validation: Validate documents before processing 2. Chunking Strategy Content-Aware: Use semantic chunking for better context preservation Overlap Management: Balance overlap size with storage efficiency Size Optimization: Optimize chunk size for your embedding model Metadata Preservation: Maintain document context in chunks Quality Control: Validate chunk quality and coherence 3. Search Optimization Index Tuning: Optimize vector database indexes Query Enhancement: Improve query understanding Result Ranking: Implement effective ranking algorithms Caching: Cache frequent searches Performance Monitoring: Track search performance metrics Conclusion Knowledge bases in AgenticGoKit provide the foundation for intelligent information retrieval and RAG systems. Key takeaways:">
    <meta property="og:url" content="http://localhost:1313/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">
    <meta property="og:site_name" content="AgenticGoKit Docs">
    <meta property="og:title" content="knowledge-bases :: AgenticGoKit Docs">
    <meta property="og:description" content="Knowledge Bases in AgenticGoKit Overview Knowledge bases are structured repositories of information that enable agents to access, search, and reason over large collections of documents and data. This tutorial covers building comprehensive knowledge bases with AgenticGoKit, including document ingestion, chunking strategies, metadata management, and search optimization.
Knowledge bases transform raw information into accessible, searchable knowledge that agents can use to provide accurate and contextual responses.
Prerequisites Understanding of RAG Implementation Familiarity with Vector Databases Knowledge of document processing and text extraction Basic understanding of information retrieval concepts Knowledge Base Architecture Components Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Documents │───▶│ Ingestion │───▶│ Processing ││ (PDF, MD, │ │ Pipeline │ │ Pipeline ││ HTML, etc.) │ └──────────────────┘ └─────────────────┘└─────────────────┘ │▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Search &amp; │◀───│ Vector Store │◀───│ Chunking &amp; ││ Retrieval │ │ (pgvector/ │ │ Embedding │└─────────────────┘ │ Weaviate) │ └─────────────────┘└──────────────────┘Knowledge Base Layers Storage Layer: Vector database with metadata Processing Layer: Document parsing and chunking Embedding Layer: Vector representation generation Retrieval Layer: Search and ranking algorithms Management Layer: Updates, versioning, and maintenance Document Ingestion Pipeline 1. Basic Document Processor package main import ( &#34;context&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;path/filepath&#34; &#34;strings&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type DocumentProcessor struct { memory core.Memory parsers map[string]DocumentParser chunker *DocumentChunker config ProcessingConfig } type ProcessingConfig struct { ChunkSize int ChunkOverlap int MaxFileSize int64 SupportedFormats []string BatchSize int } type DocumentParser interface { Parse(filePath string) (*Document, error) SupportedExtensions() []string } type Document struct { ID string Title string Content string Metadata map[string]string Source string CreatedAt time.Time UpdatedAt time.Time } func NewDocumentProcessor(memory core.Memory) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, parsers: make(map[string]DocumentParser), chunker: NewDocumentChunker(ChunkingConfig{ ChunkSize: 1000, ChunkOverlap: 200, Strategy: &#34;semantic&#34;, }), config: ProcessingConfig{ ChunkSize: 1000, ChunkOverlap: 200, MaxFileSize: 10 * 1024 * 1024, // 10MB SupportedFormats: []string{&#34;.txt&#34;, &#34;.md&#34;, &#34;.pdf&#34;, &#34;.html&#34;}, BatchSize: 10, }, } // Register parsers dp.registerParsers() return dp } func (dp *DocumentProcessor) registerParsers() { dp.parsers[&#34;.txt&#34;] = &amp;TextParser{} dp.parsers[&#34;.md&#34;] = &amp;MarkdownParser{} dp.parsers[&#34;.pdf&#34;] = &amp;PDFParser{} dp.parsers[&#34;.html&#34;] = &amp;HTMLParser{} } func (dp *DocumentProcessor) ProcessFile(ctx context.Context, filePath string) error { // Check file size fileInfo, err := os.Stat(filePath) if err != nil { return fmt.Errorf(&#34;failed to stat file: %w&#34;, err) } if fileInfo.Size() &gt; dp.config.MaxFileSize { return fmt.Errorf(&#34;file too large: %d bytes&#34;, fileInfo.Size()) } // Get parser for file extension ext := strings.ToLower(filepath.Ext(filePath)) parser, exists := dp.parsers[ext] if !exists { return fmt.Errorf(&#34;unsupported file format: %s&#34;, ext) } // Parse document doc, err := parser.Parse(filePath) if err != nil { return fmt.Errorf(&#34;failed to parse document: %w&#34;, err) } // Add file metadata doc.Metadata[&#34;file_path&#34;] = filePath doc.Metadata[&#34;file_size&#34;] = fmt.Sprintf(&#34;%d&#34;, fileInfo.Size()) doc.Metadata[&#34;processed_at&#34;] = time.Now().Format(time.RFC3339) // Process document return dp.ProcessDocument(ctx, doc) } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc *Document) error { // Chunk the document chunks, err := dp.chunker.ChunkDocument(doc) if err != nil { return fmt.Errorf(&#34;failed to chunk document: %w&#34;, err) } log.Printf(&#34;Processing document &#39;%s&#39; with %d chunks&#34;, doc.Title, len(chunks)) // Store chunks in batches for i := 0; i &lt; len(chunks); i &#43;= dp.config.BatchSize { end := i &#43; dp.config.BatchSize if end &gt; len(chunks) { end = len(chunks) } batch := chunks[i:end] err := dp.storeBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to store batch: %w&#34;, err) } } log.Printf(&#34;Successfully processed document &#39;%s&#39;&#34;, doc.Title) return nil } func (dp *DocumentProcessor) storeBatch(ctx context.Context, chunks []*DocumentChunk) error { for _, chunk := range chunks { err := dp.memory.Store(ctx, chunk.Content, &#34;document-chunk&#34;, core.WithMetadata(chunk.Metadata), core.WithTimestamp(chunk.CreatedAt), ) if err != nil { return fmt.Errorf(&#34;failed to store chunk %s: %w&#34;, chunk.ID, err) } } return nil } // Simple text parser type TextParser struct{} func (tp *TextParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } return &amp;Document{ ID: generateDocumentID(filePath), Title: filepath.Base(filePath), Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;text&#34;, &#34;parser&#34;: &#34;text&#34;, }, }, nil } func (tp *TextParser) SupportedExtensions() []string { return []string{&#34;.txt&#34;} } // Markdown parser type MarkdownParser struct{} func (mp *MarkdownParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } // Extract title from first heading lines := strings.Split(string(content), &#34;\n&#34;) title := filepath.Base(filePath) for _, line := range lines { if strings.HasPrefix(line, &#34;# &#34;) { title = strings.TrimPrefix(line, &#34;# &#34;) break } } return &amp;Document{ ID: generateDocumentID(filePath), Title: title, Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;markdown&#34;, &#34;parser&#34;: &#34;markdown&#34;, }, }, nil } func (mp *MarkdownParser) SupportedExtensions() []string { return []string{&#34;.md&#34;, &#34;.markdown&#34;} } func generateDocumentID(filePath string) string { // Generate unique ID based on file path hash := sha256.Sum256([]byte(filePath &#43; time.Now().String())) return fmt.Sprintf(&#34;%x&#34;, hash)[:16] }Document Chunking Strategies 1. Document Chunker type DocumentChunker struct { config ChunkingConfig } type ChunkingConfig struct { ChunkSize int ChunkOverlap int Strategy string // &#34;fixed&#34;, &#34;semantic&#34;, &#34;sentence&#34;, &#34;paragraph&#34; MinChunkSize int MaxChunkSize int } type DocumentChunk struct { ID string DocumentID string Content string ChunkIndex int StartOffset int EndOffset int Metadata map[string]string CreatedAt time.Time } func NewDocumentChunker(config ChunkingConfig) *DocumentChunker { return &amp;DocumentChunker{config: config} } func (dc *DocumentChunker) ChunkDocument(doc *Document) ([]*DocumentChunk, error) { switch dc.config.Strategy { case &#34;fixed&#34;: return dc.fixedSizeChunking(doc) case &#34;semantic&#34;: return dc.semanticChunking(doc) case &#34;sentence&#34;: return dc.sentenceChunking(doc) case &#34;paragraph&#34;: return dc.paragraphChunking(doc) default: return dc.fixedSizeChunking(doc) } } func (dc *DocumentChunker) fixedSizeChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content chunks := make([]*DocumentChunk, 0) for i := 0; i &lt; len(content); i &#43;= dc.config.ChunkSize - dc.config.ChunkOverlap { end := i &#43; dc.config.ChunkSize if end &gt; len(content) { end = len(content) } chunkContent := content[i:end] // Skip chunks that are too small if len(chunkContent) &lt; dc.config.MinChunkSize { continue } chunk := &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, len(chunks)), DocumentID: doc.ID, Content: chunkContent, ChunkIndex: len(chunks), StartOffset: i, EndOffset: end, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: &#34;fixed&#34;, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, len(chunks)), }, } chunks = append(chunks, chunk) if end &gt;= len(content) { break } } return chunks, nil } func (dc *DocumentChunker) semanticChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content // Split by double newlines (paragraphs) paragraphs := strings.Split(content, &#34;\n\n&#34;) chunks := make([]*DocumentChunk, 0) currentChunk := &#34;&#34; startOffset := 0 for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed chunk size if len(currentChunk)&#43;len(paragraph)&#43;2 &gt; dc.config.ChunkSize &amp;&amp; currentChunk != &#34;&#34; { // Create chunk from current content chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) // Start new chunk with overlap overlapSize := min(dc.config.ChunkOverlap, len(currentChunk)) currentChunk = currentChunk[len(currentChunk)-overlapSize:] &#43; &#34;\n\n&#34; &#43; paragraph startOffset = startOffset &#43; len(currentChunk) - overlapSize } else { // Add paragraph to current chunk if currentChunk != &#34;&#34; { currentChunk &#43;= &#34;\n\n&#34; } currentChunk &#43;= paragraph } } // Add final chunk if there&#39;s content if currentChunk != &#34;&#34; &amp;&amp; len(currentChunk) &gt;= dc.config.MinChunkSize { chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) } return chunks, nil } func (dc *DocumentChunker) createChunk(doc *Document, content string, index, startOffset, endOffset int) *DocumentChunk { return &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, index), DocumentID: doc.ID, Content: content, ChunkIndex: index, StartOffset: startOffset, EndOffset: endOffset, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: dc.config.Strategy, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, index), }, } } func min(a, b int) int { if a &lt; b { return a } return b }Knowledge Base Management 1. Knowledge Base Manager type KnowledgeBaseManager struct { memory core.Memory processor *DocumentProcessor config ManagerConfig } type ManagerConfig struct { AutoIndexing bool IndexingInterval time.Duration BackupEnabled bool BackupInterval time.Duration } func NewKnowledgeBaseManager(memory core.Memory) *KnowledgeBaseManager { processor := NewDocumentProcessor(memory) return &amp;KnowledgeBaseManager{ memory: memory, processor: processor, config: ManagerConfig{ AutoIndexing: true, IndexingInterval: 1 * time.Hour, BackupEnabled: true, BackupInterval: 24 * time.Hour, }, } } func (kbm *KnowledgeBaseManager) AddDocument(ctx context.Context, filePath string) error { return kbm.processor.ProcessFile(ctx, filePath) } func (kbm *KnowledgeBaseManager) AddDocumentFromContent(ctx context.Context, title, content string, metadata map[string]string) error { doc := &amp;Document{ ID: generateDocumentID(title &#43; content), Title: title, Content: content, Source: &#34;direct-input&#34;, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: metadata, } return kbm.processor.ProcessDocument(ctx, doc) } func (kbm *KnowledgeBaseManager) Search(ctx context.Context, query string, options ...core.SearchOption) ([]core.MemoryResult, error) { return kbm.memory.Search(ctx, query, options...) } func (kbm *KnowledgeBaseManager) GetStats(ctx context.Context) (*KnowledgeBaseStats, error) { memoryStats, err := kbm.memory.GetStats(ctx) if err != nil { return nil, err } return &amp;KnowledgeBaseStats{ TotalDocuments: memoryStats.ItemCount, TotalChunks: memoryStats.ItemCount, IndexSize: memoryStats.SizeBytes, LastUpdated: time.Now(), }, nil } type KnowledgeBaseStats struct { TotalDocuments int64 `json:&#34;total_documents&#34;` TotalChunks int64 `json:&#34;total_chunks&#34;` IndexSize int64 `json:&#34;index_size_bytes&#34;` LastUpdated time.Time `json:&#34;last_updated&#34;` }Usage Example Complete Knowledge Base Example func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Create knowledge base manager kbManager := NewKnowledgeBaseManager(memory) ctx := context.Background() // Add documents to knowledge base documents := []string{ &#34;./docs/tutorial1.md&#34;, &#34;./docs/tutorial2.md&#34;, &#34;./docs/api-reference.md&#34;, } for _, docPath := range documents { err := kbManager.AddDocument(ctx, docPath) if err != nil { log.Printf(&#34;Failed to add document %s: %v&#34;, docPath, err) } else { log.Printf(&#34;Successfully added document: %s&#34;, docPath) } } // Add content directly err = kbManager.AddDocumentFromContent(ctx, &#34;AgenticGoKit Overview&#34;, &#34;AgenticGoKit is a Go framework for building multi-agent systems...&#34;, map[string]string{ &#34;category&#34;: &#34;overview&#34;, &#34;author&#34;: &#34;AgenticGoKit Team&#34;, }, ) if err != nil { log.Printf(&#34;Failed to add content: %v&#34;, err) } // Search the knowledge base results, err := kbManager.Search(ctx, &#34;How to build multi-agent systems?&#34;, core.WithLimit(5), core.WithScoreThreshold(0.7), ) if err != nil { log.Printf(&#34;Search failed: %v&#34;, err) } else { fmt.Printf(&#34;Found %d results:\n&#34;, len(results)) for i, result := range results { fmt.Printf(&#34;%d. %s (Score: %.3f)\n&#34;, i&#43;1, result.Content[:100]&#43;&#34;...&#34;, result.Score) } } // Get knowledge base statistics stats, err := kbManager.GetStats(ctx) if err != nil { log.Printf(&#34;Failed to get stats: %v&#34;, err) } else { fmt.Printf(&#34;Knowledge Base Stats:\n&#34;) fmt.Printf(&#34; Documents: %d\n&#34;, stats.TotalDocuments) fmt.Printf(&#34; Chunks: %d\n&#34;, stats.TotalChunks) fmt.Printf(&#34; Index Size: %d MB\n&#34;, stats.IndexSize/1024/1024) } }Best Practices 1. Document Processing Format Support: Implement parsers for all relevant document formats Error Handling: Gracefully handle parsing errors and corrupted files Batch Processing: Process multiple documents efficiently Progress Tracking: Provide feedback on processing progress Validation: Validate documents before processing 2. Chunking Strategy Content-Aware: Use semantic chunking for better context preservation Overlap Management: Balance overlap size with storage efficiency Size Optimization: Optimize chunk size for your embedding model Metadata Preservation: Maintain document context in chunks Quality Control: Validate chunk quality and coherence 3. Search Optimization Index Tuning: Optimize vector database indexes Query Enhancement: Improve query understanding Result Ranking: Implement effective ranking algorithms Caching: Cache frequent searches Performance Monitoring: Track search performance metrics Conclusion Knowledge bases in AgenticGoKit provide the foundation for intelligent information retrieval and RAG systems. Key takeaways:">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="tutorials">
    <meta property="article:published_time" content="2025-07-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="name" content="knowledge-bases :: AgenticGoKit Docs">
    <meta itemprop="description" content="Knowledge Bases in AgenticGoKit Overview Knowledge bases are structured repositories of information that enable agents to access, search, and reason over large collections of documents and data. This tutorial covers building comprehensive knowledge bases with AgenticGoKit, including document ingestion, chunking strategies, metadata management, and search optimization.
Knowledge bases transform raw information into accessible, searchable knowledge that agents can use to provide accurate and contextual responses.
Prerequisites Understanding of RAG Implementation Familiarity with Vector Databases Knowledge of document processing and text extraction Basic understanding of information retrieval concepts Knowledge Base Architecture Components Overview ┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Documents │───▶│ Ingestion │───▶│ Processing ││ (PDF, MD, │ │ Pipeline │ │ Pipeline ││ HTML, etc.) │ └──────────────────┘ └─────────────────┘└─────────────────┘ │▼┌─────────────────┐ ┌──────────────────┐ ┌─────────────────┐│ Search &amp; │◀───│ Vector Store │◀───│ Chunking &amp; ││ Retrieval │ │ (pgvector/ │ │ Embedding │└─────────────────┘ │ Weaviate) │ └─────────────────┘└──────────────────┘Knowledge Base Layers Storage Layer: Vector database with metadata Processing Layer: Document parsing and chunking Embedding Layer: Vector representation generation Retrieval Layer: Search and ranking algorithms Management Layer: Updates, versioning, and maintenance Document Ingestion Pipeline 1. Basic Document Processor package main import ( &#34;context&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;path/filepath&#34; &#34;strings&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) type DocumentProcessor struct { memory core.Memory parsers map[string]DocumentParser chunker *DocumentChunker config ProcessingConfig } type ProcessingConfig struct { ChunkSize int ChunkOverlap int MaxFileSize int64 SupportedFormats []string BatchSize int } type DocumentParser interface { Parse(filePath string) (*Document, error) SupportedExtensions() []string } type Document struct { ID string Title string Content string Metadata map[string]string Source string CreatedAt time.Time UpdatedAt time.Time } func NewDocumentProcessor(memory core.Memory) *DocumentProcessor { dp := &amp;DocumentProcessor{ memory: memory, parsers: make(map[string]DocumentParser), chunker: NewDocumentChunker(ChunkingConfig{ ChunkSize: 1000, ChunkOverlap: 200, Strategy: &#34;semantic&#34;, }), config: ProcessingConfig{ ChunkSize: 1000, ChunkOverlap: 200, MaxFileSize: 10 * 1024 * 1024, // 10MB SupportedFormats: []string{&#34;.txt&#34;, &#34;.md&#34;, &#34;.pdf&#34;, &#34;.html&#34;}, BatchSize: 10, }, } // Register parsers dp.registerParsers() return dp } func (dp *DocumentProcessor) registerParsers() { dp.parsers[&#34;.txt&#34;] = &amp;TextParser{} dp.parsers[&#34;.md&#34;] = &amp;MarkdownParser{} dp.parsers[&#34;.pdf&#34;] = &amp;PDFParser{} dp.parsers[&#34;.html&#34;] = &amp;HTMLParser{} } func (dp *DocumentProcessor) ProcessFile(ctx context.Context, filePath string) error { // Check file size fileInfo, err := os.Stat(filePath) if err != nil { return fmt.Errorf(&#34;failed to stat file: %w&#34;, err) } if fileInfo.Size() &gt; dp.config.MaxFileSize { return fmt.Errorf(&#34;file too large: %d bytes&#34;, fileInfo.Size()) } // Get parser for file extension ext := strings.ToLower(filepath.Ext(filePath)) parser, exists := dp.parsers[ext] if !exists { return fmt.Errorf(&#34;unsupported file format: %s&#34;, ext) } // Parse document doc, err := parser.Parse(filePath) if err != nil { return fmt.Errorf(&#34;failed to parse document: %w&#34;, err) } // Add file metadata doc.Metadata[&#34;file_path&#34;] = filePath doc.Metadata[&#34;file_size&#34;] = fmt.Sprintf(&#34;%d&#34;, fileInfo.Size()) doc.Metadata[&#34;processed_at&#34;] = time.Now().Format(time.RFC3339) // Process document return dp.ProcessDocument(ctx, doc) } func (dp *DocumentProcessor) ProcessDocument(ctx context.Context, doc *Document) error { // Chunk the document chunks, err := dp.chunker.ChunkDocument(doc) if err != nil { return fmt.Errorf(&#34;failed to chunk document: %w&#34;, err) } log.Printf(&#34;Processing document &#39;%s&#39; with %d chunks&#34;, doc.Title, len(chunks)) // Store chunks in batches for i := 0; i &lt; len(chunks); i &#43;= dp.config.BatchSize { end := i &#43; dp.config.BatchSize if end &gt; len(chunks) { end = len(chunks) } batch := chunks[i:end] err := dp.storeBatch(ctx, batch) if err != nil { return fmt.Errorf(&#34;failed to store batch: %w&#34;, err) } } log.Printf(&#34;Successfully processed document &#39;%s&#39;&#34;, doc.Title) return nil } func (dp *DocumentProcessor) storeBatch(ctx context.Context, chunks []*DocumentChunk) error { for _, chunk := range chunks { err := dp.memory.Store(ctx, chunk.Content, &#34;document-chunk&#34;, core.WithMetadata(chunk.Metadata), core.WithTimestamp(chunk.CreatedAt), ) if err != nil { return fmt.Errorf(&#34;failed to store chunk %s: %w&#34;, chunk.ID, err) } } return nil } // Simple text parser type TextParser struct{} func (tp *TextParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } return &amp;Document{ ID: generateDocumentID(filePath), Title: filepath.Base(filePath), Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;text&#34;, &#34;parser&#34;: &#34;text&#34;, }, }, nil } func (tp *TextParser) SupportedExtensions() []string { return []string{&#34;.txt&#34;} } // Markdown parser type MarkdownParser struct{} func (mp *MarkdownParser) Parse(filePath string) (*Document, error) { content, err := ioutil.ReadFile(filePath) if err != nil { return nil, err } // Extract title from first heading lines := strings.Split(string(content), &#34;\n&#34;) title := filepath.Base(filePath) for _, line := range lines { if strings.HasPrefix(line, &#34;# &#34;) { title = strings.TrimPrefix(line, &#34;# &#34;) break } } return &amp;Document{ ID: generateDocumentID(filePath), Title: title, Content: string(content), Source: filePath, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: map[string]string{ &#34;format&#34;: &#34;markdown&#34;, &#34;parser&#34;: &#34;markdown&#34;, }, }, nil } func (mp *MarkdownParser) SupportedExtensions() []string { return []string{&#34;.md&#34;, &#34;.markdown&#34;} } func generateDocumentID(filePath string) string { // Generate unique ID based on file path hash := sha256.Sum256([]byte(filePath &#43; time.Now().String())) return fmt.Sprintf(&#34;%x&#34;, hash)[:16] }Document Chunking Strategies 1. Document Chunker type DocumentChunker struct { config ChunkingConfig } type ChunkingConfig struct { ChunkSize int ChunkOverlap int Strategy string // &#34;fixed&#34;, &#34;semantic&#34;, &#34;sentence&#34;, &#34;paragraph&#34; MinChunkSize int MaxChunkSize int } type DocumentChunk struct { ID string DocumentID string Content string ChunkIndex int StartOffset int EndOffset int Metadata map[string]string CreatedAt time.Time } func NewDocumentChunker(config ChunkingConfig) *DocumentChunker { return &amp;DocumentChunker{config: config} } func (dc *DocumentChunker) ChunkDocument(doc *Document) ([]*DocumentChunk, error) { switch dc.config.Strategy { case &#34;fixed&#34;: return dc.fixedSizeChunking(doc) case &#34;semantic&#34;: return dc.semanticChunking(doc) case &#34;sentence&#34;: return dc.sentenceChunking(doc) case &#34;paragraph&#34;: return dc.paragraphChunking(doc) default: return dc.fixedSizeChunking(doc) } } func (dc *DocumentChunker) fixedSizeChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content chunks := make([]*DocumentChunk, 0) for i := 0; i &lt; len(content); i &#43;= dc.config.ChunkSize - dc.config.ChunkOverlap { end := i &#43; dc.config.ChunkSize if end &gt; len(content) { end = len(content) } chunkContent := content[i:end] // Skip chunks that are too small if len(chunkContent) &lt; dc.config.MinChunkSize { continue } chunk := &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, len(chunks)), DocumentID: doc.ID, Content: chunkContent, ChunkIndex: len(chunks), StartOffset: i, EndOffset: end, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: &#34;fixed&#34;, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, len(chunks)), }, } chunks = append(chunks, chunk) if end &gt;= len(content) { break } } return chunks, nil } func (dc *DocumentChunker) semanticChunking(doc *Document) ([]*DocumentChunk, error) { content := doc.Content // Split by double newlines (paragraphs) paragraphs := strings.Split(content, &#34;\n\n&#34;) chunks := make([]*DocumentChunk, 0) currentChunk := &#34;&#34; startOffset := 0 for _, paragraph := range paragraphs { paragraph = strings.TrimSpace(paragraph) if paragraph == &#34;&#34; { continue } // Check if adding this paragraph would exceed chunk size if len(currentChunk)&#43;len(paragraph)&#43;2 &gt; dc.config.ChunkSize &amp;&amp; currentChunk != &#34;&#34; { // Create chunk from current content chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) // Start new chunk with overlap overlapSize := min(dc.config.ChunkOverlap, len(currentChunk)) currentChunk = currentChunk[len(currentChunk)-overlapSize:] &#43; &#34;\n\n&#34; &#43; paragraph startOffset = startOffset &#43; len(currentChunk) - overlapSize } else { // Add paragraph to current chunk if currentChunk != &#34;&#34; { currentChunk &#43;= &#34;\n\n&#34; } currentChunk &#43;= paragraph } } // Add final chunk if there&#39;s content if currentChunk != &#34;&#34; &amp;&amp; len(currentChunk) &gt;= dc.config.MinChunkSize { chunk := dc.createChunk(doc, currentChunk, len(chunks), startOffset, startOffset&#43;len(currentChunk)) chunks = append(chunks, chunk) } return chunks, nil } func (dc *DocumentChunker) createChunk(doc *Document, content string, index, startOffset, endOffset int) *DocumentChunk { return &amp;DocumentChunk{ ID: fmt.Sprintf(&#34;%s_chunk_%d&#34;, doc.ID, index), DocumentID: doc.ID, Content: content, ChunkIndex: index, StartOffset: startOffset, EndOffset: endOffset, CreatedAt: time.Now(), Metadata: map[string]string{ &#34;document_id&#34;: doc.ID, &#34;document_title&#34;: doc.Title, &#34;document_source&#34;: doc.Source, &#34;chunk_strategy&#34;: dc.config.Strategy, &#34;chunk_index&#34;: fmt.Sprintf(&#34;%d&#34;, index), }, } } func min(a, b int) int { if a &lt; b { return a } return b }Knowledge Base Management 1. Knowledge Base Manager type KnowledgeBaseManager struct { memory core.Memory processor *DocumentProcessor config ManagerConfig } type ManagerConfig struct { AutoIndexing bool IndexingInterval time.Duration BackupEnabled bool BackupInterval time.Duration } func NewKnowledgeBaseManager(memory core.Memory) *KnowledgeBaseManager { processor := NewDocumentProcessor(memory) return &amp;KnowledgeBaseManager{ memory: memory, processor: processor, config: ManagerConfig{ AutoIndexing: true, IndexingInterval: 1 * time.Hour, BackupEnabled: true, BackupInterval: 24 * time.Hour, }, } } func (kbm *KnowledgeBaseManager) AddDocument(ctx context.Context, filePath string) error { return kbm.processor.ProcessFile(ctx, filePath) } func (kbm *KnowledgeBaseManager) AddDocumentFromContent(ctx context.Context, title, content string, metadata map[string]string) error { doc := &amp;Document{ ID: generateDocumentID(title &#43; content), Title: title, Content: content, Source: &#34;direct-input&#34;, CreatedAt: time.Now(), UpdatedAt: time.Now(), Metadata: metadata, } return kbm.processor.ProcessDocument(ctx, doc) } func (kbm *KnowledgeBaseManager) Search(ctx context.Context, query string, options ...core.SearchOption) ([]core.MemoryResult, error) { return kbm.memory.Search(ctx, query, options...) } func (kbm *KnowledgeBaseManager) GetStats(ctx context.Context) (*KnowledgeBaseStats, error) { memoryStats, err := kbm.memory.GetStats(ctx) if err != nil { return nil, err } return &amp;KnowledgeBaseStats{ TotalDocuments: memoryStats.ItemCount, TotalChunks: memoryStats.ItemCount, IndexSize: memoryStats.SizeBytes, LastUpdated: time.Now(), }, nil } type KnowledgeBaseStats struct { TotalDocuments int64 `json:&#34;total_documents&#34;` TotalChunks int64 `json:&#34;total_chunks&#34;` IndexSize int64 `json:&#34;index_size_bytes&#34;` LastUpdated time.Time `json:&#34;last_updated&#34;` }Usage Example Complete Knowledge Base Example func main() { // Setup memory with vector database memory, err := core.NewMemory(core.AgentMemoryConfig{ Provider: &#34;pgvector&#34;, Connection: &#34;postgres://user:pass@localhost:5432/agentdb&#34;, EnableRAG: true, Dimensions: 1536, Embedding: core.EmbeddingConfig{ Provider: &#34;openai&#34;, Model: &#34;text-embedding-3-small&#34;, APIKey: os.Getenv(&#34;OPENAI_API_KEY&#34;), Dimensions: 1536, }, }) if err != nil { log.Fatalf(&#34;Failed to create memory: %v&#34;, err) } // Create knowledge base manager kbManager := NewKnowledgeBaseManager(memory) ctx := context.Background() // Add documents to knowledge base documents := []string{ &#34;./docs/tutorial1.md&#34;, &#34;./docs/tutorial2.md&#34;, &#34;./docs/api-reference.md&#34;, } for _, docPath := range documents { err := kbManager.AddDocument(ctx, docPath) if err != nil { log.Printf(&#34;Failed to add document %s: %v&#34;, docPath, err) } else { log.Printf(&#34;Successfully added document: %s&#34;, docPath) } } // Add content directly err = kbManager.AddDocumentFromContent(ctx, &#34;AgenticGoKit Overview&#34;, &#34;AgenticGoKit is a Go framework for building multi-agent systems...&#34;, map[string]string{ &#34;category&#34;: &#34;overview&#34;, &#34;author&#34;: &#34;AgenticGoKit Team&#34;, }, ) if err != nil { log.Printf(&#34;Failed to add content: %v&#34;, err) } // Search the knowledge base results, err := kbManager.Search(ctx, &#34;How to build multi-agent systems?&#34;, core.WithLimit(5), core.WithScoreThreshold(0.7), ) if err != nil { log.Printf(&#34;Search failed: %v&#34;, err) } else { fmt.Printf(&#34;Found %d results:\n&#34;, len(results)) for i, result := range results { fmt.Printf(&#34;%d. %s (Score: %.3f)\n&#34;, i&#43;1, result.Content[:100]&#43;&#34;...&#34;, result.Score) } } // Get knowledge base statistics stats, err := kbManager.GetStats(ctx) if err != nil { log.Printf(&#34;Failed to get stats: %v&#34;, err) } else { fmt.Printf(&#34;Knowledge Base Stats:\n&#34;) fmt.Printf(&#34; Documents: %d\n&#34;, stats.TotalDocuments) fmt.Printf(&#34; Chunks: %d\n&#34;, stats.TotalChunks) fmt.Printf(&#34; Index Size: %d MB\n&#34;, stats.IndexSize/1024/1024) } }Best Practices 1. Document Processing Format Support: Implement parsers for all relevant document formats Error Handling: Gracefully handle parsing errors and corrupted files Batch Processing: Process multiple documents efficiently Progress Tracking: Provide feedback on processing progress Validation: Validate documents before processing 2. Chunking Strategy Content-Aware: Use semantic chunking for better context preservation Overlap Management: Balance overlap size with storage efficiency Size Optimization: Optimize chunk size for your embedding model Metadata Preservation: Maintain document context in chunks Quality Control: Validate chunk quality and coherence 3. Search Optimization Index Tuning: Optimize vector database indexes Query Enhancement: Improve query understanding Result Ranking: Implement effective ranking algorithms Caching: Cache frequent searches Performance Monitoring: Track search performance metrics Conclusion Knowledge bases in AgenticGoKit provide the foundation for intelligent information retrieval and RAG systems. Key takeaways:">
    <meta itemprop="datePublished" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="dateModified" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="wordCount" content="1820">
    <title>knowledge-bases :: AgenticGoKit Docs</title>
    <link href="/AgenticGoKitDocs/css/auto-complete/auto-complete.min.css?1753430931" rel="stylesheet">
    <script src="/AgenticGoKitDocs/js/auto-complete/auto-complete.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search-lunr.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/AgenticGoKitDocs/searchindex.en.js?1753430931";
    </script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.stemmer.support.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.multi.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.en.min.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet"></noscript>
    <link href="/AgenticGoKitDocs/css/perfect-scrollbar/perfect-scrollbar.min.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/theme.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/format-html.css?1753430931" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/tutorials\/memory-systems\/knowledge-bases\/index.html';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='http:\/\/localhost:1313\/AgenticGoKitDocs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'blue' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
  </head>
  <body class="mobile-support html" data-url="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#prerequisites">Prerequisites</a></li>
    <li><a href="#knowledge-base-architecture">Knowledge Base Architecture</a>
      <ul>
        <li><a href="#components-overview">Components Overview</a></li>
        <li><a href="#knowledge-base-layers">Knowledge Base Layers</a></li>
      </ul>
    </li>
    <li><a href="#document-ingestion-pipeline">Document Ingestion Pipeline</a>
      <ul>
        <li><a href="#1-basic-document-processor">1. Basic Document Processor</a></li>
      </ul>
    </li>
    <li><a href="#document-chunking-strategies">Document Chunking Strategies</a>
      <ul>
        <li><a href="#1-document-chunker">1. Document Chunker</a></li>
      </ul>
    </li>
    <li><a href="#knowledge-base-management">Knowledge Base Management</a>
      <ul>
        <li><a href="#1-knowledge-base-manager">1. Knowledge Base Manager</a></li>
      </ul>
    </li>
    <li><a href="#usage-example">Usage Example</a>
      <ul>
        <li><a href="#complete-knowledge-base-example">Complete Knowledge Base Example</a></li>
      </ul>
    </li>
    <li><a href="#best-practices">Best Practices</a>
      <ul>
        <li><a href="#1-document-processing">1. Document Processing</a></li>
        <li><a href="#2-chunking-strategy">2. Chunking Strategy</a></li>
        <li><a href="#3-search-optimization">3. Search Optimization</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#next-steps">Next Steps</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/index.html"><span itemprop="name">content</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/index.html"><span itemprop="name">tutorials</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><span itemprop="name">memory-systems</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">knowledge-bases</span><meta itemprop="position" content="4"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html" title="document-ingestion (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html" title="memory-optimization (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable tutorials" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="knowledge-bases">knowledge-bases</h1>

<h1 id="knowledge-bases-in-agenticgokit">Knowledge Bases in AgenticGoKit</h1>
<h2 id="overview">Overview</h2>
<p>Knowledge bases are structured repositories of information that enable agents to access, search, and reason over large collections of documents and data. This tutorial covers building comprehensive knowledge bases with AgenticGoKit, including document ingestion, chunking strategies, metadata management, and search optimization.</p>
<p>Knowledge bases transform raw information into accessible, searchable knowledge that agents can use to provide accurate and contextual responses.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Understanding of <a href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">RAG Implementation</a></li>
<li>Familiarity with <a href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">Vector Databases</a></li>
<li>Knowledge of document processing and text extraction</li>
<li>Basic understanding of information retrieval concepts</li>
</ul>
<h2 id="knowledge-base-architecture">Knowledge Base Architecture</h2>
<h3 id="components-overview">Components Overview</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Documents     │───▶│   Ingestion      │───▶│   Processing    │
│   (PDF, MD,     │    │   Pipeline       │    │   Pipeline      │
│    HTML, etc.)  │    └──────────────────┘    └─────────────────┘
└─────────────────┘                                      │
                                                         ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Search &amp;      │◀───│   Vector Store   │◀───│   Chunking &amp;    │
│   Retrieval     │    │   (pgvector/     │    │   Embedding     │
└─────────────────┘    │    Weaviate)     │    └─────────────────┘
                       └──────────────────┘</code></pre></div>
<h3 id="knowledge-base-layers">Knowledge Base Layers</h3>
<ol>
<li><strong>Storage Layer</strong>: Vector database with metadata</li>
<li><strong>Processing Layer</strong>: Document parsing and chunking</li>
<li><strong>Embedding Layer</strong>: Vector representation generation</li>
<li><strong>Retrieval Layer</strong>: Search and ranking algorithms</li>
<li><strong>Management Layer</strong>: Updates, versioning, and maintenance</li>
</ol>
<h2 id="document-ingestion-pipeline">Document Ingestion Pipeline</h2>
<h3 id="1-basic-document-processor">1. Basic Document Processor</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;io/ioutil&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;path/filepath&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/kunalkushwaha/agenticgokit/core&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DocumentProcessor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>     <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parsers</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">DocumentParser</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunker</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span>     <span style="color:#a6e22e">ProcessingConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ProcessingConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkSize</span>        <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkOverlap</span>     <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxFileSize</span>      <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SupportedFormats</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">BatchSize</span>        <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DocumentParser</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SupportedExtensions</span>() []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Document</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ID</span>          <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Title</span>       <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Content</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Metadata</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Source</span>      <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CreatedAt</span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">UpdatedAt</span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewDocumentProcessor</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">DocumentProcessor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>:  <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">parsers</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">DocumentParser</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunker</span>: <span style="color:#a6e22e">NewDocumentChunker</span>(<span style="color:#a6e22e">ChunkingConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkSize</span>:    <span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkOverlap</span>: <span style="color:#ae81ff">200</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Strategy</span>:     <span style="color:#e6db74">&#34;semantic&#34;</span>,
</span></span><span style="display:flex;"><span>        }),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">ProcessingConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkSize</span>:        <span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkOverlap</span>:     <span style="color:#ae81ff">200</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">MaxFileSize</span>:      <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>, <span style="color:#75715e">// 10MB</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">SupportedFormats</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;.txt&#34;</span>, <span style="color:#e6db74">&#34;.md&#34;</span>, <span style="color:#e6db74">&#34;.pdf&#34;</span>, <span style="color:#e6db74">&#34;.html&#34;</span>},
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">BatchSize</span>:        <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Register parsers</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">registerParsers</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">registerParsers</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">parsers</span>[<span style="color:#e6db74">&#34;.txt&#34;</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TextParser</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">parsers</span>[<span style="color:#e6db74">&#34;.md&#34;</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MarkdownParser</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">parsers</span>[<span style="color:#e6db74">&#34;.pdf&#34;</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">PDFParser</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">parsers</span>[<span style="color:#e6db74">&#34;.html&#34;</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">HTMLParser</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">ProcessFile</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check file size</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fileInfo</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stat</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to stat file: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Size</span>() &gt; <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MaxFileSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;file too large: %d bytes&#34;</span>, <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Size</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get parser for file extension</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ext</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">filepath</span>.<span style="color:#a6e22e">Ext</span>(<span style="color:#a6e22e">filePath</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parser</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">parsers</span>[<span style="color:#a6e22e">ext</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unsupported file format: %s&#34;</span>, <span style="color:#a6e22e">ext</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to parse document: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add file metadata</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;file_path&#34;</span>] = <span style="color:#a6e22e">filePath</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;file_size&#34;</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Size</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Metadata</span>[<span style="color:#e6db74">&#34;processed_at&#34;</span>] = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Format</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">RFC3339</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">ProcessDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">ProcessDocument</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">doc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Chunk the document</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">chunker</span>.<span style="color:#a6e22e">ChunkDocument</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to chunk document: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Processing document &#39;%s&#39; with %d chunks&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Title</span>, len(<span style="color:#a6e22e">chunks</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store chunks in batches</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">chunks</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">BatchSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">BatchSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">chunks</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">chunks</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">batch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chunks</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">end</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">storeBatch</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">batch</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to store batch: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Successfully processed document &#39;%s&#39;&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Title</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>) <span style="color:#a6e22e">storeBatch</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">chunks</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">chunks</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dp</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">chunk</span>.<span style="color:#a6e22e">Content</span>, <span style="color:#e6db74">&#34;document-chunk&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithMetadata</span>(<span style="color:#a6e22e">chunk</span>.<span style="color:#a6e22e">Metadata</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">chunk</span>.<span style="color:#a6e22e">CreatedAt</span>),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to store chunk %s: %w&#34;</span>, <span style="color:#a6e22e">chunk</span>.<span style="color:#a6e22e">ID</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Simple text parser</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TextParser</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TextParser</span>) <span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadFile</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:        <span style="color:#a6e22e">generateDocumentID</span>(<span style="color:#a6e22e">filePath</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Title</span>:     <span style="color:#a6e22e">filepath</span>.<span style="color:#a6e22e">Base</span>(<span style="color:#a6e22e">filePath</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Content</span>:   string(<span style="color:#a6e22e">content</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Source</span>:    <span style="color:#a6e22e">filePath</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CreatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">UpdatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;format&#34;</span>: <span style="color:#e6db74">&#34;text&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;parser&#34;</span>: <span style="color:#e6db74">&#34;text&#34;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TextParser</span>) <span style="color:#a6e22e">SupportedExtensions</span>() []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;.txt&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Markdown parser</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MarkdownParser</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">mp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MarkdownParser</span>) <span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadFile</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract title from first heading</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(string(<span style="color:#a6e22e">content</span>), <span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">filepath</span>.<span style="color:#a6e22e">Base</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lines</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;# &#34;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">title</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;# &#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:        <span style="color:#a6e22e">generateDocumentID</span>(<span style="color:#a6e22e">filePath</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Title</span>:     <span style="color:#a6e22e">title</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Content</span>:   string(<span style="color:#a6e22e">content</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Source</span>:    <span style="color:#a6e22e">filePath</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CreatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">UpdatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;format&#34;</span>: <span style="color:#e6db74">&#34;markdown&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;parser&#34;</span>: <span style="color:#e6db74">&#34;markdown&#34;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">mp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MarkdownParser</span>) <span style="color:#a6e22e">SupportedExtensions</span>() []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;.md&#34;</span>, <span style="color:#e6db74">&#34;.markdown&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">generateDocumentID</span>(<span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Generate unique ID based on file path</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sha256</span>.<span style="color:#a6e22e">Sum256</span>([]byte(<span style="color:#a6e22e">filePath</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">String</span>()))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%x&#34;</span>, <span style="color:#a6e22e">hash</span>)[:<span style="color:#ae81ff">16</span>]
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="document-chunking-strategies">Document Chunking Strategies</h2>
<h3 id="1-document-chunker">1. Document Chunker</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DocumentChunker</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span> <span style="color:#a6e22e">ChunkingConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ChunkingConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkSize</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkOverlap</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Strategy</span>     <span style="color:#66d9ef">string</span> <span style="color:#75715e">// &#34;fixed&#34;, &#34;semantic&#34;, &#34;sentence&#34;, &#34;paragraph&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MinChunkSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MaxChunkSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DocumentChunk</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ID</span>          <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DocumentID</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Content</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ChunkIndex</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">StartOffset</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EndOffset</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Metadata</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CreatedAt</span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewDocumentChunker</span>(<span style="color:#a6e22e">config</span> <span style="color:#a6e22e">ChunkingConfig</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">DocumentChunker</span>{<span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">config</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span>) <span style="color:#a6e22e">ChunkDocument</span>(<span style="color:#a6e22e">doc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">Strategy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;fixed&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">fixedSizeChunking</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;semantic&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">semanticChunking</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;sentence&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">sentenceChunking</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;paragraph&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">paragraphChunking</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">fixedSizeChunking</span>(<span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span>) <span style="color:#a6e22e">fixedSizeChunking</span>(<span style="color:#a6e22e">doc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunks</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">content</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ChunkSize</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ChunkOverlap</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ChunkSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> &gt; len(<span style="color:#a6e22e">content</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunkContent</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">content</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">end</span>]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Skip chunks that are too small</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">chunkContent</span>) &lt; <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MinChunkSize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">DocumentChunk</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ID</span>:          <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s_chunk_%d&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>, len(<span style="color:#a6e22e">chunks</span>)),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">DocumentID</span>:  <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Content</span>:     <span style="color:#a6e22e">chunkContent</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ChunkIndex</span>:  len(<span style="color:#a6e22e">chunks</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">StartOffset</span>: <span style="color:#a6e22e">i</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EndOffset</span>:   <span style="color:#a6e22e">end</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">CreatedAt</span>:   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;document_id&#34;</span>:    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;document_title&#34;</span>: <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Title</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;document_source&#34;</span>: <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Source</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chunk_strategy&#34;</span>: <span style="color:#e6db74">&#34;fixed&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;chunk_index&#34;</span>:    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, len(<span style="color:#a6e22e">chunks</span>)),
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">chunk</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">end</span> <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">content</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chunks</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span>) <span style="color:#a6e22e">semanticChunking</span>(<span style="color:#a6e22e">doc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>) ([]<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Content</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Split by double newlines (paragraphs)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">paragraphs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">content</span>, <span style="color:#e6db74">&#34;\n\n&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunks</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">paragraph</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">paragraphs</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">paragraph</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">paragraph</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">paragraph</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if adding this paragraph would exceed chunk size</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">currentChunk</span>)<span style="color:#f92672">+</span>len(<span style="color:#a6e22e">paragraph</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> &gt; <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ChunkSize</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Create chunk from current content</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">createChunk</span>(<span style="color:#a6e22e">doc</span>, <span style="color:#a6e22e">currentChunk</span>, len(<span style="color:#a6e22e">chunks</span>), <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">startOffset</span><span style="color:#f92672">+</span>len(<span style="color:#a6e22e">currentChunk</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">chunk</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Start new chunk with overlap</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">overlapSize</span> <span style="color:#f92672">:=</span> min(<span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ChunkOverlap</span>, len(<span style="color:#a6e22e">currentChunk</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">currentChunk</span> = <span style="color:#a6e22e">currentChunk</span>[len(<span style="color:#a6e22e">currentChunk</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">overlapSize</span>:] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\n\n&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">paragraph</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">startOffset</span> = <span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">currentChunk</span>) <span style="color:#f92672">-</span> <span style="color:#a6e22e">overlapSize</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Add paragraph to current chunk</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;\n\n&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">paragraph</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add final chunk if there&#39;s content</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentChunk</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">currentChunk</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">MinChunkSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunk</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">createChunk</span>(<span style="color:#a6e22e">doc</span>, <span style="color:#a6e22e">currentChunk</span>, len(<span style="color:#a6e22e">chunks</span>), <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">startOffset</span><span style="color:#f92672">+</span>len(<span style="color:#a6e22e">currentChunk</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunks</span> = append(<span style="color:#a6e22e">chunks</span>, <span style="color:#a6e22e">chunk</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chunks</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">dc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunker</span>) <span style="color:#a6e22e">createChunk</span>(<span style="color:#a6e22e">doc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Document</span>, <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">endOffset</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentChunk</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">DocumentChunk</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:          <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s_chunk_%d&#34;</span>, <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>, <span style="color:#a6e22e">index</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">DocumentID</span>:  <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Content</span>:     <span style="color:#a6e22e">content</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ChunkIndex</span>:  <span style="color:#a6e22e">index</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">StartOffset</span>: <span style="color:#a6e22e">startOffset</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">EndOffset</span>:   <span style="color:#a6e22e">endOffset</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CreatedAt</span>:   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Metadata</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;document_id&#34;</span>:    <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">ID</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;document_title&#34;</span>: <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Title</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;document_source&#34;</span>: <span style="color:#a6e22e">doc</span>.<span style="color:#a6e22e">Source</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;chunk_strategy&#34;</span>: <span style="color:#a6e22e">dc</span>.<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">Strategy</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;chunk_index&#34;</span>:    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#a6e22e">index</span>),
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> min(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="knowledge-base-management">Knowledge Base Management</h2>
<h3 id="1-knowledge-base-manager">1. Knowledge Base Manager</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">KnowledgeBaseManager</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>     <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">processor</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">DocumentProcessor</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">config</span>     <span style="color:#a6e22e">ManagerConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ManagerConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AutoIndexing</span>     <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IndexingInterval</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">BackupEnabled</span>    <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">BackupInterval</span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewKnowledgeBaseManager</span>(<span style="color:#a6e22e">memory</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Memory</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">processor</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewDocumentProcessor</span>(<span style="color:#a6e22e">memory</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">KnowledgeBaseManager</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory</span>:    <span style="color:#a6e22e">memory</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">processor</span>: <span style="color:#a6e22e">processor</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">config</span>: <span style="color:#a6e22e">ManagerConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">AutoIndexing</span>:     <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">IndexingInterval</span>: <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Hour</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">BackupEnabled</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">BackupInterval</span>:   <span style="color:#ae81ff">24</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Hour</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">kbm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseManager</span>) <span style="color:#a6e22e">AddDocument</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">filePath</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">kbm</span>.<span style="color:#a6e22e">processor</span>.<span style="color:#a6e22e">ProcessFile</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">kbm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseManager</span>) <span style="color:#a6e22e">AddDocumentFromContent</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">title</span>, <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">metadata</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Document</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ID</span>:        <span style="color:#a6e22e">generateDocumentID</span>(<span style="color:#a6e22e">title</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">content</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Title</span>:     <span style="color:#a6e22e">title</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Content</span>:   <span style="color:#a6e22e">content</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Source</span>:    <span style="color:#e6db74">&#34;direct-input&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CreatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">UpdatedAt</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Metadata</span>:  <span style="color:#a6e22e">metadata</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">kbm</span>.<span style="color:#a6e22e">processor</span>.<span style="color:#a6e22e">ProcessDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">doc</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">kbm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseManager</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">query</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">options</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">SearchOption</span>) ([]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MemoryResult</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">kbm</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">options</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">kbm</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseManager</span>) <span style="color:#a6e22e">GetStats</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">KnowledgeBaseStats</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memoryStats</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kbm</span>.<span style="color:#a6e22e">memory</span>.<span style="color:#a6e22e">GetStats</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">KnowledgeBaseStats</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TotalDocuments</span>: <span style="color:#a6e22e">memoryStats</span>.<span style="color:#a6e22e">ItemCount</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TotalChunks</span>:    <span style="color:#a6e22e">memoryStats</span>.<span style="color:#a6e22e">ItemCount</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">IndexSize</span>:      <span style="color:#a6e22e">memoryStats</span>.<span style="color:#a6e22e">SizeBytes</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">LastUpdated</span>:    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(),
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">KnowledgeBaseStats</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">TotalDocuments</span> <span style="color:#66d9ef">int64</span>     <span style="color:#e6db74">`json:&#34;total_documents&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">TotalChunks</span>    <span style="color:#66d9ef">int64</span>     <span style="color:#e6db74">`json:&#34;total_chunks&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IndexSize</span>      <span style="color:#66d9ef">int64</span>     <span style="color:#e6db74">`json:&#34;index_size_bytes&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LastUpdated</span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span> <span style="color:#e6db74">`json:&#34;last_updated&#34;`</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="usage-example">Usage Example</h2>
<h3 id="complete-knowledge-base-example">Complete Knowledge Base Example</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setup memory with vector database</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">NewMemory</span>(<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">AgentMemoryConfig</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Provider</span>:   <span style="color:#e6db74">&#34;pgvector&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Connection</span>: <span style="color:#e6db74">&#34;postgres://user:pass@localhost:5432/agentdb&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">EnableRAG</span>:  <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Dimensions</span>: <span style="color:#ae81ff">1536</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Embedding</span>: <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">EmbeddingConfig</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Provider</span>:   <span style="color:#e6db74">&#34;openai&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Model</span>:      <span style="color:#e6db74">&#34;text-embedding-3-small&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">APIKey</span>:     <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;OPENAI_API_KEY&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Dimensions</span>: <span style="color:#ae81ff">1536</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Failed to create memory: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create knowledge base manager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kbManager</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewKnowledgeBaseManager</span>(<span style="color:#a6e22e">memory</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add documents to knowledge base</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">documents</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;./docs/tutorial1.md&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;./docs/tutorial2.md&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;./docs/api-reference.md&#34;</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">docPath</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">documents</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kbManager</span>.<span style="color:#a6e22e">AddDocument</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">docPath</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to add document %s: %v&#34;</span>, <span style="color:#a6e22e">docPath</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Successfully added document: %s&#34;</span>, <span style="color:#a6e22e">docPath</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add content directly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">kbManager</span>.<span style="color:#a6e22e">AddDocumentFromContent</span>(<span style="color:#a6e22e">ctx</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;AgenticGoKit Overview&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;AgenticGoKit is a Go framework for building multi-agent systems...&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;category&#34;</span>: <span style="color:#e6db74">&#34;overview&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;author&#34;</span>:   <span style="color:#e6db74">&#34;AgenticGoKit Team&#34;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to add content: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Search the knowledge base</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kbManager</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#e6db74">&#34;How to build multi-agent systems?&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithLimit</span>(<span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">WithScoreThreshold</span>(<span style="color:#ae81ff">0.7</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Search failed: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Found %d results:\n&#34;</span>, len(<span style="color:#a6e22e">results</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d. %s (Score: %.3f)\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Content</span>[:<span style="color:#ae81ff">100</span>]<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;...&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Score</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get knowledge base statistics</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stats</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kbManager</span>.<span style="color:#a6e22e">GetStats</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Failed to get stats: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Knowledge Base Stats:\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Documents: %d\n&#34;</span>, <span style="color:#a6e22e">stats</span>.<span style="color:#a6e22e">TotalDocuments</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Chunks: %d\n&#34;</span>, <span style="color:#a6e22e">stats</span>.<span style="color:#a6e22e">TotalChunks</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;  Index Size: %d MB\n&#34;</span>, <span style="color:#a6e22e">stats</span>.<span style="color:#a6e22e">IndexSize</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="best-practices">Best Practices</h2>
<h3 id="1-document-processing">1. Document Processing</h3>
<ul>
<li><strong>Format Support</strong>: Implement parsers for all relevant document formats</li>
<li><strong>Error Handling</strong>: Gracefully handle parsing errors and corrupted files</li>
<li><strong>Batch Processing</strong>: Process multiple documents efficiently</li>
<li><strong>Progress Tracking</strong>: Provide feedback on processing progress</li>
<li><strong>Validation</strong>: Validate documents before processing</li>
</ul>
<h3 id="2-chunking-strategy">2. Chunking Strategy</h3>
<ul>
<li><strong>Content-Aware</strong>: Use semantic chunking for better context preservation</li>
<li><strong>Overlap Management</strong>: Balance overlap size with storage efficiency</li>
<li><strong>Size Optimization</strong>: Optimize chunk size for your embedding model</li>
<li><strong>Metadata Preservation</strong>: Maintain document context in chunks</li>
<li><strong>Quality Control</strong>: Validate chunk quality and coherence</li>
</ul>
<h3 id="3-search-optimization">3. Search Optimization</h3>
<ul>
<li><strong>Index Tuning</strong>: Optimize vector database indexes</li>
<li><strong>Query Enhancement</strong>: Improve query understanding</li>
<li><strong>Result Ranking</strong>: Implement effective ranking algorithms</li>
<li><strong>Caching</strong>: Cache frequent searches</li>
<li><strong>Performance Monitoring</strong>: Track search performance metrics</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Knowledge bases in AgenticGoKit provide the foundation for intelligent information retrieval and RAG systems. Key takeaways:</p>
<ul>
<li>Design comprehensive document processing pipelines</li>
<li>Implement appropriate chunking strategies for your content</li>
<li>Use rich metadata to enhance search and filtering</li>
<li>Optimize search performance through indexing and caching</li>
<li>Monitor and maintain knowledge base quality over time</li>
</ul>
<p>Well-designed knowledge bases enable agents to access and utilize vast amounts of information effectively, making them more knowledgeable and helpful.</p>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">Memory Optimization</a> - Advanced performance tuning</li>
<li><a href="/AgenticGoKitDocs/tutorials/readme/index.html">Production Deployment</a> - Deploy knowledge bases at scale</li>
<li><a href="/AgenticGoKitDocs/tutorials/readme/index.html">Monitoring and Observability</a> - Monitor knowledge base performance</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://nlp.stanford.edu/IR-book/" rel="external" target="_blank">Information Retrieval Fundamentals</a></li>
<li><a href="https://github.com/pgvector/pgvector" rel="external" target="_blank">Vector Database Comparison</a></li>
<li><a href="https://github.com/unidoc/unipdf" rel="external" target="_blank">Document Processing Libraries</a></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Jul 25, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/AgenticGoKitDocs/index.html">
            <div class="logo-title">AgenticGoKit Docs</div>
          </a>
        </div>
        <search><form action="/AgenticGoKitDocs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/index.html"><a class="padding" href="/AgenticGoKitDocs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/readme/index.html">content</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/index.html"><input type="checkbox" id="R-section-8fc2fd7736125e87cab8840a86c2af5a" aria-controls="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" checked><label for="R-section-8fc2fd7736125e87cab8840a86c2af5a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu guides</span></label><a class="padding" href="/AgenticGoKitDocs/guides/index.html">guides</a><ul id="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/readme/index.html">guides</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/agentbasics/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/agentbasics/index.html">AgentBasics</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/examples/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/examples/index.html">Examples</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/configuration/index.html">Configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/customtools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/customtools/index.html">CustomTools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/providers/index.html">Providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html">MemoryProviderSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html">MemoryTroubleshooting</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html">EmbeddingModelGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/ragconfiguration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/ragconfiguration/index.html">RAGConfiguration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/toolintegration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/toolintegration/index.html">ToolIntegration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/pgvectorsetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/pgvectorsetup/index.html">PgVectorSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/weaviatesetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/weaviatesetup/index.html">WeaviateSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/performance/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/performance/index.html">Performance</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/errorhandling/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/errorhandling/index.html">ErrorHandling</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/deployment/index.html"><input type="checkbox" id="R-section-ecc839349395ef3c015a12132049dff2" aria-controls="R-subsections-ecc839349395ef3c015a12132049dff2" checked><label for="R-section-ecc839349395ef3c015a12132049dff2"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu deployment</span></label><a class="padding" href="/AgenticGoKitDocs/guides/deployment/index.html">deployment</a><ul id="R-subsections-ecc839349395ef3c015a12132049dff2" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/deployment/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/deployment/readme/index.html">deployment</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/development/index.html"><input type="checkbox" id="R-section-fff1f5eca5d0a93209b9c6262762c25a" aria-controls="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" checked><label for="R-section-fff1f5eca5d0a93209b9c6262762c25a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu development</span></label><a class="padding" href="/AgenticGoKitDocs/guides/development/index.html">development</a><ul id="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/readme/index.html">development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/best-practices/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/best-practices/index.html">best-practices</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/debugging/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/debugging/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/research-assistant/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/research-assistant/index.html">research-assistant</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/testing-agents/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/testing-agents/index.html">testing-agents</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/visualization/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/visualization/index.html">visualization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/web-search-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/web-search-integration/index.html">web-search-integration</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/framework-comparison/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/framework-comparison/index.html">framework-comparison</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memory/index.html">Memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html">ScaffoldMemoryGuide</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/setup/index.html"><input type="checkbox" id="R-section-0124aed9abb5064d53391168f3c95c22" aria-controls="R-subsections-0124aed9abb5064d53391168f3c95c22" checked><label for="R-section-0124aed9abb5064d53391168f3c95c22"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu setup</span></label><a class="padding" href="/AgenticGoKitDocs/guides/setup/index.html">setup</a><ul id="R-subsections-0124aed9abb5064d53391168f3c95c22" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/readme/index.html">setup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/llm-providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/llm-providers/index.html">llm-providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html">mcp-tools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html">orchestration-configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/vector-databases/index.html">vector-databases</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/troubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/troubleshooting/index.html">troubleshooting</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/contributors/index.html"><input type="checkbox" id="R-section-190d9b328fbda7e13ab386f7a5417de5" aria-controls="R-subsections-190d9b328fbda7e13ab386f7a5417de5" checked><label for="R-section-190d9b328fbda7e13ab386f7a5417de5"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu contributors</span></label><a class="padding" href="/AgenticGoKitDocs/contributors/index.html">contributors</a><ul id="R-subsections-190d9b328fbda7e13ab386f7a5417de5" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/readme/index.html">contributors</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/contributorguide/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/contributorguide/index.html">ContributorGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/codestyle/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/codestyle/index.html">CodeStyle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/corevsinternal/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/corevsinternal/index.html">CoreVsInternal</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/addingfeatures/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/addingfeatures/index.html">AddingFeatures</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/testing/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/testing/index.html">Testing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/docsstandards/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/docsstandards/index.html">DocsStandards</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/reference/index.html"><input type="checkbox" id="R-section-66002f201bef818664bb81aa67490c58" aria-controls="R-subsections-66002f201bef818664bb81aa67490c58" checked><label for="R-section-66002f201bef818664bb81aa67490c58"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu reference</span></label><a class="padding" href="/AgenticGoKitDocs/reference/index.html">reference</a><ul id="R-subsections-66002f201bef818664bb81aa67490c58" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/readme/index.html">reference</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/configuration/index.html">configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/cli/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/cli/index.html">cli</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/mcp/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/mcp/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/agent/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/agent/index.html">agent</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/memory/index.html">memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/orchestration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/orchestration/index.html">orchestration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/state-event/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/state-event/index.html">state-event</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/index.html"><input type="checkbox" id="R-section-e1e8c1e70c5500b49e8dda2dc550651a" aria-controls="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" checked><label for="R-section-e1e8c1e70c5500b49e8dda2dc550651a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu tutorials</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/index.html">tutorials</a><ul id="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/readme/index.html">tutorials</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/advanced/index.html"><input type="checkbox" id="R-section-d3def5cd76adc8096d0ff9fda6b8e479" aria-controls="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" checked><label for="R-section-d3def5cd76adc8096d0ff9fda6b8e479"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu advanced</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/index.html">advanced</a><ul id="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/readme/index.html">advanced</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html">circuit-breaker-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html">load-balancing-scaling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html">retry-policies</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html">testing-strategies</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/index.html"><input type="checkbox" id="R-section-212c6ccffb40ecdd78eb2136f98c4cac" aria-controls="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" checked><label for="R-section-212c6ccffb40ecdd78eb2136f98c4cac"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu core-concepts</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/index.html">core-concepts</a><ul id="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html">core-concepts</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html">agent-lifecycle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html">error-handling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html">message-passing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">orchestration-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html">state-management</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/debugging/index.html"><input type="checkbox" id="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" aria-controls="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" checked><label for="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu debugging</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/index.html">debugging</a><ul id="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/readme/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html">debugging-multi-agent-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html">logging-and-tracing</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/index.html"><input type="checkbox" id="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247" aria-controls="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" checked><label for="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu getting-started</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/index.html">getting-started</a><ul id="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html">getting-started</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html">memory-and-rag</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html">multi-agent-collaboration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html">production-deployment</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html">quickstart</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html">tool-integration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html">your-first-agent</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/mcp/index.html"><input type="checkbox" id="R-section-153aac44598009a99dd5a60317a3eecc" aria-controls="R-subsections-153aac44598009a99dd5a60317a3eecc" checked><label for="R-section-153aac44598009a99dd5a60317a3eecc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu mcp</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/index.html">mcp</a><ul id="R-subsections-153aac44598009a99dd5a60317a3eecc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">advanced-tool-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">tool-development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">tool-integration</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><input type="checkbox" id="R-section-9c1a65f2d7b3888241dcafa51a0710e7" aria-controls="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" checked><label for="R-section-9c1a65f2d7b3888241dcafa51a0710e7"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu memory-systems</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html">memory-systems</a><ul id="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">memory-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html">basic-memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">document-ingestion</a></li>
            <li class="active " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">knowledge-bases</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">memory-optimization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">rag-implementation</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">vector-databases</a></li></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/AgenticGoKitDocs/js/clipboard/clipboard.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/perfect-scrollbar/perfect-scrollbar.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/theme.js?1753430931" defer></script>
  </body>
</html>
