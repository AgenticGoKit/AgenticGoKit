<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mcp :: AgenticGoKit Docs</title>
    <link>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/index.html</link>
    <description>Model Context Protocol (MCP) in AgenticGoKit Navigation: Documentation Home → Tutorials → MCP (Tools)&#xA;Overview The Model Context Protocol (MCP) is a powerful framework within AgenticGoKit that enables agents to interact with external tools, APIs, and services. MCP bridges the gap between language models and the outside world, allowing agents to perform actions beyond text generation.&#xA;With MCP, agents can search the web, access databases, call APIs, manipulate files, perform calculations, and much more. This capability transforms agents from simple text processors into powerful assistants that can take meaningful actions.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mcp</title>
      <link>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/readme/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/readme/index.html</guid>
      <description>Model Context Protocol (MCP) in AgenticGoKit Navigation: Documentation Home → Tutorials → MCP (Tools)&#xA;Overview The Model Context Protocol (MCP) is a powerful framework within AgenticGoKit that enables agents to interact with external tools, APIs, and services. MCP bridges the gap between language models and the outside world, allowing agents to perform actions beyond text generation.&#xA;With MCP, agents can search the web, access databases, call APIs, manipulate files, perform calculations, and much more. This capability transforms agents from simple text processors into powerful assistants that can take meaningful actions.</description>
    </item>
    <item>
      <title>advanced-tool-patterns</title>
      <link>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html</guid>
      <description>Advanced Tool Patterns in AgenticGoKit Overview This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.&#xA;Prerequisites Understanding of MCP Overview Completion of Tool Development Familiarity with Tool Integration Knowledge of Orchestration Patterns Tool Composition Patterns 1. Sequential Tool Chains package patterns import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) // ToolChain executes tools in sequence, passing results between them type ToolChain struct { name string steps []ToolStep } type ToolStep struct { ToolName string ParamMapper func(previousResult interface{}, initialParams map[string]interface{}) map[string]interface{} } func NewToolChain(name string) *ToolChain { return &amp;ToolChain{ name: name, steps: make([]ToolStep, 0), } } func (tc *ToolChain) AddStep(toolName string, paramMapper func(interface{}, map[string]interface{}) map[string]interface{}) *ToolChain { tc.steps = append(tc.steps, ToolStep{ ToolName: toolName, ParamMapper: paramMapper, }) return tc } func (tc *ToolChain) Name() string { return tc.name } func (tc *ToolChain) Description() string { return fmt.Sprintf(&#34;Sequential tool chain with %d steps&#34;, len(tc.steps)) } func (tc *ToolChain) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;initial_params&#34;: { Type: &#34;object&#34;, Description: &#34;Initial parameters for the tool chain&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (tc *ToolChain) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { initialParams, ok := params[&#34;initial_params&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;initial_params must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } var currentResult interface{} = initialParams results := make([]interface{}, 0, len(tc.steps)) for i, step := range tc.steps { // Get tool tool, err := mcpManager.GetTool(step.ToolName) if err != nil { return nil, fmt.Errorf(&#34;step %d: failed to get tool %s: %w&#34;, i+1, step.ToolName, err) } // Map parameters var toolParams map[string]interface{} if step.ParamMapper != nil { toolParams = step.ParamMapper(currentResult, initialParams) } else { toolParams = initialParams } // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;step %d: tool %s execution failed: %w&#34;, i+1, step.ToolName, err) } currentResult = result results = append(results, result) } return map[string]interface{}{ &#34;final_result&#34;: currentResult, &#34;all_results&#34;: results, &#34;steps&#34;: len(tc.steps), }, nil } // Example: Research and Analysis Chain func CreateResearchChain() *ToolChain { return NewToolChain(&#34;research_analysis&#34;). AddStep(&#34;search&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { query, _ := initial[&#34;query&#34;].(string) return map[string]interface{}{ &#34;query&#34;: query, &#34;limit&#34;: 5, } }). AddStep(&#34;summarizer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { searchResults := prev.(map[string]interface{}) return map[string]interface{}{ &#34;content&#34;: searchResults[&#34;results&#34;], &#34;max_length&#34;: 500, } }). AddStep(&#34;analyzer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { summary := prev.(map[string]interface{}) return map[string]interface{}{ &#34;text&#34;: summary[&#34;summary&#34;], &#34;analysis_type&#34;: &#34;sentiment_and_topics&#34;, } }) } ```### 2. Parallel Tool Execution ```go // ParallelToolExecutor runs multiple tools concurrently type ParallelToolExecutor struct { name string tools []ParallelToolConfig aggregator ResultAggregator } type ParallelToolConfig struct { ToolName string Parameters map[string]interface{} Optional bool // If true, failure won&#39;t fail the entire execution } type ResultAggregator func(results map[string]interface{}, errors map[string]error) (interface{}, error) func NewParallelToolExecutor(name string, aggregator ResultAggregator) *ParallelToolExecutor { return &amp;ParallelToolExecutor{ name: name, tools: make([]ParallelToolConfig, 0), aggregator: aggregator, } } func (pte *ParallelToolExecutor) AddTool(toolName string, params map[string]interface{}, optional bool) *ParallelToolExecutor { pte.tools = append(pte.tools, ParallelToolConfig{ ToolName: toolName, Parameters: params, Optional: optional, }) return pte } func (pte *ParallelToolExecutor) Name() string { return pte.name } func (pte *ParallelToolExecutor) Description() string { return fmt.Sprintf(&#34;Parallel execution of %d tools&#34;, len(pte.tools)) } func (pte *ParallelToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, &#34;timeout&#34;: { Type: &#34;number&#34;, Description: &#34;Timeout in seconds for parallel execution&#34;, Required: false, Default: 30, }, } } func (pte *ParallelToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } timeout := 30 * time.Second if timeoutParam, ok := params[&#34;timeout&#34;].(float64); ok { timeout = time.Duration(timeoutParam) * time.Second } // Create context with timeout execCtx, cancel := context.WithTimeout(ctx, timeout) defer cancel() // Execute tools in parallel results := make(map[string]interface{}) errors := make(map[string]error) var wg sync.WaitGroup var mu sync.Mutex for _, toolConfig := range pte.tools { wg.Add(1) go func(config ParallelToolConfig) { defer wg.Done() tool, err := mcpManager.GetTool(config.ToolName) if err != nil { mu.Lock() errors[config.ToolName] = fmt.Errorf(&#34;failed to get tool: %w&#34;, err) mu.Unlock() return } result, err := tool.Execute(execCtx, config.Parameters) mu.Lock() if err != nil { errors[config.ToolName] = err } else { results[config.ToolName] = result } mu.Unlock() }(toolConfig) } wg.Wait() // Check for required tool failures for _, toolConfig := range pte.tools { if !toolConfig.Optional { if err, exists := errors[toolConfig.ToolName]; exists { return nil, fmt.Errorf(&#34;required tool %s failed: %w&#34;, toolConfig.ToolName, err) } } } // Aggregate results return pte.aggregator(results, errors) } // Example: Multi-Source Information Gathering func CreateInfoGatheringTool() *ParallelToolExecutor { return NewParallelToolExecutor(&#34;info_gathering&#34;, func(results map[string]interface{}, errors map[string]error) (interface{}, error) { gathered := map[string]interface{}{ &#34;sources&#34;: make(map[string]interface{}), &#34;errors&#34;: make(map[string]string), &#34;summary&#34;: &#34;&#34;, } // Collect successful results for toolName, result := range results { gathered[&#34;sources&#34;].(map[string]interface{})[toolName] = result } // Collect errors for optional tools for toolName, err := range errors { gathered[&#34;errors&#34;].(map[string]string)[toolName] = err.Error() } // Create summary sourceCount := len(results) errorCount := len(errors) gathered[&#34;summary&#34;] = fmt.Sprintf(&#34;Gathered information from %d sources with %d errors&#34;, sourceCount, errorCount) return gathered, nil }). AddTool(&#34;web_search&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, false). AddTool(&#34;weather&#34;, map[string]interface{}{&#34;location&#34;: &#34;current&#34;}, true). AddTool(&#34;stock_prices&#34;, map[string]interface{}{&#34;symbols&#34;: []string{&#34;AAPL&#34;, &#34;GOOGL&#34;}}, true). AddTool(&#34;calendar&#34;, map[string]interface{}{&#34;days&#34;: 7}, true) }&#xD;Conditional Tool Execution 1. Rule-Based Tool Selection // ConditionalToolExecutor executes tools based on conditions type ConditionalToolExecutor struct { name string rules []ExecutionRule } type ExecutionRule struct { Condition func(context.Context, map[string]interface{}) bool ToolName string Parameters func(map[string]interface{}) map[string]interface{} Description string } func NewConditionalToolExecutor(name string) *ConditionalToolExecutor { return &amp;ConditionalToolExecutor{ name: name, rules: make([]ExecutionRule, 0), } } func (cte *ConditionalToolExecutor) AddRule( condition func(context.Context, map[string]interface{}) bool, toolName string, paramMapper func(map[string]interface{}) map[string]interface{}, description string, ) *ConditionalToolExecutor { cte.rules = append(cte.rules, ExecutionRule{ Condition: condition, ToolName: toolName, Parameters: paramMapper, Description: description, }) return cte } func (cte *ConditionalToolExecutor) Name() string { return cte.name } func (cte *ConditionalToolExecutor) Description() string { return fmt.Sprintf(&#34;Conditional tool executor with %d rules&#34;, len(cte.rules)) } func (cte *ConditionalToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;input_data&#34;: { Type: &#34;object&#34;, Description: &#34;Input data for condition evaluation&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (cte *ConditionalToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { inputData, ok := params[&#34;input_data&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;input_data must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } executedRules := make([]map[string]interface{}, 0) for i, rule := range cte.rules { if rule.Condition(ctx, inputData) { // Get tool tool, err := mcpManager.GetTool(rule.ToolName) if err != nil { return nil, fmt.Errorf(&#34;rule %d: failed to get tool %s: %w&#34;, i+1, rule.ToolName, err) } // Prepare parameters toolParams := rule.Parameters(inputData) // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;rule %d: tool %s execution failed: %w&#34;, i+1, rule.ToolName, err) } executedRules = append(executedRules, map[string]interface{}{ &#34;rule_description&#34;: rule.Description, &#34;tool_name&#34;: rule.ToolName, &#34;result&#34;: result, }) } } return map[string]interface{}{ &#34;executed_rules&#34;: executedRules, &#34;total_rules&#34;: len(cte.rules), &#34;matched_rules&#34;: len(executedRules), }, nil } // Example: Smart Assistant Tool Selection func CreateSmartAssistantTool() *ConditionalToolExecutor { return NewConditionalToolExecutor(&#34;smart_assistant&#34;). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;weather&#34;) }, &#34;weather&#34;, func(data map[string]interface{}) map[string]interface{} { location := &#34;current&#34; if loc, ok := data[&#34;location&#34;].(string); ok { location = loc } return map[string]interface{}{&#34;location&#34;: location} }, &#34;Weather information requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) if !ok { return false } mathKeywords := []string{&#34;calculate&#34;, &#34;math&#34;, &#34;+&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;=&#34;} msgLower := strings.ToLower(message) for _, keyword := range mathKeywords { if strings.Contains(msgLower, keyword) { return true } } return false }, &#34;calculator&#34;, func(data map[string]interface{}) map[string]interface{} { // Simple math expression parser would go here return map[string]interface{}{ &#34;expression&#34;: data[&#34;message&#34;], } }, &#34;Mathematical calculation requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;search&#34;) }, &#34;web_search&#34;, func(data map[string]interface{}) map[string]interface{} { return map[string]interface{}{ &#34;query&#34;: data[&#34;message&#34;], &#34;limit&#34;: 5, } }, &#34;Web search requested&#34;, ) } ```## Error Handling and Recovery Patterns ### 1. Retry with Backoff ```go // RetryableTool wraps a tool with retry logic type RetryableTool struct { tool core.Tool maxRetries int baseDelay time.Duration maxDelay time.Duration backoffFunc func(attempt int, baseDelay time.Duration) time.Duration retryChecker func(error) bool } func NewRetryableTool(tool core.Tool, maxRetries int, baseDelay time.Duration) *RetryableTool { return &amp;RetryableTool{ tool: tool, maxRetries: maxRetries, baseDelay: baseDelay, maxDelay: 5 * time.Minute, backoffFunc: func(attempt int, baseDelay time.Duration) time.Duration { // Exponential backoff with jitter delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt))) jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) return delay + jitter }, retryChecker: func(err error) bool { // Retry on network errors, timeouts, and rate limits errStr := strings.ToLower(err.Error()) return strings.Contains(errStr, &#34;timeout&#34;) || strings.Contains(errStr, &#34;network&#34;) || strings.Contains(errStr, &#34;rate limit&#34;) || strings.Contains(errStr, &#34;temporary&#34;) }, } } func (rt *RetryableTool) WithMaxDelay(maxDelay time.Duration) *RetryableTool { rt.maxDelay = maxDelay return rt } func (rt *RetryableTool) WithRetryChecker(checker func(error) bool) *RetryableTool { rt.retryChecker = checker return rt } func (rt *RetryableTool) Name() string { return rt.tool.Name() } func (rt *RetryableTool) Description() string { return rt.tool.Description() } func (rt *RetryableTool) ParameterSchema() map[string]core.ParameterDefinition { return rt.tool.ParameterSchema() } func (rt *RetryableTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { var lastErr error for attempt := 0; attempt &lt;= rt.maxRetries; attempt++ { result, err := rt.tool.Execute(ctx, params) if err == nil { return result, nil } lastErr = err // Check if we should retry if !rt.retryChecker(err) { return nil, fmt.Errorf(&#34;non-retryable error: %w&#34;, err) } // Don&#39;t wait after the last attempt if attempt == rt.maxRetries { break } // Calculate delay delay := rt.backoffFunc(attempt, rt.baseDelay) if delay &gt; rt.maxDelay { delay = rt.maxDelay } // Wait with context cancellation support select { case &lt;-ctx.Done(): return nil, ctx.Err() case &lt;-time.After(delay): // Continue to next attempt } } return nil, fmt.Errorf(&#34;max retries (%d) exceeded, last error: %w&#34;, rt.maxRetries, lastErr) }&#xD;2. Circuit Breaker Pattern // CircuitBreakerTool implements circuit breaker pattern for tools type CircuitBreakerTool struct { tool core.Tool failureThreshold int resetTimeout time.Duration state CircuitState failures int lastFailureTime time.Time mu sync.RWMutex } type CircuitState int const ( CircuitClosed CircuitState = iota CircuitOpen CircuitHalfOpen ) func NewCircuitBreakerTool(tool core.Tool, failureThreshold int, resetTimeout time.Duration) *CircuitBreakerTool { return &amp;CircuitBreakerTool{ tool: tool, failureThreshold: failureThreshold, resetTimeout: resetTimeout, state: CircuitClosed, } } func (cbt *CircuitBreakerTool) Name() string { return cbt.tool.Name() } func (cbt *CircuitBreakerTool) Description() string { return cbt.tool.Description() } func (cbt *CircuitBreakerTool) ParameterSchema() map[string]core.ParameterDefinition { return cbt.tool.ParameterSchema() } func (cbt *CircuitBreakerTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { cbt.mu.Lock() // Check if circuit should be reset if cbt.state == CircuitOpen &amp;&amp; time.Since(cbt.lastFailureTime) &gt; cbt.resetTimeout { cbt.state = CircuitHalfOpen cbt.failures = 0 } // Fail fast if circuit is open if cbt.state == CircuitOpen { cbt.mu.Unlock() return nil, fmt.Errorf(&#34;circuit breaker is open for tool %s&#34;, cbt.tool.Name()) } cbt.mu.Unlock() // Execute tool result, err := cbt.tool.Execute(ctx, params) cbt.mu.Lock() defer cbt.mu.Unlock() if err != nil { cbt.failures++ cbt.lastFailureTime = time.Now() // Open circuit if threshold exceeded if cbt.failures &gt;= cbt.failureThreshold { cbt.state = CircuitOpen } return nil, err } // Success - reset circuit if it was half-open if cbt.state == CircuitHalfOpen { cbt.state = CircuitClosed cbt.failures = 0 } return result, nil } func (cbt *CircuitBreakerTool) GetState() (CircuitState, int, time.Time) { cbt.mu.RLock() defer cbt.mu.RUnlock() return cbt.state, cbt.failures, cbt.lastFailureTime }&#xD;3. Fallback Tool Pattern // FallbackTool tries primary tool first, then fallbacks type FallbackTool struct { name string description string primaryTool core.Tool fallbackTools []FallbackConfig } type FallbackConfig struct { Tool core.Tool Condition func(error) bool ParamMapper func(map[string]interface{}) map[string]interface{} } func NewFallbackTool(name, description string, primaryTool core.Tool) *FallbackTool { return &amp;FallbackTool{ name: name, description: description, primaryTool: primaryTool, fallbackTools: make([]FallbackConfig, 0), } } func (ft *FallbackTool) AddFallback( tool core.Tool, condition func(error) bool, paramMapper func(map[string]interface{}) map[string]interface{}, ) *FallbackTool { ft.fallbackTools = append(ft.fallbackTools, FallbackConfig{ Tool: tool, Condition: condition, ParamMapper: paramMapper, }) return ft } func (ft *FallbackTool) Name() string { return ft.name } func (ft *FallbackTool) Description() string { return ft.description } func (ft *FallbackTool) ParameterSchema() map[string]core.ParameterDefinition { return ft.primaryTool.ParameterSchema() } func (ft *FallbackTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Try primary tool first result, err := ft.primaryTool.Execute(ctx, params) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: ft.primaryTool.Name(), &#34;fallback&#34;: false, }, nil } primaryError := err // Try fallback tools for i, fallback := range ft.fallbackTools { if fallback.Condition(err) { // Map parameters if needed fallbackParams := params if fallback.ParamMapper != nil { fallbackParams = fallback.ParamMapper(params) } result, err := fallback.Tool.Execute(ctx, fallbackParams) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: fallback.Tool.Name(), &#34;fallback&#34;: true, &#34;fallback_index&#34;: i, &#34;primary_error&#34;: primaryError.Error(), }, nil } } } return nil, fmt.Errorf(&#34;primary tool and all fallbacks failed, primary error: %w&#34;, primaryError) } // Example: Weather with Multiple Sources func CreateWeatherWithFallbacks() *FallbackTool { primaryWeather := tools.NewWeatherTool(os.Getenv(&#34;OPENWEATHER_API_KEY&#34;)) return NewFallbackTool(&#34;weather_with_fallbacks&#34;, &#34;Weather information with multiple sources&#34;, primaryWeather). AddFallback( tools.NewWeatherAPITool(os.Getenv(&#34;WEATHERAPI_KEY&#34;)), func(err error) bool { return strings.Contains(err.Error(), &#34;api key&#34;) || strings.Contains(err.Error(), &#34;rate limit&#34;) }, func(params map[string]interface{}) map[string]interface{} { // Convert location format if needed return params }, ). AddFallback( tools.NewMockWeatherTool(), // Returns mock data func(err error) bool { return true // Always try mock as last resort }, nil, ) }&#xD;Best Practices and Guidelines 1. Tool Design Principles Composability: Design tools that can be easily combined Idempotency: Ensure tools can be safely retried Observability: Include comprehensive monitoring and logging Graceful Degradation: Implement fallback mechanisms Configuration: Make tools configurable for different environments 2. Performance Optimization Caching: Cache expensive operations and API calls Parallel Execution: Use parallel execution where appropriate Connection Pooling: Reuse connections for external services Batch Operations: Combine multiple operations when possible Resource Management: Properly manage resources and connections 3. Error Handling Strategy Categorize Errors: Distinguish between retryable and non-retryable errors Circuit Breakers: Protect against cascading failures Fallback Mechanisms: Provide alternative execution paths Monitoring: Track error patterns and rates User Experience: Provide meaningful error messages Conclusion Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents’ capabilities while maintaining reliability and performance.</description>
    </item>
    <item>
      <title>tool-development</title>
      <link>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html</guid>
      <description>Tool Development in AgenticGoKit Overview Tools are the building blocks that extend agent capabilities beyond text generation. This tutorial covers how to develop custom tools in AgenticGoKit, from simple utilities to complex integrations with external services.&#xA;By creating custom tools, you can enable your agents to perform specific tasks, access specialized information, and interact with external systems in a controlled manner.&#xA;Prerequisites Understanding of MCP Overview Basic knowledge of Go interfaces and error handling Familiarity with State Management Tool Interface In AgenticGoKit, all tools implement the Tool interface:</description>
    </item>
    <item>
      <title>tool-integration</title>
      <link>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html</link>
      <pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html</guid>
      <description>Tool Integration in AgenticGoKit Overview Integrating tools with agents is a key capability in AgenticGoKit that enables agents to perform actions beyond text generation. This tutorial covers how to connect tools to agents, configure tool access, handle tool results, and implement tool-aware prompting.&#xA;Effective tool integration allows agents to interact with external systems, access specialized information, and perform complex tasks while maintaining a natural conversation flow.&#xA;Prerequisites Understanding of MCP Overview Familiarity with Tool Development Knowledge of Agent Lifecycle Basic understanding of State Management MCP Integration Architecture ┌─────────────┐ ┌───────────────┐ ┌─────────────┐&#xD;│ │ │ │ │ │&#xD;│ Agent │────▶│ MCP Manager │────▶│ Tool │&#xD;│ │ │ │ │ │&#xD;└─────────────┘ └───────────────┘ └─────────────┘&#xD;▲ │ │&#xD;│ ▼ ▼&#xD;│ ┌───────────────┐ ┌─────────────┐&#xD;└──────────────│ Tool Result │◀───│ External │&#xD;│ Processor │ │ Service │&#xD;└───────────────┘ └─────────────┘&#xD;Basic Tool Integration 1. Setting Up MCP Manager package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; &#34;github.com/kunalkushwaha/agenticgokit/tools&#34; ) func main() { // Create MCP manager mcpManager := core.NewMCPManager() // Register tools mcpManager.RegisterTool(&#34;calculator&#34;, tools.NewCalculatorTool()) mcpManager.RegisterTool(&#34;weather&#34;, tools.NewWeatherTool(os.Getenv(&#34;WEATHER_API_KEY&#34;))) mcpManager.RegisterTool(&#34;counter&#34;, tools.NewCounterTool()) // Create LLM provider llmProvider, err := core.NewOpenAIProvider( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-4&#34;, core.WithTemperature(0.2), core.WithMaxTokens(1000), ) if err != nil { log.Fatalf(&#34;Failed to create LLM provider: %v&#34;, err) } // Create agent with MCP capability agent, err := core.NewAgent(&#34;assistant&#34;). WithLLM(llmProvider). WithMCP(mcpManager). WithMCPConfig(core.MCPConfig{ Tools: []string{&#34;calculator&#34;, &#34;weather&#34;, &#34;counter&#34;}, MaxToolCalls: 5, ToolTimeout: 10 * time.Second, }). Build() if err != nil { log.Fatalf(&#34;Failed to create agent: %v&#34;, err) } // Create runner runner := core.NewRunner(100) runner.RegisterAgent(&#34;assistant&#34;, agent) // Start runner ctx := context.Background() runner.Start(ctx) defer runner.Stop() // Create event with user query event := core.NewEvent( &#34;assistant&#34;, core.EventData{&#34;message&#34;: &#34;What&#39;s 25 * 16 and what&#39;s the weather in New York?&#34;}, map[string]string{&#34;session_id&#34;: &#34;test-session&#34;}, ) // Register callback to handle agent response runner.RegisterCallback(core.HookAfterAgentRun, &#34;response-handler&#34;, func(ctx context.Context, args core.CallbackArgs) (core.State, error) { if response, ok := args.AgentResult.OutputState.Get(&#34;response&#34;); ok { fmt.Printf(&#34;Agent response: %s\n&#34;, response) } return args.State, nil }, ) // Emit event runner.Emit(event) // Wait for response time.Sleep(5 * time.Second) }&#xD;2. Tool-Aware Prompting func createToolAwareAgent() (core.AgentHandler, error) { // Create MCP manager mcpManager := core.NewMCPManager() // Register tools mcpManager.RegisterTool(&#34;calculator&#34;, tools.NewCalculatorTool()) mcpManager.RegisterTool(&#34;weather&#34;, tools.NewWeatherTool(os.Getenv(&#34;WEATHER_API_KEY&#34;))) // Create LLM provider llmProvider, err := core.NewOpenAIProvider( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-4&#34;, core.WithTemperature(0.2), core.WithMaxTokens(1000), ) if err != nil { return nil, fmt.Errorf(&#34;failed to create LLM provider: %w&#34;, err) } // Create tool-aware system prompt systemPrompt := `You are a helpful assistant with access to the following tools: 1. calculator: Performs basic arithmetic operations (add, subtract, multiply, divide) - Parameters: operation (string), a (number), b (number) 2. weather: Gets current weather information for a specified location - Parameters: location (string), units (string, optional) When you need to use a tool, use the following format: &lt;tool&gt;calculator&lt;/tool&gt; &lt;parameters&gt; { &#34;operation&#34;: &#34;add&#34;, &#34;a&#34;: 5, &#34;b&#34;: 3 } &lt;/parameters&gt; Wait for the tool result before continuing. Tool results will be provided in this format: &lt;tool_result&gt; { &#34;result&#34;: 8 } &lt;/tool_result&gt; Answer user questions directly when you can, and use tools when necessary.` // Create agent with MCP capability and tool-aware prompt return core.NewAgent(&#34;assistant&#34;). WithLLM(llmProvider). WithSystemPrompt(systemPrompt). WithMCP(mcpManager). WithMCPConfig(core.MCPConfig{ Tools: []string{&#34;calculator&#34;, &#34;weather&#34;}, MaxToolCalls: 5, ToolTimeout: 10 * time.Second, }). Build() }&#xD;3. Handling Tool Results func setupToolResultHandling(runner *core.Runner) { // Register callback for tool execution runner.RegisterCallback(core.HookBeforeToolExecution, &#34;tool-execution-logger&#34;, func(ctx context.Context, args core.CallbackArgs) (core.State, error) { toolName := args.ToolName toolParams := args.ToolParams fmt.Printf(&#34;Executing tool: %s with params: %v\n&#34;, toolName, toolParams) return args.State, nil }, ) // Register callback for tool result runner.RegisterCallback(core.HookAfterToolExecution, &#34;tool-result-logger&#34;, func(ctx context.Context, args core.CallbackArgs) (core.State, error) { toolName := args.ToolName toolResult := args.ToolResult toolError := args.Error if toolError != nil { fmt.Printf(&#34;Tool %s failed: %v\n&#34;, toolName, toolError) } else { fmt.Printf(&#34;Tool %s result: %v\n&#34;, toolName, toolResult) } return args.State, nil }, ) // Register callback for tool error runner.RegisterCallback(core.HookToolError, &#34;tool-error-handler&#34;, func(ctx context.Context, args core.CallbackArgs) (core.State, error) { toolName := args.ToolName toolError := args.Error fmt.Printf(&#34;Tool error: %s - %v\n&#34;, toolName, toolError) // Add error information to state newState := args.State.Clone() newState.Set(&#34;tool_error&#34;, fmt.Sprintf(&#34;The %s tool encountered an error: %v&#34;, toolName, toolError)) return newState, nil }, ) }&#xD;Advanced Tool Integration 1. Dynamic Tool Selection type DynamicToolSelector struct { tools map[string]core.Tool llmProvider core.LLMProvider } func NewDynamicToolSelector(llmProvider core.LLMProvider) *DynamicToolSelector { return &amp;DynamicToolSelector{ tools: make(map[string]core.Tool), llmProvider: llmProvider, } } func (dts *DynamicToolSelector) RegisterTool(name string, tool core.Tool) { dts.tools[name] = tool } func (dts *DynamicToolSelector) SelectTools(ctx context.Context, query string) ([]string, error) { // Create tool descriptions var toolDescriptions strings.Builder for name, tool := range dts.tools { toolDescriptions.WriteString(fmt.Sprintf(&#34;- %s: %s\n&#34;, name, tool.Description())) } // Create prompt for tool selection prompt := fmt.Sprintf(`Given the following user query and available tools, select the most appropriate tools to answer the query. User query: %s Available tools: %s Return only the names of the tools that should be used, separated by commas (e.g., &#34;calculator,weather&#34;). If no tools are needed, return &#34;none&#34;. Selected tools:`, query, toolDescriptions.String()) // Get tool selection from LLM response, err := dts.llmProvider.Generate(ctx, prompt) if err != nil { return nil, fmt.Errorf(&#34;tool selection failed: %w&#34;, err) } // Parse response response = strings.TrimSpace(response) if response == &#34;none&#34; { return []string{}, nil } // Split by comma and trim spaces selectedTools := strings.Split(response, &#34;,&#34;) for i := range selectedTools { selectedTools[i] = strings.TrimSpace(selectedTools[i]) } // Validate selected tools validTools := make([]string, 0, len(selectedTools)) for _, name := range selectedTools { if _, exists := dts.tools[name]; exists { validTools = append(validTools, name) } } return validTools, nil }&#xD;2. Tool Result Processing type ToolResultProcessor struct { llmProvider core.LLMProvider } func NewToolResultProcessor(llmProvider core.LLMProvider) *ToolResultProcessor { return &amp;ToolResultProcessor{ llmProvider: llmProvider, } } func (trp *ToolResultProcessor) ProcessResult(ctx context.Context, toolName string, result interface{}, query string) (string, error) { // Convert result to string representation resultStr := fmt.Sprintf(&#34;%v&#34;, result) if resultMap, ok := result.(map[string]interface{}); ok { resultBytes, err := json.MarshalIndent(resultMap, &#34;&#34;, &#34; &#34;) if err == nil { resultStr = string(resultBytes) } } // Create prompt for result processing prompt := fmt.Sprintf(`You are processing the result of a tool execution. Format the result in a clear, human-readable way that answers the user&#39;s query. User query: %s Tool used: %s Tool result: %s Provide a concise, helpful response based on this result:`, query, toolName, resultStr) // Get formatted response from LLM return trp.llmProvider.Generate(ctx, prompt) }&#xD;3. Tool Caching and Performance type CachedTool struct { tool core.Tool cache map[string]CacheEntry cacheTTL time.Duration mu sync.RWMutex } type CacheEntry struct { Result interface{} Timestamp time.Time } func NewCachedTool(tool core.Tool, cacheTTL time.Duration) *CachedTool { return &amp;CachedTool{ tool: tool, cache: make(map[string]CacheEntry), cacheTTL: cacheTTL, } } func (ct *CachedTool) Name() string { return ct.tool.Name() } func (ct *CachedTool) Description() string { return ct.tool.Description() } func (ct *CachedTool) ParameterSchema() map[string]core.ParameterDefinition { return ct.tool.ParameterSchema() } func (ct *CachedTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Create cache key from parameters cacheKey := ct.createCacheKey(params) // Check cache if result, found := ct.getCachedResult(cacheKey); found { return result, nil } // Execute tool result, err := ct.tool.Execute(ctx, params) if err != nil { return nil, err } // Cache result ct.setCachedResult(cacheKey, result) return result, nil } func (ct *CachedTool) createCacheKey(params map[string]interface{}) string { // Create deterministic key from parameters keys := make([]string, 0, len(params)) for k := range params { keys = append(keys, k) } sort.Strings(keys) var keyBuilder strings.Builder for _, k := range keys { keyBuilder.WriteString(fmt.Sprintf(&#34;%s:%v;&#34;, k, params[k])) } // Hash the key for consistent length hasher := sha256.New() hasher.Write([]byte(keyBuilder.String())) return fmt.Sprintf(&#34;%x&#34;, hasher.Sum(nil)) } func (ct *CachedTool) getCachedResult(key string) (interface{}, bool) { ct.mu.RLock() defer ct.mu.RUnlock() entry, exists := ct.cache[key] if !exists { return nil, false } // Check if entry is expired if time.Since(entry.Timestamp) &gt; ct.cacheTTL { return nil, false } return entry.Result, true } func (ct *CachedTool) setCachedResult(key string, result interface{}) { ct.mu.Lock() defer ct.mu.Unlock() ct.cache[key] = CacheEntry{ Result: result, Timestamp: time.Now(), } // Clean up expired entries periodically if len(ct.cache)%100 == 0 { go ct.cleanupExpiredEntries() } } func (ct *CachedTool) cleanupExpiredEntries() { ct.mu.Lock() defer ct.mu.Unlock() now := time.Now() for key, entry := range ct.cache { if now.Sub(entry.Timestamp) &gt; ct.cacheTTL { delete(ct.cache, key) } } }&#xD;Tool Configuration and Management 1. Tool Configuration type ToolConfig struct { Name string `json:&#34;name&#34;` Enabled bool `json:&#34;enabled&#34;` MaxCalls int `json:&#34;max_calls&#34;` Timeout time.Duration `json:&#34;timeout&#34;` RateLimit RateLimitConfig `json:&#34;rate_limit&#34;` Cache CacheConfig `json:&#34;cache&#34;` Parameters map[string]interface{} `json:&#34;parameters&#34;` } type RateLimitConfig struct { MaxRequests int `json:&#34;max_requests&#34;` Interval time.Duration `json:&#34;interval&#34;` } type CacheConfig struct { Enabled bool `json:&#34;enabled&#34;` TTL time.Duration `json:&#34;ttl&#34;` } type ToolManager struct { tools map[string]core.Tool configs map[string]ToolConfig mu sync.RWMutex } func NewToolManager() *ToolManager { return &amp;ToolManager{ tools: make(map[string]core.Tool), configs: make(map[string]ToolConfig), } } func (tm *ToolManager) RegisterTool(tool core.Tool, config ToolConfig) error { tm.mu.Lock() defer tm.mu.Unlock() name := tool.Name() // Apply configuration wrappers wrappedTool := tool // Add caching if enabled if config.Cache.Enabled { wrappedTool = NewCachedTool(wrappedTool, config.Cache.TTL) } // Add rate limiting if configured if config.RateLimit.MaxRequests &gt; 0 { wrappedTool = NewRateLimitedTool(wrappedTool, config.RateLimit.MaxRequests, config.RateLimit.Interval) } // Add validation wrappedTool = NewValidatedTool(wrappedTool, true) tm.tools[name] = wrappedTool tm.configs[name] = config return nil } func (tm *ToolManager) GetTool(name string) (core.Tool, error) { tm.mu.RLock() defer tm.mu.RUnlock() tool, exists := tm.tools[name] if !exists { return nil, fmt.Errorf(&#34;tool not found: %s&#34;, name) } config := tm.configs[name] if !config.Enabled { return nil, fmt.Errorf(&#34;tool disabled: %s&#34;, name) } return tool, nil } func (tm *ToolManager) ListEnabledTools() []string { tm.mu.RLock() defer tm.mu.RUnlock() var enabled []string for name, config := range tm.configs { if config.Enabled { enabled = append(enabled, name) } } return enabled }&#xD;2. Tool Discovery and Registration type ToolDiscovery struct { registry map[string]ToolFactory mu sync.RWMutex } type ToolFactory func(config map[string]interface{}) (core.Tool, error) func NewToolDiscovery() *ToolDiscovery { td := &amp;ToolDiscovery{ registry: make(map[string]ToolFactory), } // Register built-in tool factories td.RegisterFactory(&#34;calculator&#34;, func(config map[string]interface{}) (core.Tool, error) { return tools.NewCalculatorTool(), nil }) td.RegisterFactory(&#34;weather&#34;, func(config map[string]interface{}) (core.Tool, error) { apiKey, ok := config[&#34;api_key&#34;].(string) if !ok || apiKey == &#34;&#34; { return nil, fmt.Errorf(&#34;weather tool requires api_key parameter&#34;) } return tools.NewWeatherTool(apiKey), nil }) td.RegisterFactory(&#34;counter&#34;, func(config map[string]interface{}) (core.Tool, error) { return tools.NewCounterTool(), nil }) return td } func (td *ToolDiscovery) RegisterFactory(name string, factory ToolFactory) { td.mu.Lock() defer td.mu.Unlock() td.registry[name] = factory } func (td *ToolDiscovery) CreateTool(name string, config map[string]interface{}) (core.Tool, error) { td.mu.RLock() factory, exists := td.registry[name] td.mu.RUnlock() if !exists { return nil, fmt.Errorf(&#34;unknown tool type: %s&#34;, name) } return factory(config) } func (td *ToolDiscovery) ListAvailableTools() []string { td.mu.RLock() defer td.mu.RUnlock() tools := make([]string, 0, len(td.registry)) for name := range td.registry { tools = append(tools, name) } return tools }&#xD;Production Integration Patterns 1. Tool Health Monitoring type ToolHealthMonitor struct { tools map[string]core.Tool metrics map[string]*ToolMetrics mu sync.RWMutex } type ToolMetrics struct { TotalCalls int64 `json:&#34;total_calls&#34;` SuccessCalls int64 `json:&#34;success_calls&#34;` ErrorCalls int64 `json:&#34;error_calls&#34;` AverageTime time.Duration `json:&#34;average_time&#34;` LastError string `json:&#34;last_error&#34;` LastErrorTime time.Time `json:&#34;last_error_time&#34;` } func NewToolHealthMonitor() *ToolHealthMonitor { return &amp;ToolHealthMonitor{ tools: make(map[string]core.Tool), metrics: make(map[string]*ToolMetrics), } } func (thm *ToolHealthMonitor) WrapTool(tool core.Tool) core.Tool { thm.mu.Lock() defer thm.mu.Unlock() name := tool.Name() thm.tools[name] = tool thm.metrics[name] = &amp;ToolMetrics{} return &amp;MonitoredTool{ tool: tool, monitor: thm, } } type MonitoredTool struct { tool core.Tool monitor *ToolHealthMonitor } func (mt *MonitoredTool) Name() string { return mt.tool.Name() } func (mt *MonitoredTool) Description() string { return mt.tool.Description() } func (mt *MonitoredTool) ParameterSchema() map[string]core.ParameterDefinition { return mt.tool.ParameterSchema() } func (mt *MonitoredTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { start := time.Now() name := mt.tool.Name() // Execute tool result, err := mt.tool.Execute(ctx, params) // Record metrics duration := time.Since(start) mt.monitor.recordExecution(name, duration, err) return result, err } func (thm *ToolHealthMonitor) recordExecution(toolName string, duration time.Duration, err error) { thm.mu.Lock() defer thm.mu.Unlock() metrics := thm.metrics[toolName] metrics.TotalCalls++ if err != nil { metrics.ErrorCalls++ metrics.LastError = err.Error() metrics.LastErrorTime = time.Now() } else { metrics.SuccessCalls++ } // Update average time (simple moving average) if metrics.TotalCalls == 1 { metrics.AverageTime = duration } else { metrics.AverageTime = time.Duration( (int64(metrics.AverageTime)*metrics.TotalCalls + int64(duration)) / (metrics.TotalCalls + 1), ) } } func (thm *ToolHealthMonitor) GetMetrics(toolName string) (*ToolMetrics, error) { thm.mu.RLock() defer thm.mu.RUnlock() metrics, exists := thm.metrics[toolName] if !exists { return nil, fmt.Errorf(&#34;tool not found: %s&#34;, toolName) } // Return a copy to avoid race conditions return &amp;ToolMetrics{ TotalCalls: metrics.TotalCalls, SuccessCalls: metrics.SuccessCalls, ErrorCalls: metrics.ErrorCalls, AverageTime: metrics.AverageTime, LastError: metrics.LastError, LastErrorTime: metrics.LastErrorTime, }, nil } func (thm *ToolHealthMonitor) GetHealthStatus() map[string]string { thm.mu.RLock() defer thm.mu.RUnlock() status := make(map[string]string) for name, metrics := range thm.metrics { if metrics.TotalCalls == 0 { status[name] = &#34;unknown&#34; continue } errorRate := float64(metrics.ErrorCalls) / float64(metrics.TotalCalls) switch { case errorRate == 0: status[name] = &#34;healthy&#34; case errorRate &lt; 0.1: status[name] = &#34;warning&#34; default: status[name] = &#34;unhealthy&#34; } } return status }&#xD;2. Complete Integration Example package main import ( &#34;context&#34; &#34;encoding/json&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;time&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; &#34;github.com/kunalkushwaha/agenticgokit/tools&#34; ) func main() { // Create tool discovery and manager discovery := NewToolDiscovery() manager := NewToolManager() monitor := NewToolHealthMonitor() // Configure tools toolConfigs := []struct { name string config ToolConfig params map[string]interface{} }{ { name: &#34;calculator&#34;, config: ToolConfig{ Name: &#34;calculator&#34;, Enabled: true, MaxCalls: 100, Timeout: 5 * time.Second, Cache: CacheConfig{ Enabled: true, TTL: 1 * time.Hour, }, }, }, { name: &#34;weather&#34;, config: ToolConfig{ Name: &#34;weather&#34;, Enabled: true, MaxCalls: 50, Timeout: 10 * time.Second, RateLimit: RateLimitConfig{ MaxRequests: 10, Interval: 1 * time.Minute, }, Cache: CacheConfig{ Enabled: true, TTL: 15 * time.Minute, }, }, params: map[string]interface{}{ &#34;api_key&#34;: os.Getenv(&#34;WEATHER_API_KEY&#34;), }, }, } // Create and register tools for _, tc := range toolConfigs { tool, err := discovery.CreateTool(tc.name, tc.params) if err != nil { log.Fatalf(&#34;Failed to create tool %s: %v&#34;, tc.name, err) } // Wrap with monitoring monitoredTool := monitor.WrapTool(tool) // Register with manager if err := manager.RegisterTool(monitoredTool, tc.config); err != nil { log.Fatalf(&#34;Failed to register tool %s: %v&#34;, tc.name, err) } } // Create MCP manager and register tools mcpManager := core.NewMCPManager() for _, toolName := range manager.ListEnabledTools() { tool, err := manager.GetTool(toolName) if err != nil { log.Printf(&#34;Failed to get tool %s: %v&#34;, toolName, err) continue } mcpManager.RegisterTool(toolName, tool) } // Create LLM provider llmProvider, err := core.NewOpenAIProvider( os.Getenv(&#34;OPENAI_API_KEY&#34;), &#34;gpt-4&#34;, core.WithTemperature(0.2), core.WithMaxTokens(1000), ) if err != nil { log.Fatalf(&#34;Failed to create LLM provider: %v&#34;, err) } // Create agent agent, err := core.NewAgent(&#34;assistant&#34;). WithLLM(llmProvider). WithMCP(mcpManager). WithMCPConfig(core.MCPConfig{ Tools: manager.ListEnabledTools(), MaxToolCalls: 5, ToolTimeout: 10 * time.Second, }). Build() if err != nil { log.Fatalf(&#34;Failed to create agent: %v&#34;, err) } // Create runner with tool monitoring runner := core.NewRunner(100) runner.RegisterAgent(&#34;assistant&#34;, agent) // Setup tool result handling setupToolResultHandling(runner) // Start runner ctx := context.Background() runner.Start(ctx) defer runner.Stop() // Example interaction event := core.NewEvent( &#34;assistant&#34;, core.EventData{&#34;message&#34;: &#34;Calculate 15 * 23 and tell me the weather in London&#34;}, map[string]string{&#34;session_id&#34;: &#34;demo-session&#34;}, ) runner.Emit(event) // Wait and show metrics time.Sleep(10 * time.Second) // Display tool health metrics fmt.Println(&#34;\nTool Health Status:&#34;) healthStatus := monitor.GetHealthStatus() for tool, status := range healthStatus { fmt.Printf(&#34;- %s: %s\n&#34;, tool, status) if metrics, err := monitor.GetMetrics(tool); err == nil { fmt.Printf(&#34; Calls: %d (Success: %d, Errors: %d)\n&#34;, metrics.TotalCalls, metrics.SuccessCalls, metrics.ErrorCalls) fmt.Printf(&#34; Average Time: %v\n&#34;, metrics.AverageTime) if metrics.LastError != &#34;&#34; { fmt.Printf(&#34; Last Error: %s (%v)\n&#34;, metrics.LastError, metrics.LastErrorTime) } } } }&#xD;Best Practices 1. Tool Integration Guidelines Selective Tool Access: Only provide agents with tools they actually need Tool Validation: Always validate tool parameters and results Error Handling: Implement robust error handling and recovery Performance Monitoring: Monitor tool performance and health Security: Implement proper authentication and authorization Caching: Use caching for expensive or frequently called tools Rate Limiting: Protect external services with rate limiting 2. Prompting Best Practices Clear Tool Descriptions: Provide clear, concise tool descriptions Parameter Documentation: Document all parameters with examples Usage Examples: Include examples of when and how to use tools Error Guidance: Explain how to handle tool errors Tool Selection: Guide the agent on tool selection criteria 3. Production Considerations Monitoring: Implement comprehensive tool monitoring Logging: Log all tool executions for debugging Metrics: Track tool usage and performance metrics Health Checks: Implement tool health checking Fallbacks: Provide fallback mechanisms for tool failures Configuration: Make tool configuration externally manageable Troubleshooting Common Issues Tool Not Found: Ensure tools are properly registered with the MCP manager Parameter Validation Errors: Check parameter schemas and validation rules Timeout Errors: Adjust tool timeout settings for slow operations Rate Limit Exceeded: Configure appropriate rate limits for external services Authentication Failures: Verify API keys and authentication credentials Debugging Tips Enable detailed logging for tool executions Use tool health monitoring to identify problematic tools Test tools independently before integrating with agents Monitor tool performance metrics regularly Implement proper error handling and recovery mechanisms Conclusion Tool integration is a powerful feature that extends agent capabilities beyond text generation. By following the patterns and best practices in this tutorial, you can create robust, scalable tool integrations that enhance your agent systems.</description>
    </item>
  </channel>
</rss>