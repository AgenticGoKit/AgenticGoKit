<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head><script src="/AgenticGoKitDocs/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=AgenticGoKitDocs/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0+9803d5122ebb3276acea823f476e9eb44f607862">
    <meta name="description" content="Advanced Tool Patterns in AgenticGoKit Overview This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.
Prerequisites Understanding of MCP Overview Completion of Tool Development Familiarity with Tool Integration Knowledge of Orchestration Patterns Tool Composition Patterns 1. Sequential Tool Chains package patterns import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) // ToolChain executes tools in sequence, passing results between them type ToolChain struct { name string steps []ToolStep } type ToolStep struct { ToolName string ParamMapper func(previousResult interface{}, initialParams map[string]interface{}) map[string]interface{} } func NewToolChain(name string) *ToolChain { return &amp;ToolChain{ name: name, steps: make([]ToolStep, 0), } } func (tc *ToolChain) AddStep(toolName string, paramMapper func(interface{}, map[string]interface{}) map[string]interface{}) *ToolChain { tc.steps = append(tc.steps, ToolStep{ ToolName: toolName, ParamMapper: paramMapper, }) return tc } func (tc *ToolChain) Name() string { return tc.name } func (tc *ToolChain) Description() string { return fmt.Sprintf(&#34;Sequential tool chain with %d steps&#34;, len(tc.steps)) } func (tc *ToolChain) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;initial_params&#34;: { Type: &#34;object&#34;, Description: &#34;Initial parameters for the tool chain&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (tc *ToolChain) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { initialParams, ok := params[&#34;initial_params&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;initial_params must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } var currentResult interface{} = initialParams results := make([]interface{}, 0, len(tc.steps)) for i, step := range tc.steps { // Get tool tool, err := mcpManager.GetTool(step.ToolName) if err != nil { return nil, fmt.Errorf(&#34;step %d: failed to get tool %s: %w&#34;, i&#43;1, step.ToolName, err) } // Map parameters var toolParams map[string]interface{} if step.ParamMapper != nil { toolParams = step.ParamMapper(currentResult, initialParams) } else { toolParams = initialParams } // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;step %d: tool %s execution failed: %w&#34;, i&#43;1, step.ToolName, err) } currentResult = result results = append(results, result) } return map[string]interface{}{ &#34;final_result&#34;: currentResult, &#34;all_results&#34;: results, &#34;steps&#34;: len(tc.steps), }, nil } // Example: Research and Analysis Chain func CreateResearchChain() *ToolChain { return NewToolChain(&#34;research_analysis&#34;). AddStep(&#34;search&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { query, _ := initial[&#34;query&#34;].(string) return map[string]interface{}{ &#34;query&#34;: query, &#34;limit&#34;: 5, } }). AddStep(&#34;summarizer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { searchResults := prev.(map[string]interface{}) return map[string]interface{}{ &#34;content&#34;: searchResults[&#34;results&#34;], &#34;max_length&#34;: 500, } }). AddStep(&#34;analyzer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { summary := prev.(map[string]interface{}) return map[string]interface{}{ &#34;text&#34;: summary[&#34;summary&#34;], &#34;analysis_type&#34;: &#34;sentiment_and_topics&#34;, } }) } ```### 2. Parallel Tool Execution ```go // ParallelToolExecutor runs multiple tools concurrently type ParallelToolExecutor struct { name string tools []ParallelToolConfig aggregator ResultAggregator } type ParallelToolConfig struct { ToolName string Parameters map[string]interface{} Optional bool // If true, failure won&#39;t fail the entire execution } type ResultAggregator func(results map[string]interface{}, errors map[string]error) (interface{}, error) func NewParallelToolExecutor(name string, aggregator ResultAggregator) *ParallelToolExecutor { return &amp;ParallelToolExecutor{ name: name, tools: make([]ParallelToolConfig, 0), aggregator: aggregator, } } func (pte *ParallelToolExecutor) AddTool(toolName string, params map[string]interface{}, optional bool) *ParallelToolExecutor { pte.tools = append(pte.tools, ParallelToolConfig{ ToolName: toolName, Parameters: params, Optional: optional, }) return pte } func (pte *ParallelToolExecutor) Name() string { return pte.name } func (pte *ParallelToolExecutor) Description() string { return fmt.Sprintf(&#34;Parallel execution of %d tools&#34;, len(pte.tools)) } func (pte *ParallelToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, &#34;timeout&#34;: { Type: &#34;number&#34;, Description: &#34;Timeout in seconds for parallel execution&#34;, Required: false, Default: 30, }, } } func (pte *ParallelToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } timeout := 30 * time.Second if timeoutParam, ok := params[&#34;timeout&#34;].(float64); ok { timeout = time.Duration(timeoutParam) * time.Second } // Create context with timeout execCtx, cancel := context.WithTimeout(ctx, timeout) defer cancel() // Execute tools in parallel results := make(map[string]interface{}) errors := make(map[string]error) var wg sync.WaitGroup var mu sync.Mutex for _, toolConfig := range pte.tools { wg.Add(1) go func(config ParallelToolConfig) { defer wg.Done() tool, err := mcpManager.GetTool(config.ToolName) if err != nil { mu.Lock() errors[config.ToolName] = fmt.Errorf(&#34;failed to get tool: %w&#34;, err) mu.Unlock() return } result, err := tool.Execute(execCtx, config.Parameters) mu.Lock() if err != nil { errors[config.ToolName] = err } else { results[config.ToolName] = result } mu.Unlock() }(toolConfig) } wg.Wait() // Check for required tool failures for _, toolConfig := range pte.tools { if !toolConfig.Optional { if err, exists := errors[toolConfig.ToolName]; exists { return nil, fmt.Errorf(&#34;required tool %s failed: %w&#34;, toolConfig.ToolName, err) } } } // Aggregate results return pte.aggregator(results, errors) } // Example: Multi-Source Information Gathering func CreateInfoGatheringTool() *ParallelToolExecutor { return NewParallelToolExecutor(&#34;info_gathering&#34;, func(results map[string]interface{}, errors map[string]error) (interface{}, error) { gathered := map[string]interface{}{ &#34;sources&#34;: make(map[string]interface{}), &#34;errors&#34;: make(map[string]string), &#34;summary&#34;: &#34;&#34;, } // Collect successful results for toolName, result := range results { gathered[&#34;sources&#34;].(map[string]interface{})[toolName] = result } // Collect errors for optional tools for toolName, err := range errors { gathered[&#34;errors&#34;].(map[string]string)[toolName] = err.Error() } // Create summary sourceCount := len(results) errorCount := len(errors) gathered[&#34;summary&#34;] = fmt.Sprintf(&#34;Gathered information from %d sources with %d errors&#34;, sourceCount, errorCount) return gathered, nil }). AddTool(&#34;web_search&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, false). AddTool(&#34;weather&#34;, map[string]interface{}{&#34;location&#34;: &#34;current&#34;}, true). AddTool(&#34;stock_prices&#34;, map[string]interface{}{&#34;symbols&#34;: []string{&#34;AAPL&#34;, &#34;GOOGL&#34;}}, true). AddTool(&#34;calendar&#34;, map[string]interface{}{&#34;days&#34;: 7}, true) }Conditional Tool Execution 1. Rule-Based Tool Selection // ConditionalToolExecutor executes tools based on conditions type ConditionalToolExecutor struct { name string rules []ExecutionRule } type ExecutionRule struct { Condition func(context.Context, map[string]interface{}) bool ToolName string Parameters func(map[string]interface{}) map[string]interface{} Description string } func NewConditionalToolExecutor(name string) *ConditionalToolExecutor { return &amp;ConditionalToolExecutor{ name: name, rules: make([]ExecutionRule, 0), } } func (cte *ConditionalToolExecutor) AddRule( condition func(context.Context, map[string]interface{}) bool, toolName string, paramMapper func(map[string]interface{}) map[string]interface{}, description string, ) *ConditionalToolExecutor { cte.rules = append(cte.rules, ExecutionRule{ Condition: condition, ToolName: toolName, Parameters: paramMapper, Description: description, }) return cte } func (cte *ConditionalToolExecutor) Name() string { return cte.name } func (cte *ConditionalToolExecutor) Description() string { return fmt.Sprintf(&#34;Conditional tool executor with %d rules&#34;, len(cte.rules)) } func (cte *ConditionalToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;input_data&#34;: { Type: &#34;object&#34;, Description: &#34;Input data for condition evaluation&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (cte *ConditionalToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { inputData, ok := params[&#34;input_data&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;input_data must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } executedRules := make([]map[string]interface{}, 0) for i, rule := range cte.rules { if rule.Condition(ctx, inputData) { // Get tool tool, err := mcpManager.GetTool(rule.ToolName) if err != nil { return nil, fmt.Errorf(&#34;rule %d: failed to get tool %s: %w&#34;, i&#43;1, rule.ToolName, err) } // Prepare parameters toolParams := rule.Parameters(inputData) // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;rule %d: tool %s execution failed: %w&#34;, i&#43;1, rule.ToolName, err) } executedRules = append(executedRules, map[string]interface{}{ &#34;rule_description&#34;: rule.Description, &#34;tool_name&#34;: rule.ToolName, &#34;result&#34;: result, }) } } return map[string]interface{}{ &#34;executed_rules&#34;: executedRules, &#34;total_rules&#34;: len(cte.rules), &#34;matched_rules&#34;: len(executedRules), }, nil } // Example: Smart Assistant Tool Selection func CreateSmartAssistantTool() *ConditionalToolExecutor { return NewConditionalToolExecutor(&#34;smart_assistant&#34;). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;weather&#34;) }, &#34;weather&#34;, func(data map[string]interface{}) map[string]interface{} { location := &#34;current&#34; if loc, ok := data[&#34;location&#34;].(string); ok { location = loc } return map[string]interface{}{&#34;location&#34;: location} }, &#34;Weather information requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) if !ok { return false } mathKeywords := []string{&#34;calculate&#34;, &#34;math&#34;, &#34;&#43;&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;=&#34;} msgLower := strings.ToLower(message) for _, keyword := range mathKeywords { if strings.Contains(msgLower, keyword) { return true } } return false }, &#34;calculator&#34;, func(data map[string]interface{}) map[string]interface{} { // Simple math expression parser would go here return map[string]interface{}{ &#34;expression&#34;: data[&#34;message&#34;], } }, &#34;Mathematical calculation requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;search&#34;) }, &#34;web_search&#34;, func(data map[string]interface{}) map[string]interface{} { return map[string]interface{}{ &#34;query&#34;: data[&#34;message&#34;], &#34;limit&#34;: 5, } }, &#34;Web search requested&#34;, ) } ```## Error Handling and Recovery Patterns ### 1. Retry with Backoff ```go // RetryableTool wraps a tool with retry logic type RetryableTool struct { tool core.Tool maxRetries int baseDelay time.Duration maxDelay time.Duration backoffFunc func(attempt int, baseDelay time.Duration) time.Duration retryChecker func(error) bool } func NewRetryableTool(tool core.Tool, maxRetries int, baseDelay time.Duration) *RetryableTool { return &amp;RetryableTool{ tool: tool, maxRetries: maxRetries, baseDelay: baseDelay, maxDelay: 5 * time.Minute, backoffFunc: func(attempt int, baseDelay time.Duration) time.Duration { // Exponential backoff with jitter delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt))) jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) return delay &#43; jitter }, retryChecker: func(err error) bool { // Retry on network errors, timeouts, and rate limits errStr := strings.ToLower(err.Error()) return strings.Contains(errStr, &#34;timeout&#34;) || strings.Contains(errStr, &#34;network&#34;) || strings.Contains(errStr, &#34;rate limit&#34;) || strings.Contains(errStr, &#34;temporary&#34;) }, } } func (rt *RetryableTool) WithMaxDelay(maxDelay time.Duration) *RetryableTool { rt.maxDelay = maxDelay return rt } func (rt *RetryableTool) WithRetryChecker(checker func(error) bool) *RetryableTool { rt.retryChecker = checker return rt } func (rt *RetryableTool) Name() string { return rt.tool.Name() } func (rt *RetryableTool) Description() string { return rt.tool.Description() } func (rt *RetryableTool) ParameterSchema() map[string]core.ParameterDefinition { return rt.tool.ParameterSchema() } func (rt *RetryableTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { var lastErr error for attempt := 0; attempt &lt;= rt.maxRetries; attempt&#43;&#43; { result, err := rt.tool.Execute(ctx, params) if err == nil { return result, nil } lastErr = err // Check if we should retry if !rt.retryChecker(err) { return nil, fmt.Errorf(&#34;non-retryable error: %w&#34;, err) } // Don&#39;t wait after the last attempt if attempt == rt.maxRetries { break } // Calculate delay delay := rt.backoffFunc(attempt, rt.baseDelay) if delay &gt; rt.maxDelay { delay = rt.maxDelay } // Wait with context cancellation support select { case &lt;-ctx.Done(): return nil, ctx.Err() case &lt;-time.After(delay): // Continue to next attempt } } return nil, fmt.Errorf(&#34;max retries (%d) exceeded, last error: %w&#34;, rt.maxRetries, lastErr) }2. Circuit Breaker Pattern // CircuitBreakerTool implements circuit breaker pattern for tools type CircuitBreakerTool struct { tool core.Tool failureThreshold int resetTimeout time.Duration state CircuitState failures int lastFailureTime time.Time mu sync.RWMutex } type CircuitState int const ( CircuitClosed CircuitState = iota CircuitOpen CircuitHalfOpen ) func NewCircuitBreakerTool(tool core.Tool, failureThreshold int, resetTimeout time.Duration) *CircuitBreakerTool { return &amp;CircuitBreakerTool{ tool: tool, failureThreshold: failureThreshold, resetTimeout: resetTimeout, state: CircuitClosed, } } func (cbt *CircuitBreakerTool) Name() string { return cbt.tool.Name() } func (cbt *CircuitBreakerTool) Description() string { return cbt.tool.Description() } func (cbt *CircuitBreakerTool) ParameterSchema() map[string]core.ParameterDefinition { return cbt.tool.ParameterSchema() } func (cbt *CircuitBreakerTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { cbt.mu.Lock() // Check if circuit should be reset if cbt.state == CircuitOpen &amp;&amp; time.Since(cbt.lastFailureTime) &gt; cbt.resetTimeout { cbt.state = CircuitHalfOpen cbt.failures = 0 } // Fail fast if circuit is open if cbt.state == CircuitOpen { cbt.mu.Unlock() return nil, fmt.Errorf(&#34;circuit breaker is open for tool %s&#34;, cbt.tool.Name()) } cbt.mu.Unlock() // Execute tool result, err := cbt.tool.Execute(ctx, params) cbt.mu.Lock() defer cbt.mu.Unlock() if err != nil { cbt.failures&#43;&#43; cbt.lastFailureTime = time.Now() // Open circuit if threshold exceeded if cbt.failures &gt;= cbt.failureThreshold { cbt.state = CircuitOpen } return nil, err } // Success - reset circuit if it was half-open if cbt.state == CircuitHalfOpen { cbt.state = CircuitClosed cbt.failures = 0 } return result, nil } func (cbt *CircuitBreakerTool) GetState() (CircuitState, int, time.Time) { cbt.mu.RLock() defer cbt.mu.RUnlock() return cbt.state, cbt.failures, cbt.lastFailureTime }3. Fallback Tool Pattern // FallbackTool tries primary tool first, then fallbacks type FallbackTool struct { name string description string primaryTool core.Tool fallbackTools []FallbackConfig } type FallbackConfig struct { Tool core.Tool Condition func(error) bool ParamMapper func(map[string]interface{}) map[string]interface{} } func NewFallbackTool(name, description string, primaryTool core.Tool) *FallbackTool { return &amp;FallbackTool{ name: name, description: description, primaryTool: primaryTool, fallbackTools: make([]FallbackConfig, 0), } } func (ft *FallbackTool) AddFallback( tool core.Tool, condition func(error) bool, paramMapper func(map[string]interface{}) map[string]interface{}, ) *FallbackTool { ft.fallbackTools = append(ft.fallbackTools, FallbackConfig{ Tool: tool, Condition: condition, ParamMapper: paramMapper, }) return ft } func (ft *FallbackTool) Name() string { return ft.name } func (ft *FallbackTool) Description() string { return ft.description } func (ft *FallbackTool) ParameterSchema() map[string]core.ParameterDefinition { return ft.primaryTool.ParameterSchema() } func (ft *FallbackTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Try primary tool first result, err := ft.primaryTool.Execute(ctx, params) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: ft.primaryTool.Name(), &#34;fallback&#34;: false, }, nil } primaryError := err // Try fallback tools for i, fallback := range ft.fallbackTools { if fallback.Condition(err) { // Map parameters if needed fallbackParams := params if fallback.ParamMapper != nil { fallbackParams = fallback.ParamMapper(params) } result, err := fallback.Tool.Execute(ctx, fallbackParams) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: fallback.Tool.Name(), &#34;fallback&#34;: true, &#34;fallback_index&#34;: i, &#34;primary_error&#34;: primaryError.Error(), }, nil } } } return nil, fmt.Errorf(&#34;primary tool and all fallbacks failed, primary error: %w&#34;, primaryError) } // Example: Weather with Multiple Sources func CreateWeatherWithFallbacks() *FallbackTool { primaryWeather := tools.NewWeatherTool(os.Getenv(&#34;OPENWEATHER_API_KEY&#34;)) return NewFallbackTool(&#34;weather_with_fallbacks&#34;, &#34;Weather information with multiple sources&#34;, primaryWeather). AddFallback( tools.NewWeatherAPITool(os.Getenv(&#34;WEATHERAPI_KEY&#34;)), func(err error) bool { return strings.Contains(err.Error(), &#34;api key&#34;) || strings.Contains(err.Error(), &#34;rate limit&#34;) }, func(params map[string]interface{}) map[string]interface{} { // Convert location format if needed return params }, ). AddFallback( tools.NewMockWeatherTool(), // Returns mock data func(err error) bool { return true // Always try mock as last resort }, nil, ) }Best Practices and Guidelines 1. Tool Design Principles Composability: Design tools that can be easily combined Idempotency: Ensure tools can be safely retried Observability: Include comprehensive monitoring and logging Graceful Degradation: Implement fallback mechanisms Configuration: Make tools configurable for different environments 2. Performance Optimization Caching: Cache expensive operations and API calls Parallel Execution: Use parallel execution where appropriate Connection Pooling: Reuse connections for external services Batch Operations: Combine multiple operations when possible Resource Management: Properly manage resources and connections 3. Error Handling Strategy Categorize Errors: Distinguish between retryable and non-retryable errors Circuit Breakers: Protect against cascading failures Fallback Mechanisms: Provide alternative execution paths Monitoring: Track error patterns and rates User Experience: Provide meaningful error messages Conclusion Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents’ capabilities while maintaining reliability and performance.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="advanced-tool-patterns :: AgenticGoKit Docs">
    <meta name="twitter:description" content="Advanced Tool Patterns in AgenticGoKit Overview This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.
Prerequisites Understanding of MCP Overview Completion of Tool Development Familiarity with Tool Integration Knowledge of Orchestration Patterns Tool Composition Patterns 1. Sequential Tool Chains package patterns import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) // ToolChain executes tools in sequence, passing results between them type ToolChain struct { name string steps []ToolStep } type ToolStep struct { ToolName string ParamMapper func(previousResult interface{}, initialParams map[string]interface{}) map[string]interface{} } func NewToolChain(name string) *ToolChain { return &amp;ToolChain{ name: name, steps: make([]ToolStep, 0), } } func (tc *ToolChain) AddStep(toolName string, paramMapper func(interface{}, map[string]interface{}) map[string]interface{}) *ToolChain { tc.steps = append(tc.steps, ToolStep{ ToolName: toolName, ParamMapper: paramMapper, }) return tc } func (tc *ToolChain) Name() string { return tc.name } func (tc *ToolChain) Description() string { return fmt.Sprintf(&#34;Sequential tool chain with %d steps&#34;, len(tc.steps)) } func (tc *ToolChain) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;initial_params&#34;: { Type: &#34;object&#34;, Description: &#34;Initial parameters for the tool chain&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (tc *ToolChain) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { initialParams, ok := params[&#34;initial_params&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;initial_params must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } var currentResult interface{} = initialParams results := make([]interface{}, 0, len(tc.steps)) for i, step := range tc.steps { // Get tool tool, err := mcpManager.GetTool(step.ToolName) if err != nil { return nil, fmt.Errorf(&#34;step %d: failed to get tool %s: %w&#34;, i&#43;1, step.ToolName, err) } // Map parameters var toolParams map[string]interface{} if step.ParamMapper != nil { toolParams = step.ParamMapper(currentResult, initialParams) } else { toolParams = initialParams } // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;step %d: tool %s execution failed: %w&#34;, i&#43;1, step.ToolName, err) } currentResult = result results = append(results, result) } return map[string]interface{}{ &#34;final_result&#34;: currentResult, &#34;all_results&#34;: results, &#34;steps&#34;: len(tc.steps), }, nil } // Example: Research and Analysis Chain func CreateResearchChain() *ToolChain { return NewToolChain(&#34;research_analysis&#34;). AddStep(&#34;search&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { query, _ := initial[&#34;query&#34;].(string) return map[string]interface{}{ &#34;query&#34;: query, &#34;limit&#34;: 5, } }). AddStep(&#34;summarizer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { searchResults := prev.(map[string]interface{}) return map[string]interface{}{ &#34;content&#34;: searchResults[&#34;results&#34;], &#34;max_length&#34;: 500, } }). AddStep(&#34;analyzer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { summary := prev.(map[string]interface{}) return map[string]interface{}{ &#34;text&#34;: summary[&#34;summary&#34;], &#34;analysis_type&#34;: &#34;sentiment_and_topics&#34;, } }) } ```### 2. Parallel Tool Execution ```go // ParallelToolExecutor runs multiple tools concurrently type ParallelToolExecutor struct { name string tools []ParallelToolConfig aggregator ResultAggregator } type ParallelToolConfig struct { ToolName string Parameters map[string]interface{} Optional bool // If true, failure won&#39;t fail the entire execution } type ResultAggregator func(results map[string]interface{}, errors map[string]error) (interface{}, error) func NewParallelToolExecutor(name string, aggregator ResultAggregator) *ParallelToolExecutor { return &amp;ParallelToolExecutor{ name: name, tools: make([]ParallelToolConfig, 0), aggregator: aggregator, } } func (pte *ParallelToolExecutor) AddTool(toolName string, params map[string]interface{}, optional bool) *ParallelToolExecutor { pte.tools = append(pte.tools, ParallelToolConfig{ ToolName: toolName, Parameters: params, Optional: optional, }) return pte } func (pte *ParallelToolExecutor) Name() string { return pte.name } func (pte *ParallelToolExecutor) Description() string { return fmt.Sprintf(&#34;Parallel execution of %d tools&#34;, len(pte.tools)) } func (pte *ParallelToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, &#34;timeout&#34;: { Type: &#34;number&#34;, Description: &#34;Timeout in seconds for parallel execution&#34;, Required: false, Default: 30, }, } } func (pte *ParallelToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } timeout := 30 * time.Second if timeoutParam, ok := params[&#34;timeout&#34;].(float64); ok { timeout = time.Duration(timeoutParam) * time.Second } // Create context with timeout execCtx, cancel := context.WithTimeout(ctx, timeout) defer cancel() // Execute tools in parallel results := make(map[string]interface{}) errors := make(map[string]error) var wg sync.WaitGroup var mu sync.Mutex for _, toolConfig := range pte.tools { wg.Add(1) go func(config ParallelToolConfig) { defer wg.Done() tool, err := mcpManager.GetTool(config.ToolName) if err != nil { mu.Lock() errors[config.ToolName] = fmt.Errorf(&#34;failed to get tool: %w&#34;, err) mu.Unlock() return } result, err := tool.Execute(execCtx, config.Parameters) mu.Lock() if err != nil { errors[config.ToolName] = err } else { results[config.ToolName] = result } mu.Unlock() }(toolConfig) } wg.Wait() // Check for required tool failures for _, toolConfig := range pte.tools { if !toolConfig.Optional { if err, exists := errors[toolConfig.ToolName]; exists { return nil, fmt.Errorf(&#34;required tool %s failed: %w&#34;, toolConfig.ToolName, err) } } } // Aggregate results return pte.aggregator(results, errors) } // Example: Multi-Source Information Gathering func CreateInfoGatheringTool() *ParallelToolExecutor { return NewParallelToolExecutor(&#34;info_gathering&#34;, func(results map[string]interface{}, errors map[string]error) (interface{}, error) { gathered := map[string]interface{}{ &#34;sources&#34;: make(map[string]interface{}), &#34;errors&#34;: make(map[string]string), &#34;summary&#34;: &#34;&#34;, } // Collect successful results for toolName, result := range results { gathered[&#34;sources&#34;].(map[string]interface{})[toolName] = result } // Collect errors for optional tools for toolName, err := range errors { gathered[&#34;errors&#34;].(map[string]string)[toolName] = err.Error() } // Create summary sourceCount := len(results) errorCount := len(errors) gathered[&#34;summary&#34;] = fmt.Sprintf(&#34;Gathered information from %d sources with %d errors&#34;, sourceCount, errorCount) return gathered, nil }). AddTool(&#34;web_search&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, false). AddTool(&#34;weather&#34;, map[string]interface{}{&#34;location&#34;: &#34;current&#34;}, true). AddTool(&#34;stock_prices&#34;, map[string]interface{}{&#34;symbols&#34;: []string{&#34;AAPL&#34;, &#34;GOOGL&#34;}}, true). AddTool(&#34;calendar&#34;, map[string]interface{}{&#34;days&#34;: 7}, true) }Conditional Tool Execution 1. Rule-Based Tool Selection // ConditionalToolExecutor executes tools based on conditions type ConditionalToolExecutor struct { name string rules []ExecutionRule } type ExecutionRule struct { Condition func(context.Context, map[string]interface{}) bool ToolName string Parameters func(map[string]interface{}) map[string]interface{} Description string } func NewConditionalToolExecutor(name string) *ConditionalToolExecutor { return &amp;ConditionalToolExecutor{ name: name, rules: make([]ExecutionRule, 0), } } func (cte *ConditionalToolExecutor) AddRule( condition func(context.Context, map[string]interface{}) bool, toolName string, paramMapper func(map[string]interface{}) map[string]interface{}, description string, ) *ConditionalToolExecutor { cte.rules = append(cte.rules, ExecutionRule{ Condition: condition, ToolName: toolName, Parameters: paramMapper, Description: description, }) return cte } func (cte *ConditionalToolExecutor) Name() string { return cte.name } func (cte *ConditionalToolExecutor) Description() string { return fmt.Sprintf(&#34;Conditional tool executor with %d rules&#34;, len(cte.rules)) } func (cte *ConditionalToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;input_data&#34;: { Type: &#34;object&#34;, Description: &#34;Input data for condition evaluation&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (cte *ConditionalToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { inputData, ok := params[&#34;input_data&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;input_data must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } executedRules := make([]map[string]interface{}, 0) for i, rule := range cte.rules { if rule.Condition(ctx, inputData) { // Get tool tool, err := mcpManager.GetTool(rule.ToolName) if err != nil { return nil, fmt.Errorf(&#34;rule %d: failed to get tool %s: %w&#34;, i&#43;1, rule.ToolName, err) } // Prepare parameters toolParams := rule.Parameters(inputData) // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;rule %d: tool %s execution failed: %w&#34;, i&#43;1, rule.ToolName, err) } executedRules = append(executedRules, map[string]interface{}{ &#34;rule_description&#34;: rule.Description, &#34;tool_name&#34;: rule.ToolName, &#34;result&#34;: result, }) } } return map[string]interface{}{ &#34;executed_rules&#34;: executedRules, &#34;total_rules&#34;: len(cte.rules), &#34;matched_rules&#34;: len(executedRules), }, nil } // Example: Smart Assistant Tool Selection func CreateSmartAssistantTool() *ConditionalToolExecutor { return NewConditionalToolExecutor(&#34;smart_assistant&#34;). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;weather&#34;) }, &#34;weather&#34;, func(data map[string]interface{}) map[string]interface{} { location := &#34;current&#34; if loc, ok := data[&#34;location&#34;].(string); ok { location = loc } return map[string]interface{}{&#34;location&#34;: location} }, &#34;Weather information requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) if !ok { return false } mathKeywords := []string{&#34;calculate&#34;, &#34;math&#34;, &#34;&#43;&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;=&#34;} msgLower := strings.ToLower(message) for _, keyword := range mathKeywords { if strings.Contains(msgLower, keyword) { return true } } return false }, &#34;calculator&#34;, func(data map[string]interface{}) map[string]interface{} { // Simple math expression parser would go here return map[string]interface{}{ &#34;expression&#34;: data[&#34;message&#34;], } }, &#34;Mathematical calculation requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;search&#34;) }, &#34;web_search&#34;, func(data map[string]interface{}) map[string]interface{} { return map[string]interface{}{ &#34;query&#34;: data[&#34;message&#34;], &#34;limit&#34;: 5, } }, &#34;Web search requested&#34;, ) } ```## Error Handling and Recovery Patterns ### 1. Retry with Backoff ```go // RetryableTool wraps a tool with retry logic type RetryableTool struct { tool core.Tool maxRetries int baseDelay time.Duration maxDelay time.Duration backoffFunc func(attempt int, baseDelay time.Duration) time.Duration retryChecker func(error) bool } func NewRetryableTool(tool core.Tool, maxRetries int, baseDelay time.Duration) *RetryableTool { return &amp;RetryableTool{ tool: tool, maxRetries: maxRetries, baseDelay: baseDelay, maxDelay: 5 * time.Minute, backoffFunc: func(attempt int, baseDelay time.Duration) time.Duration { // Exponential backoff with jitter delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt))) jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) return delay &#43; jitter }, retryChecker: func(err error) bool { // Retry on network errors, timeouts, and rate limits errStr := strings.ToLower(err.Error()) return strings.Contains(errStr, &#34;timeout&#34;) || strings.Contains(errStr, &#34;network&#34;) || strings.Contains(errStr, &#34;rate limit&#34;) || strings.Contains(errStr, &#34;temporary&#34;) }, } } func (rt *RetryableTool) WithMaxDelay(maxDelay time.Duration) *RetryableTool { rt.maxDelay = maxDelay return rt } func (rt *RetryableTool) WithRetryChecker(checker func(error) bool) *RetryableTool { rt.retryChecker = checker return rt } func (rt *RetryableTool) Name() string { return rt.tool.Name() } func (rt *RetryableTool) Description() string { return rt.tool.Description() } func (rt *RetryableTool) ParameterSchema() map[string]core.ParameterDefinition { return rt.tool.ParameterSchema() } func (rt *RetryableTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { var lastErr error for attempt := 0; attempt &lt;= rt.maxRetries; attempt&#43;&#43; { result, err := rt.tool.Execute(ctx, params) if err == nil { return result, nil } lastErr = err // Check if we should retry if !rt.retryChecker(err) { return nil, fmt.Errorf(&#34;non-retryable error: %w&#34;, err) } // Don&#39;t wait after the last attempt if attempt == rt.maxRetries { break } // Calculate delay delay := rt.backoffFunc(attempt, rt.baseDelay) if delay &gt; rt.maxDelay { delay = rt.maxDelay } // Wait with context cancellation support select { case &lt;-ctx.Done(): return nil, ctx.Err() case &lt;-time.After(delay): // Continue to next attempt } } return nil, fmt.Errorf(&#34;max retries (%d) exceeded, last error: %w&#34;, rt.maxRetries, lastErr) }2. Circuit Breaker Pattern // CircuitBreakerTool implements circuit breaker pattern for tools type CircuitBreakerTool struct { tool core.Tool failureThreshold int resetTimeout time.Duration state CircuitState failures int lastFailureTime time.Time mu sync.RWMutex } type CircuitState int const ( CircuitClosed CircuitState = iota CircuitOpen CircuitHalfOpen ) func NewCircuitBreakerTool(tool core.Tool, failureThreshold int, resetTimeout time.Duration) *CircuitBreakerTool { return &amp;CircuitBreakerTool{ tool: tool, failureThreshold: failureThreshold, resetTimeout: resetTimeout, state: CircuitClosed, } } func (cbt *CircuitBreakerTool) Name() string { return cbt.tool.Name() } func (cbt *CircuitBreakerTool) Description() string { return cbt.tool.Description() } func (cbt *CircuitBreakerTool) ParameterSchema() map[string]core.ParameterDefinition { return cbt.tool.ParameterSchema() } func (cbt *CircuitBreakerTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { cbt.mu.Lock() // Check if circuit should be reset if cbt.state == CircuitOpen &amp;&amp; time.Since(cbt.lastFailureTime) &gt; cbt.resetTimeout { cbt.state = CircuitHalfOpen cbt.failures = 0 } // Fail fast if circuit is open if cbt.state == CircuitOpen { cbt.mu.Unlock() return nil, fmt.Errorf(&#34;circuit breaker is open for tool %s&#34;, cbt.tool.Name()) } cbt.mu.Unlock() // Execute tool result, err := cbt.tool.Execute(ctx, params) cbt.mu.Lock() defer cbt.mu.Unlock() if err != nil { cbt.failures&#43;&#43; cbt.lastFailureTime = time.Now() // Open circuit if threshold exceeded if cbt.failures &gt;= cbt.failureThreshold { cbt.state = CircuitOpen } return nil, err } // Success - reset circuit if it was half-open if cbt.state == CircuitHalfOpen { cbt.state = CircuitClosed cbt.failures = 0 } return result, nil } func (cbt *CircuitBreakerTool) GetState() (CircuitState, int, time.Time) { cbt.mu.RLock() defer cbt.mu.RUnlock() return cbt.state, cbt.failures, cbt.lastFailureTime }3. Fallback Tool Pattern // FallbackTool tries primary tool first, then fallbacks type FallbackTool struct { name string description string primaryTool core.Tool fallbackTools []FallbackConfig } type FallbackConfig struct { Tool core.Tool Condition func(error) bool ParamMapper func(map[string]interface{}) map[string]interface{} } func NewFallbackTool(name, description string, primaryTool core.Tool) *FallbackTool { return &amp;FallbackTool{ name: name, description: description, primaryTool: primaryTool, fallbackTools: make([]FallbackConfig, 0), } } func (ft *FallbackTool) AddFallback( tool core.Tool, condition func(error) bool, paramMapper func(map[string]interface{}) map[string]interface{}, ) *FallbackTool { ft.fallbackTools = append(ft.fallbackTools, FallbackConfig{ Tool: tool, Condition: condition, ParamMapper: paramMapper, }) return ft } func (ft *FallbackTool) Name() string { return ft.name } func (ft *FallbackTool) Description() string { return ft.description } func (ft *FallbackTool) ParameterSchema() map[string]core.ParameterDefinition { return ft.primaryTool.ParameterSchema() } func (ft *FallbackTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Try primary tool first result, err := ft.primaryTool.Execute(ctx, params) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: ft.primaryTool.Name(), &#34;fallback&#34;: false, }, nil } primaryError := err // Try fallback tools for i, fallback := range ft.fallbackTools { if fallback.Condition(err) { // Map parameters if needed fallbackParams := params if fallback.ParamMapper != nil { fallbackParams = fallback.ParamMapper(params) } result, err := fallback.Tool.Execute(ctx, fallbackParams) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: fallback.Tool.Name(), &#34;fallback&#34;: true, &#34;fallback_index&#34;: i, &#34;primary_error&#34;: primaryError.Error(), }, nil } } } return nil, fmt.Errorf(&#34;primary tool and all fallbacks failed, primary error: %w&#34;, primaryError) } // Example: Weather with Multiple Sources func CreateWeatherWithFallbacks() *FallbackTool { primaryWeather := tools.NewWeatherTool(os.Getenv(&#34;OPENWEATHER_API_KEY&#34;)) return NewFallbackTool(&#34;weather_with_fallbacks&#34;, &#34;Weather information with multiple sources&#34;, primaryWeather). AddFallback( tools.NewWeatherAPITool(os.Getenv(&#34;WEATHERAPI_KEY&#34;)), func(err error) bool { return strings.Contains(err.Error(), &#34;api key&#34;) || strings.Contains(err.Error(), &#34;rate limit&#34;) }, func(params map[string]interface{}) map[string]interface{} { // Convert location format if needed return params }, ). AddFallback( tools.NewMockWeatherTool(), // Returns mock data func(err error) bool { return true // Always try mock as last resort }, nil, ) }Best Practices and Guidelines 1. Tool Design Principles Composability: Design tools that can be easily combined Idempotency: Ensure tools can be safely retried Observability: Include comprehensive monitoring and logging Graceful Degradation: Implement fallback mechanisms Configuration: Make tools configurable for different environments 2. Performance Optimization Caching: Cache expensive operations and API calls Parallel Execution: Use parallel execution where appropriate Connection Pooling: Reuse connections for external services Batch Operations: Combine multiple operations when possible Resource Management: Properly manage resources and connections 3. Error Handling Strategy Categorize Errors: Distinguish between retryable and non-retryable errors Circuit Breakers: Protect against cascading failures Fallback Mechanisms: Provide alternative execution paths Monitoring: Track error patterns and rates User Experience: Provide meaningful error messages Conclusion Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents’ capabilities while maintaining reliability and performance.">
    <meta property="og:url" content="http://localhost:1313/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">
    <meta property="og:site_name" content="AgenticGoKit Docs">
    <meta property="og:title" content="advanced-tool-patterns :: AgenticGoKit Docs">
    <meta property="og:description" content="Advanced Tool Patterns in AgenticGoKit Overview This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.
Prerequisites Understanding of MCP Overview Completion of Tool Development Familiarity with Tool Integration Knowledge of Orchestration Patterns Tool Composition Patterns 1. Sequential Tool Chains package patterns import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) // ToolChain executes tools in sequence, passing results between them type ToolChain struct { name string steps []ToolStep } type ToolStep struct { ToolName string ParamMapper func(previousResult interface{}, initialParams map[string]interface{}) map[string]interface{} } func NewToolChain(name string) *ToolChain { return &amp;ToolChain{ name: name, steps: make([]ToolStep, 0), } } func (tc *ToolChain) AddStep(toolName string, paramMapper func(interface{}, map[string]interface{}) map[string]interface{}) *ToolChain { tc.steps = append(tc.steps, ToolStep{ ToolName: toolName, ParamMapper: paramMapper, }) return tc } func (tc *ToolChain) Name() string { return tc.name } func (tc *ToolChain) Description() string { return fmt.Sprintf(&#34;Sequential tool chain with %d steps&#34;, len(tc.steps)) } func (tc *ToolChain) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;initial_params&#34;: { Type: &#34;object&#34;, Description: &#34;Initial parameters for the tool chain&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (tc *ToolChain) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { initialParams, ok := params[&#34;initial_params&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;initial_params must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } var currentResult interface{} = initialParams results := make([]interface{}, 0, len(tc.steps)) for i, step := range tc.steps { // Get tool tool, err := mcpManager.GetTool(step.ToolName) if err != nil { return nil, fmt.Errorf(&#34;step %d: failed to get tool %s: %w&#34;, i&#43;1, step.ToolName, err) } // Map parameters var toolParams map[string]interface{} if step.ParamMapper != nil { toolParams = step.ParamMapper(currentResult, initialParams) } else { toolParams = initialParams } // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;step %d: tool %s execution failed: %w&#34;, i&#43;1, step.ToolName, err) } currentResult = result results = append(results, result) } return map[string]interface{}{ &#34;final_result&#34;: currentResult, &#34;all_results&#34;: results, &#34;steps&#34;: len(tc.steps), }, nil } // Example: Research and Analysis Chain func CreateResearchChain() *ToolChain { return NewToolChain(&#34;research_analysis&#34;). AddStep(&#34;search&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { query, _ := initial[&#34;query&#34;].(string) return map[string]interface{}{ &#34;query&#34;: query, &#34;limit&#34;: 5, } }). AddStep(&#34;summarizer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { searchResults := prev.(map[string]interface{}) return map[string]interface{}{ &#34;content&#34;: searchResults[&#34;results&#34;], &#34;max_length&#34;: 500, } }). AddStep(&#34;analyzer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { summary := prev.(map[string]interface{}) return map[string]interface{}{ &#34;text&#34;: summary[&#34;summary&#34;], &#34;analysis_type&#34;: &#34;sentiment_and_topics&#34;, } }) } ```### 2. Parallel Tool Execution ```go // ParallelToolExecutor runs multiple tools concurrently type ParallelToolExecutor struct { name string tools []ParallelToolConfig aggregator ResultAggregator } type ParallelToolConfig struct { ToolName string Parameters map[string]interface{} Optional bool // If true, failure won&#39;t fail the entire execution } type ResultAggregator func(results map[string]interface{}, errors map[string]error) (interface{}, error) func NewParallelToolExecutor(name string, aggregator ResultAggregator) *ParallelToolExecutor { return &amp;ParallelToolExecutor{ name: name, tools: make([]ParallelToolConfig, 0), aggregator: aggregator, } } func (pte *ParallelToolExecutor) AddTool(toolName string, params map[string]interface{}, optional bool) *ParallelToolExecutor { pte.tools = append(pte.tools, ParallelToolConfig{ ToolName: toolName, Parameters: params, Optional: optional, }) return pte } func (pte *ParallelToolExecutor) Name() string { return pte.name } func (pte *ParallelToolExecutor) Description() string { return fmt.Sprintf(&#34;Parallel execution of %d tools&#34;, len(pte.tools)) } func (pte *ParallelToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, &#34;timeout&#34;: { Type: &#34;number&#34;, Description: &#34;Timeout in seconds for parallel execution&#34;, Required: false, Default: 30, }, } } func (pte *ParallelToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } timeout := 30 * time.Second if timeoutParam, ok := params[&#34;timeout&#34;].(float64); ok { timeout = time.Duration(timeoutParam) * time.Second } // Create context with timeout execCtx, cancel := context.WithTimeout(ctx, timeout) defer cancel() // Execute tools in parallel results := make(map[string]interface{}) errors := make(map[string]error) var wg sync.WaitGroup var mu sync.Mutex for _, toolConfig := range pte.tools { wg.Add(1) go func(config ParallelToolConfig) { defer wg.Done() tool, err := mcpManager.GetTool(config.ToolName) if err != nil { mu.Lock() errors[config.ToolName] = fmt.Errorf(&#34;failed to get tool: %w&#34;, err) mu.Unlock() return } result, err := tool.Execute(execCtx, config.Parameters) mu.Lock() if err != nil { errors[config.ToolName] = err } else { results[config.ToolName] = result } mu.Unlock() }(toolConfig) } wg.Wait() // Check for required tool failures for _, toolConfig := range pte.tools { if !toolConfig.Optional { if err, exists := errors[toolConfig.ToolName]; exists { return nil, fmt.Errorf(&#34;required tool %s failed: %w&#34;, toolConfig.ToolName, err) } } } // Aggregate results return pte.aggregator(results, errors) } // Example: Multi-Source Information Gathering func CreateInfoGatheringTool() *ParallelToolExecutor { return NewParallelToolExecutor(&#34;info_gathering&#34;, func(results map[string]interface{}, errors map[string]error) (interface{}, error) { gathered := map[string]interface{}{ &#34;sources&#34;: make(map[string]interface{}), &#34;errors&#34;: make(map[string]string), &#34;summary&#34;: &#34;&#34;, } // Collect successful results for toolName, result := range results { gathered[&#34;sources&#34;].(map[string]interface{})[toolName] = result } // Collect errors for optional tools for toolName, err := range errors { gathered[&#34;errors&#34;].(map[string]string)[toolName] = err.Error() } // Create summary sourceCount := len(results) errorCount := len(errors) gathered[&#34;summary&#34;] = fmt.Sprintf(&#34;Gathered information from %d sources with %d errors&#34;, sourceCount, errorCount) return gathered, nil }). AddTool(&#34;web_search&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, false). AddTool(&#34;weather&#34;, map[string]interface{}{&#34;location&#34;: &#34;current&#34;}, true). AddTool(&#34;stock_prices&#34;, map[string]interface{}{&#34;symbols&#34;: []string{&#34;AAPL&#34;, &#34;GOOGL&#34;}}, true). AddTool(&#34;calendar&#34;, map[string]interface{}{&#34;days&#34;: 7}, true) }Conditional Tool Execution 1. Rule-Based Tool Selection // ConditionalToolExecutor executes tools based on conditions type ConditionalToolExecutor struct { name string rules []ExecutionRule } type ExecutionRule struct { Condition func(context.Context, map[string]interface{}) bool ToolName string Parameters func(map[string]interface{}) map[string]interface{} Description string } func NewConditionalToolExecutor(name string) *ConditionalToolExecutor { return &amp;ConditionalToolExecutor{ name: name, rules: make([]ExecutionRule, 0), } } func (cte *ConditionalToolExecutor) AddRule( condition func(context.Context, map[string]interface{}) bool, toolName string, paramMapper func(map[string]interface{}) map[string]interface{}, description string, ) *ConditionalToolExecutor { cte.rules = append(cte.rules, ExecutionRule{ Condition: condition, ToolName: toolName, Parameters: paramMapper, Description: description, }) return cte } func (cte *ConditionalToolExecutor) Name() string { return cte.name } func (cte *ConditionalToolExecutor) Description() string { return fmt.Sprintf(&#34;Conditional tool executor with %d rules&#34;, len(cte.rules)) } func (cte *ConditionalToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;input_data&#34;: { Type: &#34;object&#34;, Description: &#34;Input data for condition evaluation&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (cte *ConditionalToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { inputData, ok := params[&#34;input_data&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;input_data must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } executedRules := make([]map[string]interface{}, 0) for i, rule := range cte.rules { if rule.Condition(ctx, inputData) { // Get tool tool, err := mcpManager.GetTool(rule.ToolName) if err != nil { return nil, fmt.Errorf(&#34;rule %d: failed to get tool %s: %w&#34;, i&#43;1, rule.ToolName, err) } // Prepare parameters toolParams := rule.Parameters(inputData) // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;rule %d: tool %s execution failed: %w&#34;, i&#43;1, rule.ToolName, err) } executedRules = append(executedRules, map[string]interface{}{ &#34;rule_description&#34;: rule.Description, &#34;tool_name&#34;: rule.ToolName, &#34;result&#34;: result, }) } } return map[string]interface{}{ &#34;executed_rules&#34;: executedRules, &#34;total_rules&#34;: len(cte.rules), &#34;matched_rules&#34;: len(executedRules), }, nil } // Example: Smart Assistant Tool Selection func CreateSmartAssistantTool() *ConditionalToolExecutor { return NewConditionalToolExecutor(&#34;smart_assistant&#34;). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;weather&#34;) }, &#34;weather&#34;, func(data map[string]interface{}) map[string]interface{} { location := &#34;current&#34; if loc, ok := data[&#34;location&#34;].(string); ok { location = loc } return map[string]interface{}{&#34;location&#34;: location} }, &#34;Weather information requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) if !ok { return false } mathKeywords := []string{&#34;calculate&#34;, &#34;math&#34;, &#34;&#43;&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;=&#34;} msgLower := strings.ToLower(message) for _, keyword := range mathKeywords { if strings.Contains(msgLower, keyword) { return true } } return false }, &#34;calculator&#34;, func(data map[string]interface{}) map[string]interface{} { // Simple math expression parser would go here return map[string]interface{}{ &#34;expression&#34;: data[&#34;message&#34;], } }, &#34;Mathematical calculation requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;search&#34;) }, &#34;web_search&#34;, func(data map[string]interface{}) map[string]interface{} { return map[string]interface{}{ &#34;query&#34;: data[&#34;message&#34;], &#34;limit&#34;: 5, } }, &#34;Web search requested&#34;, ) } ```## Error Handling and Recovery Patterns ### 1. Retry with Backoff ```go // RetryableTool wraps a tool with retry logic type RetryableTool struct { tool core.Tool maxRetries int baseDelay time.Duration maxDelay time.Duration backoffFunc func(attempt int, baseDelay time.Duration) time.Duration retryChecker func(error) bool } func NewRetryableTool(tool core.Tool, maxRetries int, baseDelay time.Duration) *RetryableTool { return &amp;RetryableTool{ tool: tool, maxRetries: maxRetries, baseDelay: baseDelay, maxDelay: 5 * time.Minute, backoffFunc: func(attempt int, baseDelay time.Duration) time.Duration { // Exponential backoff with jitter delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt))) jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) return delay &#43; jitter }, retryChecker: func(err error) bool { // Retry on network errors, timeouts, and rate limits errStr := strings.ToLower(err.Error()) return strings.Contains(errStr, &#34;timeout&#34;) || strings.Contains(errStr, &#34;network&#34;) || strings.Contains(errStr, &#34;rate limit&#34;) || strings.Contains(errStr, &#34;temporary&#34;) }, } } func (rt *RetryableTool) WithMaxDelay(maxDelay time.Duration) *RetryableTool { rt.maxDelay = maxDelay return rt } func (rt *RetryableTool) WithRetryChecker(checker func(error) bool) *RetryableTool { rt.retryChecker = checker return rt } func (rt *RetryableTool) Name() string { return rt.tool.Name() } func (rt *RetryableTool) Description() string { return rt.tool.Description() } func (rt *RetryableTool) ParameterSchema() map[string]core.ParameterDefinition { return rt.tool.ParameterSchema() } func (rt *RetryableTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { var lastErr error for attempt := 0; attempt &lt;= rt.maxRetries; attempt&#43;&#43; { result, err := rt.tool.Execute(ctx, params) if err == nil { return result, nil } lastErr = err // Check if we should retry if !rt.retryChecker(err) { return nil, fmt.Errorf(&#34;non-retryable error: %w&#34;, err) } // Don&#39;t wait after the last attempt if attempt == rt.maxRetries { break } // Calculate delay delay := rt.backoffFunc(attempt, rt.baseDelay) if delay &gt; rt.maxDelay { delay = rt.maxDelay } // Wait with context cancellation support select { case &lt;-ctx.Done(): return nil, ctx.Err() case &lt;-time.After(delay): // Continue to next attempt } } return nil, fmt.Errorf(&#34;max retries (%d) exceeded, last error: %w&#34;, rt.maxRetries, lastErr) }2. Circuit Breaker Pattern // CircuitBreakerTool implements circuit breaker pattern for tools type CircuitBreakerTool struct { tool core.Tool failureThreshold int resetTimeout time.Duration state CircuitState failures int lastFailureTime time.Time mu sync.RWMutex } type CircuitState int const ( CircuitClosed CircuitState = iota CircuitOpen CircuitHalfOpen ) func NewCircuitBreakerTool(tool core.Tool, failureThreshold int, resetTimeout time.Duration) *CircuitBreakerTool { return &amp;CircuitBreakerTool{ tool: tool, failureThreshold: failureThreshold, resetTimeout: resetTimeout, state: CircuitClosed, } } func (cbt *CircuitBreakerTool) Name() string { return cbt.tool.Name() } func (cbt *CircuitBreakerTool) Description() string { return cbt.tool.Description() } func (cbt *CircuitBreakerTool) ParameterSchema() map[string]core.ParameterDefinition { return cbt.tool.ParameterSchema() } func (cbt *CircuitBreakerTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { cbt.mu.Lock() // Check if circuit should be reset if cbt.state == CircuitOpen &amp;&amp; time.Since(cbt.lastFailureTime) &gt; cbt.resetTimeout { cbt.state = CircuitHalfOpen cbt.failures = 0 } // Fail fast if circuit is open if cbt.state == CircuitOpen { cbt.mu.Unlock() return nil, fmt.Errorf(&#34;circuit breaker is open for tool %s&#34;, cbt.tool.Name()) } cbt.mu.Unlock() // Execute tool result, err := cbt.tool.Execute(ctx, params) cbt.mu.Lock() defer cbt.mu.Unlock() if err != nil { cbt.failures&#43;&#43; cbt.lastFailureTime = time.Now() // Open circuit if threshold exceeded if cbt.failures &gt;= cbt.failureThreshold { cbt.state = CircuitOpen } return nil, err } // Success - reset circuit if it was half-open if cbt.state == CircuitHalfOpen { cbt.state = CircuitClosed cbt.failures = 0 } return result, nil } func (cbt *CircuitBreakerTool) GetState() (CircuitState, int, time.Time) { cbt.mu.RLock() defer cbt.mu.RUnlock() return cbt.state, cbt.failures, cbt.lastFailureTime }3. Fallback Tool Pattern // FallbackTool tries primary tool first, then fallbacks type FallbackTool struct { name string description string primaryTool core.Tool fallbackTools []FallbackConfig } type FallbackConfig struct { Tool core.Tool Condition func(error) bool ParamMapper func(map[string]interface{}) map[string]interface{} } func NewFallbackTool(name, description string, primaryTool core.Tool) *FallbackTool { return &amp;FallbackTool{ name: name, description: description, primaryTool: primaryTool, fallbackTools: make([]FallbackConfig, 0), } } func (ft *FallbackTool) AddFallback( tool core.Tool, condition func(error) bool, paramMapper func(map[string]interface{}) map[string]interface{}, ) *FallbackTool { ft.fallbackTools = append(ft.fallbackTools, FallbackConfig{ Tool: tool, Condition: condition, ParamMapper: paramMapper, }) return ft } func (ft *FallbackTool) Name() string { return ft.name } func (ft *FallbackTool) Description() string { return ft.description } func (ft *FallbackTool) ParameterSchema() map[string]core.ParameterDefinition { return ft.primaryTool.ParameterSchema() } func (ft *FallbackTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Try primary tool first result, err := ft.primaryTool.Execute(ctx, params) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: ft.primaryTool.Name(), &#34;fallback&#34;: false, }, nil } primaryError := err // Try fallback tools for i, fallback := range ft.fallbackTools { if fallback.Condition(err) { // Map parameters if needed fallbackParams := params if fallback.ParamMapper != nil { fallbackParams = fallback.ParamMapper(params) } result, err := fallback.Tool.Execute(ctx, fallbackParams) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: fallback.Tool.Name(), &#34;fallback&#34;: true, &#34;fallback_index&#34;: i, &#34;primary_error&#34;: primaryError.Error(), }, nil } } } return nil, fmt.Errorf(&#34;primary tool and all fallbacks failed, primary error: %w&#34;, primaryError) } // Example: Weather with Multiple Sources func CreateWeatherWithFallbacks() *FallbackTool { primaryWeather := tools.NewWeatherTool(os.Getenv(&#34;OPENWEATHER_API_KEY&#34;)) return NewFallbackTool(&#34;weather_with_fallbacks&#34;, &#34;Weather information with multiple sources&#34;, primaryWeather). AddFallback( tools.NewWeatherAPITool(os.Getenv(&#34;WEATHERAPI_KEY&#34;)), func(err error) bool { return strings.Contains(err.Error(), &#34;api key&#34;) || strings.Contains(err.Error(), &#34;rate limit&#34;) }, func(params map[string]interface{}) map[string]interface{} { // Convert location format if needed return params }, ). AddFallback( tools.NewMockWeatherTool(), // Returns mock data func(err error) bool { return true // Always try mock as last resort }, nil, ) }Best Practices and Guidelines 1. Tool Design Principles Composability: Design tools that can be easily combined Idempotency: Ensure tools can be safely retried Observability: Include comprehensive monitoring and logging Graceful Degradation: Implement fallback mechanisms Configuration: Make tools configurable for different environments 2. Performance Optimization Caching: Cache expensive operations and API calls Parallel Execution: Use parallel execution where appropriate Connection Pooling: Reuse connections for external services Batch Operations: Combine multiple operations when possible Resource Management: Properly manage resources and connections 3. Error Handling Strategy Categorize Errors: Distinguish between retryable and non-retryable errors Circuit Breakers: Protect against cascading failures Fallback Mechanisms: Provide alternative execution paths Monitoring: Track error patterns and rates User Experience: Provide meaningful error messages Conclusion Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents’ capabilities while maintaining reliability and performance.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="tutorials">
    <meta property="article:published_time" content="2025-07-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="name" content="advanced-tool-patterns :: AgenticGoKit Docs">
    <meta itemprop="description" content="Advanced Tool Patterns in AgenticGoKit Overview This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.
Prerequisites Understanding of MCP Overview Completion of Tool Development Familiarity with Tool Integration Knowledge of Orchestration Patterns Tool Composition Patterns 1. Sequential Tool Chains package patterns import ( &#34;context&#34; &#34;fmt&#34; &#34;github.com/kunalkushwaha/agenticgokit/core&#34; ) // ToolChain executes tools in sequence, passing results between them type ToolChain struct { name string steps []ToolStep } type ToolStep struct { ToolName string ParamMapper func(previousResult interface{}, initialParams map[string]interface{}) map[string]interface{} } func NewToolChain(name string) *ToolChain { return &amp;ToolChain{ name: name, steps: make([]ToolStep, 0), } } func (tc *ToolChain) AddStep(toolName string, paramMapper func(interface{}, map[string]interface{}) map[string]interface{}) *ToolChain { tc.steps = append(tc.steps, ToolStep{ ToolName: toolName, ParamMapper: paramMapper, }) return tc } func (tc *ToolChain) Name() string { return tc.name } func (tc *ToolChain) Description() string { return fmt.Sprintf(&#34;Sequential tool chain with %d steps&#34;, len(tc.steps)) } func (tc *ToolChain) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;initial_params&#34;: { Type: &#34;object&#34;, Description: &#34;Initial parameters for the tool chain&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (tc *ToolChain) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { initialParams, ok := params[&#34;initial_params&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;initial_params must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } var currentResult interface{} = initialParams results := make([]interface{}, 0, len(tc.steps)) for i, step := range tc.steps { // Get tool tool, err := mcpManager.GetTool(step.ToolName) if err != nil { return nil, fmt.Errorf(&#34;step %d: failed to get tool %s: %w&#34;, i&#43;1, step.ToolName, err) } // Map parameters var toolParams map[string]interface{} if step.ParamMapper != nil { toolParams = step.ParamMapper(currentResult, initialParams) } else { toolParams = initialParams } // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;step %d: tool %s execution failed: %w&#34;, i&#43;1, step.ToolName, err) } currentResult = result results = append(results, result) } return map[string]interface{}{ &#34;final_result&#34;: currentResult, &#34;all_results&#34;: results, &#34;steps&#34;: len(tc.steps), }, nil } // Example: Research and Analysis Chain func CreateResearchChain() *ToolChain { return NewToolChain(&#34;research_analysis&#34;). AddStep(&#34;search&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { query, _ := initial[&#34;query&#34;].(string) return map[string]interface{}{ &#34;query&#34;: query, &#34;limit&#34;: 5, } }). AddStep(&#34;summarizer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { searchResults := prev.(map[string]interface{}) return map[string]interface{}{ &#34;content&#34;: searchResults[&#34;results&#34;], &#34;max_length&#34;: 500, } }). AddStep(&#34;analyzer&#34;, func(prev interface{}, initial map[string]interface{}) map[string]interface{} { summary := prev.(map[string]interface{}) return map[string]interface{}{ &#34;text&#34;: summary[&#34;summary&#34;], &#34;analysis_type&#34;: &#34;sentiment_and_topics&#34;, } }) } ```### 2. Parallel Tool Execution ```go // ParallelToolExecutor runs multiple tools concurrently type ParallelToolExecutor struct { name string tools []ParallelToolConfig aggregator ResultAggregator } type ParallelToolConfig struct { ToolName string Parameters map[string]interface{} Optional bool // If true, failure won&#39;t fail the entire execution } type ResultAggregator func(results map[string]interface{}, errors map[string]error) (interface{}, error) func NewParallelToolExecutor(name string, aggregator ResultAggregator) *ParallelToolExecutor { return &amp;ParallelToolExecutor{ name: name, tools: make([]ParallelToolConfig, 0), aggregator: aggregator, } } func (pte *ParallelToolExecutor) AddTool(toolName string, params map[string]interface{}, optional bool) *ParallelToolExecutor { pte.tools = append(pte.tools, ParallelToolConfig{ ToolName: toolName, Parameters: params, Optional: optional, }) return pte } func (pte *ParallelToolExecutor) Name() string { return pte.name } func (pte *ParallelToolExecutor) Description() string { return fmt.Sprintf(&#34;Parallel execution of %d tools&#34;, len(pte.tools)) } func (pte *ParallelToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, &#34;timeout&#34;: { Type: &#34;number&#34;, Description: &#34;Timeout in seconds for parallel execution&#34;, Required: false, Default: 30, }, } } func (pte *ParallelToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } timeout := 30 * time.Second if timeoutParam, ok := params[&#34;timeout&#34;].(float64); ok { timeout = time.Duration(timeoutParam) * time.Second } // Create context with timeout execCtx, cancel := context.WithTimeout(ctx, timeout) defer cancel() // Execute tools in parallel results := make(map[string]interface{}) errors := make(map[string]error) var wg sync.WaitGroup var mu sync.Mutex for _, toolConfig := range pte.tools { wg.Add(1) go func(config ParallelToolConfig) { defer wg.Done() tool, err := mcpManager.GetTool(config.ToolName) if err != nil { mu.Lock() errors[config.ToolName] = fmt.Errorf(&#34;failed to get tool: %w&#34;, err) mu.Unlock() return } result, err := tool.Execute(execCtx, config.Parameters) mu.Lock() if err != nil { errors[config.ToolName] = err } else { results[config.ToolName] = result } mu.Unlock() }(toolConfig) } wg.Wait() // Check for required tool failures for _, toolConfig := range pte.tools { if !toolConfig.Optional { if err, exists := errors[toolConfig.ToolName]; exists { return nil, fmt.Errorf(&#34;required tool %s failed: %w&#34;, toolConfig.ToolName, err) } } } // Aggregate results return pte.aggregator(results, errors) } // Example: Multi-Source Information Gathering func CreateInfoGatheringTool() *ParallelToolExecutor { return NewParallelToolExecutor(&#34;info_gathering&#34;, func(results map[string]interface{}, errors map[string]error) (interface{}, error) { gathered := map[string]interface{}{ &#34;sources&#34;: make(map[string]interface{}), &#34;errors&#34;: make(map[string]string), &#34;summary&#34;: &#34;&#34;, } // Collect successful results for toolName, result := range results { gathered[&#34;sources&#34;].(map[string]interface{})[toolName] = result } // Collect errors for optional tools for toolName, err := range errors { gathered[&#34;errors&#34;].(map[string]string)[toolName] = err.Error() } // Create summary sourceCount := len(results) errorCount := len(errors) gathered[&#34;summary&#34;] = fmt.Sprintf(&#34;Gathered information from %d sources with %d errors&#34;, sourceCount, errorCount) return gathered, nil }). AddTool(&#34;web_search&#34;, map[string]interface{}{&#34;query&#34;: &#34;latest news&#34;}, false). AddTool(&#34;weather&#34;, map[string]interface{}{&#34;location&#34;: &#34;current&#34;}, true). AddTool(&#34;stock_prices&#34;, map[string]interface{}{&#34;symbols&#34;: []string{&#34;AAPL&#34;, &#34;GOOGL&#34;}}, true). AddTool(&#34;calendar&#34;, map[string]interface{}{&#34;days&#34;: 7}, true) }Conditional Tool Execution 1. Rule-Based Tool Selection // ConditionalToolExecutor executes tools based on conditions type ConditionalToolExecutor struct { name string rules []ExecutionRule } type ExecutionRule struct { Condition func(context.Context, map[string]interface{}) bool ToolName string Parameters func(map[string]interface{}) map[string]interface{} Description string } func NewConditionalToolExecutor(name string) *ConditionalToolExecutor { return &amp;ConditionalToolExecutor{ name: name, rules: make([]ExecutionRule, 0), } } func (cte *ConditionalToolExecutor) AddRule( condition func(context.Context, map[string]interface{}) bool, toolName string, paramMapper func(map[string]interface{}) map[string]interface{}, description string, ) *ConditionalToolExecutor { cte.rules = append(cte.rules, ExecutionRule{ Condition: condition, ToolName: toolName, Parameters: paramMapper, Description: description, }) return cte } func (cte *ConditionalToolExecutor) Name() string { return cte.name } func (cte *ConditionalToolExecutor) Description() string { return fmt.Sprintf(&#34;Conditional tool executor with %d rules&#34;, len(cte.rules)) } func (cte *ConditionalToolExecutor) ParameterSchema() map[string]core.ParameterDefinition { return map[string]core.ParameterDefinition{ &#34;input_data&#34;: { Type: &#34;object&#34;, Description: &#34;Input data for condition evaluation&#34;, Required: true, }, &#34;mcp_manager&#34;: { Type: &#34;object&#34;, Description: &#34;MCP manager for tool execution&#34;, Required: true, }, } } func (cte *ConditionalToolExecutor) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { inputData, ok := params[&#34;input_data&#34;].(map[string]interface{}) if !ok { return nil, fmt.Errorf(&#34;input_data must be an object&#34;) } mcpManager, ok := params[&#34;mcp_manager&#34;].(*core.MCPManager) if !ok { return nil, fmt.Errorf(&#34;mcp_manager must be provided&#34;) } executedRules := make([]map[string]interface{}, 0) for i, rule := range cte.rules { if rule.Condition(ctx, inputData) { // Get tool tool, err := mcpManager.GetTool(rule.ToolName) if err != nil { return nil, fmt.Errorf(&#34;rule %d: failed to get tool %s: %w&#34;, i&#43;1, rule.ToolName, err) } // Prepare parameters toolParams := rule.Parameters(inputData) // Execute tool result, err := tool.Execute(ctx, toolParams) if err != nil { return nil, fmt.Errorf(&#34;rule %d: tool %s execution failed: %w&#34;, i&#43;1, rule.ToolName, err) } executedRules = append(executedRules, map[string]interface{}{ &#34;rule_description&#34;: rule.Description, &#34;tool_name&#34;: rule.ToolName, &#34;result&#34;: result, }) } } return map[string]interface{}{ &#34;executed_rules&#34;: executedRules, &#34;total_rules&#34;: len(cte.rules), &#34;matched_rules&#34;: len(executedRules), }, nil } // Example: Smart Assistant Tool Selection func CreateSmartAssistantTool() *ConditionalToolExecutor { return NewConditionalToolExecutor(&#34;smart_assistant&#34;). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;weather&#34;) }, &#34;weather&#34;, func(data map[string]interface{}) map[string]interface{} { location := &#34;current&#34; if loc, ok := data[&#34;location&#34;].(string); ok { location = loc } return map[string]interface{}{&#34;location&#34;: location} }, &#34;Weather information requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) if !ok { return false } mathKeywords := []string{&#34;calculate&#34;, &#34;math&#34;, &#34;&#43;&#34;, &#34;-&#34;, &#34;*&#34;, &#34;/&#34;, &#34;=&#34;} msgLower := strings.ToLower(message) for _, keyword := range mathKeywords { if strings.Contains(msgLower, keyword) { return true } } return false }, &#34;calculator&#34;, func(data map[string]interface{}) map[string]interface{} { // Simple math expression parser would go here return map[string]interface{}{ &#34;expression&#34;: data[&#34;message&#34;], } }, &#34;Mathematical calculation requested&#34;, ). AddRule( func(ctx context.Context, data map[string]interface{}) bool { message, ok := data[&#34;message&#34;].(string) return ok &amp;&amp; strings.Contains(strings.ToLower(message), &#34;search&#34;) }, &#34;web_search&#34;, func(data map[string]interface{}) map[string]interface{} { return map[string]interface{}{ &#34;query&#34;: data[&#34;message&#34;], &#34;limit&#34;: 5, } }, &#34;Web search requested&#34;, ) } ```## Error Handling and Recovery Patterns ### 1. Retry with Backoff ```go // RetryableTool wraps a tool with retry logic type RetryableTool struct { tool core.Tool maxRetries int baseDelay time.Duration maxDelay time.Duration backoffFunc func(attempt int, baseDelay time.Duration) time.Duration retryChecker func(error) bool } func NewRetryableTool(tool core.Tool, maxRetries int, baseDelay time.Duration) *RetryableTool { return &amp;RetryableTool{ tool: tool, maxRetries: maxRetries, baseDelay: baseDelay, maxDelay: 5 * time.Minute, backoffFunc: func(attempt int, baseDelay time.Duration) time.Duration { // Exponential backoff with jitter delay := time.Duration(float64(baseDelay) * math.Pow(2, float64(attempt))) jitter := time.Duration(rand.Float64() * float64(delay) * 0.1) return delay &#43; jitter }, retryChecker: func(err error) bool { // Retry on network errors, timeouts, and rate limits errStr := strings.ToLower(err.Error()) return strings.Contains(errStr, &#34;timeout&#34;) || strings.Contains(errStr, &#34;network&#34;) || strings.Contains(errStr, &#34;rate limit&#34;) || strings.Contains(errStr, &#34;temporary&#34;) }, } } func (rt *RetryableTool) WithMaxDelay(maxDelay time.Duration) *RetryableTool { rt.maxDelay = maxDelay return rt } func (rt *RetryableTool) WithRetryChecker(checker func(error) bool) *RetryableTool { rt.retryChecker = checker return rt } func (rt *RetryableTool) Name() string { return rt.tool.Name() } func (rt *RetryableTool) Description() string { return rt.tool.Description() } func (rt *RetryableTool) ParameterSchema() map[string]core.ParameterDefinition { return rt.tool.ParameterSchema() } func (rt *RetryableTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { var lastErr error for attempt := 0; attempt &lt;= rt.maxRetries; attempt&#43;&#43; { result, err := rt.tool.Execute(ctx, params) if err == nil { return result, nil } lastErr = err // Check if we should retry if !rt.retryChecker(err) { return nil, fmt.Errorf(&#34;non-retryable error: %w&#34;, err) } // Don&#39;t wait after the last attempt if attempt == rt.maxRetries { break } // Calculate delay delay := rt.backoffFunc(attempt, rt.baseDelay) if delay &gt; rt.maxDelay { delay = rt.maxDelay } // Wait with context cancellation support select { case &lt;-ctx.Done(): return nil, ctx.Err() case &lt;-time.After(delay): // Continue to next attempt } } return nil, fmt.Errorf(&#34;max retries (%d) exceeded, last error: %w&#34;, rt.maxRetries, lastErr) }2. Circuit Breaker Pattern // CircuitBreakerTool implements circuit breaker pattern for tools type CircuitBreakerTool struct { tool core.Tool failureThreshold int resetTimeout time.Duration state CircuitState failures int lastFailureTime time.Time mu sync.RWMutex } type CircuitState int const ( CircuitClosed CircuitState = iota CircuitOpen CircuitHalfOpen ) func NewCircuitBreakerTool(tool core.Tool, failureThreshold int, resetTimeout time.Duration) *CircuitBreakerTool { return &amp;CircuitBreakerTool{ tool: tool, failureThreshold: failureThreshold, resetTimeout: resetTimeout, state: CircuitClosed, } } func (cbt *CircuitBreakerTool) Name() string { return cbt.tool.Name() } func (cbt *CircuitBreakerTool) Description() string { return cbt.tool.Description() } func (cbt *CircuitBreakerTool) ParameterSchema() map[string]core.ParameterDefinition { return cbt.tool.ParameterSchema() } func (cbt *CircuitBreakerTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { cbt.mu.Lock() // Check if circuit should be reset if cbt.state == CircuitOpen &amp;&amp; time.Since(cbt.lastFailureTime) &gt; cbt.resetTimeout { cbt.state = CircuitHalfOpen cbt.failures = 0 } // Fail fast if circuit is open if cbt.state == CircuitOpen { cbt.mu.Unlock() return nil, fmt.Errorf(&#34;circuit breaker is open for tool %s&#34;, cbt.tool.Name()) } cbt.mu.Unlock() // Execute tool result, err := cbt.tool.Execute(ctx, params) cbt.mu.Lock() defer cbt.mu.Unlock() if err != nil { cbt.failures&#43;&#43; cbt.lastFailureTime = time.Now() // Open circuit if threshold exceeded if cbt.failures &gt;= cbt.failureThreshold { cbt.state = CircuitOpen } return nil, err } // Success - reset circuit if it was half-open if cbt.state == CircuitHalfOpen { cbt.state = CircuitClosed cbt.failures = 0 } return result, nil } func (cbt *CircuitBreakerTool) GetState() (CircuitState, int, time.Time) { cbt.mu.RLock() defer cbt.mu.RUnlock() return cbt.state, cbt.failures, cbt.lastFailureTime }3. Fallback Tool Pattern // FallbackTool tries primary tool first, then fallbacks type FallbackTool struct { name string description string primaryTool core.Tool fallbackTools []FallbackConfig } type FallbackConfig struct { Tool core.Tool Condition func(error) bool ParamMapper func(map[string]interface{}) map[string]interface{} } func NewFallbackTool(name, description string, primaryTool core.Tool) *FallbackTool { return &amp;FallbackTool{ name: name, description: description, primaryTool: primaryTool, fallbackTools: make([]FallbackConfig, 0), } } func (ft *FallbackTool) AddFallback( tool core.Tool, condition func(error) bool, paramMapper func(map[string]interface{}) map[string]interface{}, ) *FallbackTool { ft.fallbackTools = append(ft.fallbackTools, FallbackConfig{ Tool: tool, Condition: condition, ParamMapper: paramMapper, }) return ft } func (ft *FallbackTool) Name() string { return ft.name } func (ft *FallbackTool) Description() string { return ft.description } func (ft *FallbackTool) ParameterSchema() map[string]core.ParameterDefinition { return ft.primaryTool.ParameterSchema() } func (ft *FallbackTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) { // Try primary tool first result, err := ft.primaryTool.Execute(ctx, params) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: ft.primaryTool.Name(), &#34;fallback&#34;: false, }, nil } primaryError := err // Try fallback tools for i, fallback := range ft.fallbackTools { if fallback.Condition(err) { // Map parameters if needed fallbackParams := params if fallback.ParamMapper != nil { fallbackParams = fallback.ParamMapper(params) } result, err := fallback.Tool.Execute(ctx, fallbackParams) if err == nil { return map[string]interface{}{ &#34;result&#34;: result, &#34;tool_used&#34;: fallback.Tool.Name(), &#34;fallback&#34;: true, &#34;fallback_index&#34;: i, &#34;primary_error&#34;: primaryError.Error(), }, nil } } } return nil, fmt.Errorf(&#34;primary tool and all fallbacks failed, primary error: %w&#34;, primaryError) } // Example: Weather with Multiple Sources func CreateWeatherWithFallbacks() *FallbackTool { primaryWeather := tools.NewWeatherTool(os.Getenv(&#34;OPENWEATHER_API_KEY&#34;)) return NewFallbackTool(&#34;weather_with_fallbacks&#34;, &#34;Weather information with multiple sources&#34;, primaryWeather). AddFallback( tools.NewWeatherAPITool(os.Getenv(&#34;WEATHERAPI_KEY&#34;)), func(err error) bool { return strings.Contains(err.Error(), &#34;api key&#34;) || strings.Contains(err.Error(), &#34;rate limit&#34;) }, func(params map[string]interface{}) map[string]interface{} { // Convert location format if needed return params }, ). AddFallback( tools.NewMockWeatherTool(), // Returns mock data func(err error) bool { return true // Always try mock as last resort }, nil, ) }Best Practices and Guidelines 1. Tool Design Principles Composability: Design tools that can be easily combined Idempotency: Ensure tools can be safely retried Observability: Include comprehensive monitoring and logging Graceful Degradation: Implement fallback mechanisms Configuration: Make tools configurable for different environments 2. Performance Optimization Caching: Cache expensive operations and API calls Parallel Execution: Use parallel execution where appropriate Connection Pooling: Reuse connections for external services Batch Operations: Combine multiple operations when possible Resource Management: Properly manage resources and connections 3. Error Handling Strategy Categorize Errors: Distinguish between retryable and non-retryable errors Circuit Breakers: Protect against cascading failures Fallback Mechanisms: Provide alternative execution paths Monitoring: Track error patterns and rates User Experience: Provide meaningful error messages Conclusion Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents’ capabilities while maintaining reliability and performance.">
    <meta itemprop="datePublished" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="dateModified" content="2025-07-25T00:00:00+00:00">
    <meta itemprop="wordCount" content="2360">
    <title>advanced-tool-patterns :: AgenticGoKit Docs</title>
    <link href="/AgenticGoKitDocs/css/auto-complete/auto-complete.min.css?1753430931" rel="stylesheet">
    <script src="/AgenticGoKitDocs/js/auto-complete/auto-complete.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search-lunr.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/search.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/AgenticGoKitDocs/searchindex.en.js?1753430931";
    </script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.stemmer.support.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.multi.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/lunr/lunr.en.min.js?1753430931" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/AgenticGoKitDocs/fonts/fontawesome/css/fontawesome-all.min.css?1753430931" rel="stylesheet"></noscript>
    <link href="/AgenticGoKitDocs/css/perfect-scrollbar/perfect-scrollbar.min.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/theme.css?1753430931" rel="stylesheet">
    <link href="/AgenticGoKitDocs/css/format-html.css?1753430931" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/tutorials\/mcp\/advanced-tool-patterns\/index.html';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='http:\/\/localhost:1313\/AgenticGoKitDocs';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'blue' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
  </head>
  <body class="mobile-support html" data-url="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#prerequisites">Prerequisites</a></li>
    <li><a href="#tool-composition-patterns">Tool Composition Patterns</a>
      <ul>
        <li><a href="#1-sequential-tool-chains">1. Sequential Tool Chains</a></li>
      </ul>
    </li>
    <li><a href="#conditional-tool-execution">Conditional Tool Execution</a>
      <ul>
        <li><a href="#1-rule-based-tool-selection">1. Rule-Based Tool Selection</a></li>
        <li><a href="#2-circuit-breaker-pattern">2. Circuit Breaker Pattern</a></li>
        <li><a href="#3-fallback-tool-pattern">3. Fallback Tool Pattern</a></li>
      </ul>
    </li>
    <li><a href="#best-practices-and-guidelines">Best Practices and Guidelines</a>
      <ul>
        <li><a href="#1-tool-design-principles">1. Tool Design Principles</a></li>
        <li><a href="#2-performance-optimization">2. Performance Optimization</a></li>
        <li><a href="#3-error-handling-strategy">3. Error Handling Strategy</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#next-steps">Next Steps</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/index.html"><span itemprop="name">content</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/index.html"><span itemprop="name">tutorials</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/AgenticGoKitDocs/tutorials/mcp/index.html"><span itemprop="name">mcp</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">advanced-tool-patterns</span><meta itemprop="position" content="4"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html" title="mcp (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html" title="tool-development (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable tutorials" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="advanced-tool-patterns">advanced-tool-patterns</h1>

<h1 id="advanced-tool-patterns-in-agenticgokit">Advanced Tool Patterns in AgenticGoKit</h1>
<h2 id="overview">Overview</h2>
<p>This tutorial explores advanced patterns for tool usage in AgenticGoKit, including tool composition, conditional execution, parallel tool usage, and sophisticated error handling strategies. These patterns enable you to build complex, production-ready agent systems that can handle sophisticated workflows and edge cases.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Understanding of <a href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html">MCP Overview</a></li>
<li>Completion of <a href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">Tool Development</a></li>
<li>Familiarity with <a href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">Tool Integration</a></li>
<li>Knowledge of <a href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">Orchestration Patterns</a></li>
</ul>
<h2 id="tool-composition-patterns">Tool Composition Patterns</h2>
<h3 id="1-sequential-tool-chains">1. Sequential Tool Chains</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">patterns</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/kunalkushwaha/agenticgokit/core&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ToolChain executes tools in sequence, passing results between them</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ToolChain</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">steps</span> []<span style="color:#a6e22e">ToolStep</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ToolStep</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ToolName</span>    <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ParamMapper</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">previousResult</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">initialParams</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewToolChain</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ToolChain</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:  <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">steps</span>: make([]<span style="color:#a6e22e">ToolStep</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span>) <span style="color:#a6e22e">AddStep</span>(<span style="color:#a6e22e">toolName</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">paramMapper</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span> = append(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span>, <span style="color:#a6e22e">ToolStep</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ToolName</span>:    <span style="color:#a6e22e">toolName</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ParamMapper</span>: <span style="color:#a6e22e">paramMapper</span>,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">tc</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Sequential tool chain with %d steps&#34;</span>, len(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;initial_params&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;Initial parameters for the tool chain&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;mcp_manager&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;MCP manager for tool execution&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initialParams</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;initial_params&#34;</span>].(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;initial_params must be an object&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mcpManager</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;mcp_manager&#34;</span>].(<span style="color:#f92672">*</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MCPManager</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;mcp_manager must be provided&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">currentResult</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">initialParams</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">interface</span>{}, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">step</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get tool</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">tool</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mcpManager</span>.<span style="color:#a6e22e">GetTool</span>(<span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">ToolName</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;step %d: failed to get tool %s: %w&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">ToolName</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Map parameters</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">toolParams</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">ParamMapper</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">toolParams</span> = <span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">ParamMapper</span>(<span style="color:#a6e22e">currentResult</span>, <span style="color:#a6e22e">initialParams</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">toolParams</span> = <span style="color:#a6e22e">initialParams</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Execute tool</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">toolParams</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;step %d: tool %s execution failed: %w&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">ToolName</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentResult</span> = <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">results</span> = append(<span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;final_result&#34;</span>: <span style="color:#a6e22e">currentResult</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;all_results&#34;</span>:  <span style="color:#a6e22e">results</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;steps&#34;</span>:        len(<span style="color:#a6e22e">tc</span>.<span style="color:#a6e22e">steps</span>),
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Example: Research and Analysis Chain</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CreateResearchChain</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">ToolChain</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewToolChain</span>(<span style="color:#e6db74">&#34;research_analysis&#34;</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddStep</span>(<span style="color:#e6db74">&#34;search&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">prev</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">initial</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">query</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">initial</span>[<span style="color:#e6db74">&#34;query&#34;</span>].(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;query&#34;</span>: <span style="color:#a6e22e">query</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;limit&#34;</span>: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddStep</span>(<span style="color:#e6db74">&#34;summarizer&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">prev</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">initial</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">searchResults</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">prev</span>.(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;content&#34;</span>: <span style="color:#a6e22e">searchResults</span>[<span style="color:#e6db74">&#34;results&#34;</span>],
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;max_length&#34;</span>: <span style="color:#ae81ff">500</span>,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddStep</span>(<span style="color:#e6db74">&#34;analyzer&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">prev</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">initial</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">summary</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">prev</span>.(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#a6e22e">summary</span>[<span style="color:#e6db74">&#34;summary&#34;</span>],
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;analysis_type&#34;</span>: <span style="color:#e6db74">&#34;sentiment_and_topics&#34;</span>,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```### 2.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> Parallel Tool Execution
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span><span style="color:#66d9ef">go</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ParallelToolExecutor runs multiple tools concurrently</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ParallelToolExecutor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>        <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tools</span>       []<span style="color:#a6e22e">ParallelToolConfig</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">aggregator</span>  <span style="color:#a6e22e">ResultAggregator</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ParallelToolConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ToolName</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Parameters</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Optional</span>   <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// If true, failure won&#39;t fail the entire execution</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ResultAggregator</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">results</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">errors</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">error</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewParallelToolExecutor</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">aggregator</span> <span style="color:#a6e22e">ResultAggregator</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ParallelToolExecutor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:       <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">tools</span>:      make([]<span style="color:#a6e22e">ParallelToolConfig</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">aggregator</span>: <span style="color:#a6e22e">aggregator</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span>) <span style="color:#a6e22e">AddTool</span>(<span style="color:#a6e22e">toolName</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">tools</span> = append(<span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">tools</span>, <span style="color:#a6e22e">ParallelToolConfig</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ToolName</span>:   <span style="color:#a6e22e">toolName</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Parameters</span>: <span style="color:#a6e22e">params</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Optional</span>:   <span style="color:#a6e22e">optional</span>,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Parallel execution of %d tools&#34;</span>, len(<span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">tools</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;mcp_manager&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;MCP manager for tool execution&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;timeout&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;number&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;Timeout in seconds for parallel execution&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Default</span>:     <span style="color:#ae81ff">30</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">pte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mcpManager</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;mcp_manager&#34;</span>].(<span style="color:#f92672">*</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MCPManager</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;mcp_manager must be provided&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">timeout</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">timeoutParam</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;timeout&#34;</span>].(<span style="color:#66d9ef">float64</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">timeout</span> = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(<span style="color:#a6e22e">timeoutParam</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create context with timeout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">execCtx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">timeout</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Execute tools in parallel</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">errors</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">toolConfig</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">tools</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">config</span> <span style="color:#a6e22e">ParallelToolConfig</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tool</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mcpManager</span>.<span style="color:#a6e22e">GetTool</span>(<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ToolName</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">errors</span>[<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ToolName</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to get tool: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">execCtx</span>, <span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">Parameters</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">errors</span>[<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ToolName</span>] = <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">results</span>[<span style="color:#a6e22e">config</span>.<span style="color:#a6e22e">ToolName</span>] = <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        }(<span style="color:#a6e22e">toolConfig</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for required tool failures</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">toolConfig</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">tools</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">toolConfig</span>.<span style="color:#a6e22e">Optional</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>[<span style="color:#a6e22e">toolConfig</span>.<span style="color:#a6e22e">ToolName</span>]; <span style="color:#a6e22e">exists</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;required tool %s failed: %w&#34;</span>, <span style="color:#a6e22e">toolConfig</span>.<span style="color:#a6e22e">ToolName</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Aggregate results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pte</span>.<span style="color:#a6e22e">aggregator</span>(<span style="color:#a6e22e">results</span>, <span style="color:#a6e22e">errors</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Example: Multi-Source Information Gathering</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CreateInfoGatheringTool</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">ParallelToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewParallelToolExecutor</span>(<span style="color:#e6db74">&#34;info_gathering&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">results</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">errors</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">error</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">gathered</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;sources&#34;</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;errors&#34;</span>:  make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;summary&#34;</span>: <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Collect successful results</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">toolName</span>, <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">gathered</span>[<span style="color:#e6db74">&#34;sources&#34;</span>].(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})[<span style="color:#a6e22e">toolName</span>] = <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Collect errors for optional tools</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">toolName</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">errors</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">gathered</span>[<span style="color:#e6db74">&#34;errors&#34;</span>].(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>)[<span style="color:#a6e22e">toolName</span>] = <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Create summary</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sourceCount</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">errorCount</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">errors</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">gathered</span>[<span style="color:#e6db74">&#34;summary&#34;</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Gathered information from %d sources with %d errors&#34;</span>, <span style="color:#a6e22e">sourceCount</span>, <span style="color:#a6e22e">errorCount</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gathered</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }).
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AddTool</span>(<span style="color:#e6db74">&#34;web_search&#34;</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{<span style="color:#e6db74">&#34;query&#34;</span>: <span style="color:#e6db74">&#34;latest news&#34;</span>}, <span style="color:#66d9ef">false</span>).
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AddTool</span>(<span style="color:#e6db74">&#34;weather&#34;</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{<span style="color:#e6db74">&#34;location&#34;</span>: <span style="color:#e6db74">&#34;current&#34;</span>}, <span style="color:#66d9ef">true</span>).
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AddTool</span>(<span style="color:#e6db74">&#34;stock_prices&#34;</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{<span style="color:#e6db74">&#34;symbols&#34;</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;AAPL&#34;</span>, <span style="color:#e6db74">&#34;GOOGL&#34;</span>}}, <span style="color:#66d9ef">true</span>).
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">AddTool</span>(<span style="color:#e6db74">&#34;calendar&#34;</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{<span style="color:#e6db74">&#34;days&#34;</span>: <span style="color:#ae81ff">7</span>}, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="conditional-tool-execution">Conditional Tool Execution</h2>
<h3 id="1-rule-based-tool-selection">1. Rule-Based Tool Selection</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// ConditionalToolExecutor executes tools based on conditions</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ConditionalToolExecutor</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rules</span> []<span style="color:#a6e22e">ExecutionRule</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ExecutionRule</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Condition</span>   <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ToolName</span>    <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Parameters</span>  <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Description</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewConditionalToolExecutor</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ConditionalToolExecutor</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:  <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rules</span>: make([]<span style="color:#a6e22e">ExecutionRule</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span>) <span style="color:#a6e22e">AddRule</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">condition</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toolName</span> <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">paramMapper</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{},
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">description</span> <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">rules</span> = append(<span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">rules</span>, <span style="color:#a6e22e">ExecutionRule</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Condition</span>:   <span style="color:#a6e22e">condition</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ToolName</span>:    <span style="color:#a6e22e">toolName</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Parameters</span>:  <span style="color:#a6e22e">paramMapper</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Description</span>: <span style="color:#a6e22e">description</span>,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;Conditional tool executor with %d rules&#34;</span>, len(<span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">rules</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;input_data&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;Input data for condition evaluation&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;mcp_manager&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Type</span>:        <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Description</span>: <span style="color:#e6db74">&#34;MCP manager for tool execution&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Required</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cte</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inputData</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;input_data&#34;</span>].(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;input_data must be an object&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mcpManager</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>[<span style="color:#e6db74">&#34;mcp_manager&#34;</span>].(<span style="color:#f92672">*</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">MCPManager</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;mcp_manager must be provided&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">executedRules</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">rule</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">rules</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">Condition</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">inputData</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Get tool</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tool</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mcpManager</span>.<span style="color:#a6e22e">GetTool</span>(<span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">ToolName</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;rule %d: failed to get tool %s: %w&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">ToolName</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Prepare parameters</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">toolParams</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">Parameters</span>(<span style="color:#a6e22e">inputData</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Execute tool</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">toolParams</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;rule %d: tool %s execution failed: %w&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">ToolName</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">executedRules</span> = append(<span style="color:#a6e22e">executedRules</span>, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;rule_description&#34;</span>: <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">Description</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;tool_name&#34;</span>:        <span style="color:#a6e22e">rule</span>.<span style="color:#a6e22e">ToolName</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;result&#34;</span>:           <span style="color:#a6e22e">result</span>,
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;executed_rules&#34;</span>: <span style="color:#a6e22e">executedRules</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;total_rules&#34;</span>:    len(<span style="color:#a6e22e">cte</span>.<span style="color:#a6e22e">rules</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;matched_rules&#34;</span>:  len(<span style="color:#a6e22e">executedRules</span>),
</span></span><span style="display:flex;"><span>    }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Example: Smart Assistant Tool Selection</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CreateSmartAssistantTool</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">ConditionalToolExecutor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewConditionalToolExecutor</span>(<span style="color:#e6db74">&#34;smart_assistant&#34;</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddRule</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;message&#34;</span>].(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">message</span>), <span style="color:#e6db74">&#34;weather&#34;</span>)
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;weather&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">location</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;current&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">loc</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;location&#34;</span>].(<span style="color:#66d9ef">string</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">location</span> = <span style="color:#a6e22e">loc</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{<span style="color:#e6db74">&#34;location&#34;</span>: <span style="color:#a6e22e">location</span>}
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Weather information requested&#34;</span>,
</span></span><span style="display:flex;"><span>        ).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddRule</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;message&#34;</span>].(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">mathKeywords</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;calculate&#34;</span>, <span style="color:#e6db74">&#34;math&#34;</span>, <span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#e6db74">&#34;-&#34;</span>, <span style="color:#e6db74">&#34;*&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#e6db74">&#34;=&#34;</span>}
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">msgLower</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">message</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">keyword</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">mathKeywords</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">msgLower</span>, <span style="color:#a6e22e">keyword</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;calculator&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Simple math expression parser would go here</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;expression&#34;</span>: <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;message&#34;</span>],
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Mathematical calculation requested&#34;</span>,
</span></span><span style="display:flex;"><span>        ).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddRule</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;message&#34;</span>].(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">message</span>), <span style="color:#e6db74">&#34;search&#34;</span>)
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;web_search&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;query&#34;</span>: <span style="color:#a6e22e">data</span>[<span style="color:#e6db74">&#34;message&#34;</span>],
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;limit&#34;</span>: <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Web search requested&#34;</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```## 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Error Handling and Recovery Patterns
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">### 1. Retry with Backoff
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span><span style="color:#66d9ef">go</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// RetryableTool wraps a tool with retry logic</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RetryableTool</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tool</span>         <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxRetries</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">baseDelay</span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxDelay</span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">backoffFunc</span>  <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">attempt</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">baseDelay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">retryChecker</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewRetryableTool</span>(<span style="color:#a6e22e">tool</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>, <span style="color:#a6e22e">maxRetries</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">baseDelay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RetryableTool</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">tool</span>:       <span style="color:#a6e22e">tool</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxRetries</span>: <span style="color:#a6e22e">maxRetries</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">baseDelay</span>:  <span style="color:#a6e22e">baseDelay</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxDelay</span>:   <span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">backoffFunc</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">attempt</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">baseDelay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Exponential backoff with jitter</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">delay</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(float64(<span style="color:#a6e22e">baseDelay</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#ae81ff">2</span>, float64(<span style="color:#a6e22e">attempt</span>)))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">jitter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Float64</span>() <span style="color:#f92672">*</span> float64(<span style="color:#a6e22e">delay</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">delay</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">jitter</span>
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">retryChecker</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Retry on network errors, timeouts, and rate limits</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">errStr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">errStr</span>, <span style="color:#e6db74">&#34;timeout&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">errStr</span>, <span style="color:#e6db74">&#34;network&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">errStr</span>, <span style="color:#e6db74">&#34;rate limit&#34;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">errStr</span>, <span style="color:#e6db74">&#34;temporary&#34;</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">WithMaxDelay</span>(<span style="color:#a6e22e">maxDelay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxDelay</span> = <span style="color:#a6e22e">maxDelay</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rt</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">WithRetryChecker</span>(<span style="color:#a6e22e">checker</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">retryChecker</span> = <span style="color:#a6e22e">checker</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rt</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Name</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Description</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">ParameterSchema</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">rt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RetryableTool</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lastErr</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">attempt</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">attempt</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxRetries</span>; <span style="color:#a6e22e">attempt</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">params</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastErr</span> = <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if we should retry</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">retryChecker</span>(<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;non-retryable error: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Don&#39;t wait after the last attempt</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">attempt</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxRetries</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Calculate delay</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">delay</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">backoffFunc</span>(<span style="color:#a6e22e">attempt</span>, <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">baseDelay</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delay</span> &gt; <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxDelay</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">delay</span> = <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxDelay</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Wait with context cancellation support</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Err</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">delay</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Continue to next attempt</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;max retries (%d) exceeded, last error: %w&#34;</span>, <span style="color:#a6e22e">rt</span>.<span style="color:#a6e22e">maxRetries</span>, <span style="color:#a6e22e">lastErr</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="2-circuit-breaker-pattern">2. Circuit Breaker Pattern</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// CircuitBreakerTool implements circuit breaker pattern for tools</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CircuitBreakerTool</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tool</span>            <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">failureThreshold</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resetTimeout</span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">state</span>           <span style="color:#a6e22e">CircuitState</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">failures</span>        <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastFailureTime</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>              <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CircuitState</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CircuitClosed</span> <span style="color:#a6e22e">CircuitState</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CircuitOpen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CircuitHalfOpen</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewCircuitBreakerTool</span>(<span style="color:#a6e22e">tool</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>, <span style="color:#a6e22e">failureThreshold</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">resetTimeout</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">CircuitBreakerTool</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">tool</span>:             <span style="color:#a6e22e">tool</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">failureThreshold</span>: <span style="color:#a6e22e">failureThreshold</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resetTimeout</span>:     <span style="color:#a6e22e">resetTimeout</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">state</span>:            <span style="color:#a6e22e">CircuitClosed</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cbt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Name</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cbt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Description</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cbt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">ParameterSchema</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cbt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if circuit should be reset</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">CircuitOpen</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">lastFailureTime</span>) &gt; <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">resetTimeout</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">CircuitHalfOpen</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failures</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Fail fast if circuit is open</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">CircuitOpen</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;circuit breaker is open for tool %s&#34;</span>, <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Name</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Execute tool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">params</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failures</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">lastFailureTime</span> = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Open circuit if threshold exceeded</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failures</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failureThreshold</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">CircuitOpen</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Success - reset circuit if it was half-open</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">CircuitHalfOpen</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">CircuitClosed</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failures</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cbt</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">CircuitBreakerTool</span>) <span style="color:#a6e22e">GetState</span>() (<span style="color:#a6e22e">CircuitState</span>, <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">failures</span>, <span style="color:#a6e22e">cbt</span>.<span style="color:#a6e22e">lastFailureTime</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="3-fallback-tool-pattern">3. Fallback Tool Pattern</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// FallbackTool tries primary tool first, then fallbacks</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FallbackTool</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>         <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">description</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">primaryTool</span>  <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fallbackTools</span> []<span style="color:#a6e22e">FallbackConfig</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FallbackConfig</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tool</span>      <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Condition</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ParamMapper</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewFallbackTool</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">description</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">primaryTool</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">FallbackTool</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span>:          <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">description</span>:   <span style="color:#a6e22e">description</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">primaryTool</span>:   <span style="color:#a6e22e">primaryTool</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fallbackTools</span>: make([]<span style="color:#a6e22e">FallbackConfig</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ft</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span>) <span style="color:#a6e22e">AddFallback</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tool</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">Tool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">condition</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">paramMapper</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{},
</span></span><span style="display:flex;"><span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">fallbackTools</span> = append(<span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">fallbackTools</span>, <span style="color:#a6e22e">FallbackConfig</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Tool</span>:        <span style="color:#a6e22e">tool</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Condition</span>:   <span style="color:#a6e22e">condition</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ParamMapper</span>: <span style="color:#a6e22e">paramMapper</span>,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ft</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ft</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ft</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span>) <span style="color:#a6e22e">Description</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">description</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ft</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span>) <span style="color:#a6e22e">ParameterSchema</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ParameterDefinition</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">primaryTool</span>.<span style="color:#a6e22e">ParameterSchema</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ft</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span>) <span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Try primary tool first</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">primaryTool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">params</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;result&#34;</span>:    <span style="color:#a6e22e">result</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;tool_used&#34;</span>: <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">primaryTool</span>.<span style="color:#a6e22e">Name</span>(),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;fallback&#34;</span>:  <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>        }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">primaryError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Try fallback tools</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">fallback</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ft</span>.<span style="color:#a6e22e">fallbackTools</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fallback</span>.<span style="color:#a6e22e">Condition</span>(<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Map parameters if needed</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fallbackParams</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">params</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fallback</span>.<span style="color:#a6e22e">ParamMapper</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">fallbackParams</span> = <span style="color:#a6e22e">fallback</span>.<span style="color:#a6e22e">ParamMapper</span>(<span style="color:#a6e22e">params</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fallback</span>.<span style="color:#a6e22e">Tool</span>.<span style="color:#a6e22e">Execute</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">fallbackParams</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;result&#34;</span>:        <span style="color:#a6e22e">result</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;tool_used&#34;</span>:     <span style="color:#a6e22e">fallback</span>.<span style="color:#a6e22e">Tool</span>.<span style="color:#a6e22e">Name</span>(),
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;fallback&#34;</span>:      <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;fallback_index&#34;</span>: <span style="color:#a6e22e">i</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;primary_error&#34;</span>: <span style="color:#a6e22e">primaryError</span>.<span style="color:#a6e22e">Error</span>(),
</span></span><span style="display:flex;"><span>                }, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;primary tool and all fallbacks failed, primary error: %w&#34;</span>, <span style="color:#a6e22e">primaryError</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Example: Weather with Multiple Sources</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CreateWeatherWithFallbacks</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">FallbackTool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">primaryWeather</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tools</span>.<span style="color:#a6e22e">NewWeatherTool</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;OPENWEATHER_API_KEY&#34;</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewFallbackTool</span>(<span style="color:#e6db74">&#34;weather_with_fallbacks&#34;</span>, <span style="color:#e6db74">&#34;Weather information with multiple sources&#34;</span>, <span style="color:#a6e22e">primaryWeather</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddFallback</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tools</span>.<span style="color:#a6e22e">NewWeatherAPITool</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#e6db74">&#34;WEATHERAPI_KEY&#34;</span>)),
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;api key&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;rate limit&#34;</span>)
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">params</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Convert location format if needed</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">params</span>
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        ).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">AddFallback</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tools</span>.<span style="color:#a6e22e">NewMockWeatherTool</span>(), <span style="color:#75715e">// Returns mock data</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> <span style="color:#75715e">// Always try mock as last resort</span>
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">nil</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="best-practices-and-guidelines">Best Practices and Guidelines</h2>
<h3 id="1-tool-design-principles">1. Tool Design Principles</h3>
<ul>
<li><strong>Composability</strong>: Design tools that can be easily combined</li>
<li><strong>Idempotency</strong>: Ensure tools can be safely retried</li>
<li><strong>Observability</strong>: Include comprehensive monitoring and logging</li>
<li><strong>Graceful Degradation</strong>: Implement fallback mechanisms</li>
<li><strong>Configuration</strong>: Make tools configurable for different environments</li>
</ul>
<h3 id="2-performance-optimization">2. Performance Optimization</h3>
<ul>
<li><strong>Caching</strong>: Cache expensive operations and API calls</li>
<li><strong>Parallel Execution</strong>: Use parallel execution where appropriate</li>
<li><strong>Connection Pooling</strong>: Reuse connections for external services</li>
<li><strong>Batch Operations</strong>: Combine multiple operations when possible</li>
<li><strong>Resource Management</strong>: Properly manage resources and connections</li>
</ul>
<h3 id="3-error-handling-strategy">3. Error Handling Strategy</h3>
<ul>
<li><strong>Categorize Errors</strong>: Distinguish between retryable and non-retryable errors</li>
<li><strong>Circuit Breakers</strong>: Protect against cascading failures</li>
<li><strong>Fallback Mechanisms</strong>: Provide alternative execution paths</li>
<li><strong>Monitoring</strong>: Track error patterns and rates</li>
<li><strong>User Experience</strong>: Provide meaningful error messages</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Advanced tool patterns enable you to build sophisticated, production-ready agent systems that can handle complex workflows, recover from failures, and scale effectively. By combining these patterns, you can create robust tool ecosystems that enhance your agents&rsquo; capabilities while maintaining reliability and performance.</p>
<p>Key takeaways:</p>
<ul>
<li>Use composition patterns for complex workflows</li>
<li>Implement proper error handling and recovery mechanisms</li>
<li>Monitor tool performance and health comprehensively</li>
<li>Design for scalability and maintainability</li>
<li>Follow production deployment best practices</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">Tool Development</a> - Learn the basics of tool creation</li>
<li><a href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">Tool Integration</a> - Understand tool integration patterns</li>
<li><a href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">Orchestration Patterns</a> - Explore agent orchestration</li>
<li><a href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">Production Deployment</a> - Deploy your systems</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="../../api/core.md#mcp">API Reference: MCP</a></li>
<li><a href="../../examples/">Examples: Advanced Patterns</a></li>
<li><a href="/AgenticGoKitDocs/contributors/readme/index.html">Monitoring and Observability</a></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Jul 25, 2025
  </footer>
</article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          <a id="R-logo" class="R-default" href="/AgenticGoKitDocs/index.html">
            <div class="logo-title">AgenticGoKit Docs</div>
          </a>
        </div>
        <search><form action="/AgenticGoKitDocs/search/index.html" method="get">
          <div class="searchbox default-animation">
            <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
            <label class="a11y-only" for="R-search-by">Search</label>
            <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
            <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
          </div>
        </form></search>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-homelinks">
          <ul class="space collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/index.html"><a class="padding" href="/AgenticGoKitDocs/index.html"><i class="fa-fw fas fa-home"></i> Home</a></li>
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-headercontrols">
          <ul class="">
          </ul>
        </div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div class="R-sidebarmenu R-shortcutmenu-main">
          <ul class="enlarge morespace collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/readme/index.html">content</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/index.html"><input type="checkbox" id="R-section-8fc2fd7736125e87cab8840a86c2af5a" aria-controls="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" checked><label for="R-section-8fc2fd7736125e87cab8840a86c2af5a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu guides</span></label><a class="padding" href="/AgenticGoKitDocs/guides/index.html">guides</a><ul id="R-subsections-8fc2fd7736125e87cab8840a86c2af5a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/readme/index.html">guides</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/agentbasics/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/agentbasics/index.html">AgentBasics</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/examples/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/examples/index.html">Examples</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/configuration/index.html">Configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/customtools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/customtools/index.html">CustomTools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/providers/index.html">Providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memoryprovidersetup/index.html">MemoryProviderSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memorytroubleshooting/index.html">MemoryTroubleshooting</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/embeddingmodelguide/index.html">EmbeddingModelGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/ragconfiguration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/ragconfiguration/index.html">RAGConfiguration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/toolintegration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/toolintegration/index.html">ToolIntegration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/pgvectorsetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/pgvectorsetup/index.html">PgVectorSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/weaviatesetup/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/weaviatesetup/index.html">WeaviateSetup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/performance/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/performance/index.html">Performance</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/errorhandling/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/errorhandling/index.html">ErrorHandling</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/deployment/index.html"><input type="checkbox" id="R-section-ecc839349395ef3c015a12132049dff2" aria-controls="R-subsections-ecc839349395ef3c015a12132049dff2" checked><label for="R-section-ecc839349395ef3c015a12132049dff2"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu deployment</span></label><a class="padding" href="/AgenticGoKitDocs/guides/deployment/index.html">deployment</a><ul id="R-subsections-ecc839349395ef3c015a12132049dff2" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/deployment/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/deployment/readme/index.html">deployment</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/development/index.html"><input type="checkbox" id="R-section-fff1f5eca5d0a93209b9c6262762c25a" aria-controls="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" checked><label for="R-section-fff1f5eca5d0a93209b9c6262762c25a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu development</span></label><a class="padding" href="/AgenticGoKitDocs/guides/development/index.html">development</a><ul id="R-subsections-fff1f5eca5d0a93209b9c6262762c25a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/readme/index.html">development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/best-practices/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/best-practices/index.html">best-practices</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/debugging/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/debugging/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/research-assistant/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/research-assistant/index.html">research-assistant</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/testing-agents/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/testing-agents/index.html">testing-agents</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/visualization/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/visualization/index.html">visualization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/development/web-search-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/development/web-search-integration/index.html">web-search-integration</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/framework-comparison/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/framework-comparison/index.html">framework-comparison</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/memory/index.html">Memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/scaffoldmemoryguide/index.html">ScaffoldMemoryGuide</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/guides/setup/index.html"><input type="checkbox" id="R-section-0124aed9abb5064d53391168f3c95c22" aria-controls="R-subsections-0124aed9abb5064d53391168f3c95c22" checked><label for="R-section-0124aed9abb5064d53391168f3c95c22"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu setup</span></label><a class="padding" href="/AgenticGoKitDocs/guides/setup/index.html">setup</a><ul id="R-subsections-0124aed9abb5064d53391168f3c95c22" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/readme/index.html">setup</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/llm-providers/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/llm-providers/index.html">llm-providers</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/mcp-tools/index.html">mcp-tools</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/orchestration-configuration/index.html">orchestration-configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/setup/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/setup/vector-databases/index.html">vector-databases</a></li></ul></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/guides/troubleshooting/index.html"><a class="padding" href="/AgenticGoKitDocs/guides/troubleshooting/index.html">troubleshooting</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/contributors/index.html"><input type="checkbox" id="R-section-190d9b328fbda7e13ab386f7a5417de5" aria-controls="R-subsections-190d9b328fbda7e13ab386f7a5417de5" checked><label for="R-section-190d9b328fbda7e13ab386f7a5417de5"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu contributors</span></label><a class="padding" href="/AgenticGoKitDocs/contributors/index.html">contributors</a><ul id="R-subsections-190d9b328fbda7e13ab386f7a5417de5" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/readme/index.html">contributors</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/contributorguide/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/contributorguide/index.html">ContributorGuide</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/codestyle/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/codestyle/index.html">CodeStyle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/corevsinternal/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/corevsinternal/index.html">CoreVsInternal</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/addingfeatures/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/addingfeatures/index.html">AddingFeatures</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/testing/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/testing/index.html">Testing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/contributors/docsstandards/index.html"><a class="padding" href="/AgenticGoKitDocs/contributors/docsstandards/index.html">DocsStandards</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/reference/index.html"><input type="checkbox" id="R-section-66002f201bef818664bb81aa67490c58" aria-controls="R-subsections-66002f201bef818664bb81aa67490c58" checked><label for="R-section-66002f201bef818664bb81aa67490c58"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu reference</span></label><a class="padding" href="/AgenticGoKitDocs/reference/index.html">reference</a><ul id="R-subsections-66002f201bef818664bb81aa67490c58" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/readme/index.html">reference</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/configuration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/configuration/index.html">configuration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/cli/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/cli/index.html">cli</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/mcp/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/mcp/index.html">mcp</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/agent/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/agent/index.html">agent</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/memory/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/memory/index.html">memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/orchestration/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/orchestration/index.html">orchestration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/reference/api/state-event/index.html"><a class="padding" href="/AgenticGoKitDocs/reference/api/state-event/index.html">state-event</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/index.html"><input type="checkbox" id="R-section-e1e8c1e70c5500b49e8dda2dc550651a" aria-controls="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" checked><label for="R-section-e1e8c1e70c5500b49e8dda2dc550651a"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu tutorials</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/index.html">tutorials</a><ul id="R-subsections-e1e8c1e70c5500b49e8dda2dc550651a" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/readme/index.html">tutorials</a></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/advanced/index.html"><input type="checkbox" id="R-section-d3def5cd76adc8096d0ff9fda6b8e479" aria-controls="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" checked><label for="R-section-d3def5cd76adc8096d0ff9fda6b8e479"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu advanced</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/index.html">advanced</a><ul id="R-subsections-d3def5cd76adc8096d0ff9fda6b8e479" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/readme/index.html">advanced</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/circuit-breaker-patterns/index.html">circuit-breaker-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/load-balancing-scaling/index.html">load-balancing-scaling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/retry-policies/index.html">retry-policies</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/advanced/testing-strategies/index.html">testing-strategies</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/index.html"><input type="checkbox" id="R-section-212c6ccffb40ecdd78eb2136f98c4cac" aria-controls="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" checked><label for="R-section-212c6ccffb40ecdd78eb2136f98c4cac"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu core-concepts</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/index.html">core-concepts</a><ul id="R-subsections-212c6ccffb40ecdd78eb2136f98c4cac" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/readme/index.html">core-concepts</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/agent-lifecycle/index.html">agent-lifecycle</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/error-handling/index.html">error-handling</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/message-passing/index.html">message-passing</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/orchestration-patterns/index.html">orchestration-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/core-concepts/state-management/index.html">state-management</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/debugging/index.html"><input type="checkbox" id="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" aria-controls="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" checked><label for="R-section-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu debugging</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/index.html">debugging</a><ul id="R-subsections-d8dfe6eec6c6d4cb6f6f50bdd07fa3cc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/readme/index.html">debugging</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/debugging-multi-agent-systems/index.html">debugging-multi-agent-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/debugging/logging-and-tracing/index.html">logging-and-tracing</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/index.html"><input type="checkbox" id="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247" aria-controls="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" checked><label for="R-section-e7f904c8b9d0f9bf1f07ca7d482d2247"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu getting-started</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/index.html">getting-started</a><ul id="R-subsections-e7f904c8b9d0f9bf1f07ca7d482d2247" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/readme/index.html">getting-started</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/memory-and-rag/index.html">memory-and-rag</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/multi-agent-collaboration/index.html">multi-agent-collaboration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/production-deployment/index.html">production-deployment</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/quickstart/index.html">quickstart</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/tool-integration/index.html">tool-integration</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/getting-started/your-first-agent/index.html">your-first-agent</a></li></ul></li>
            <li class="parent alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/mcp/index.html"><input type="checkbox" id="R-section-153aac44598009a99dd5a60317a3eecc" aria-controls="R-subsections-153aac44598009a99dd5a60317a3eecc" checked><label for="R-section-153aac44598009a99dd5a60317a3eecc"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu mcp</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/index.html">mcp</a><ul id="R-subsections-153aac44598009a99dd5a60317a3eecc" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/readme/index.html">mcp</a></li>
            <li class="active " data-nav-id="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/advanced-tool-patterns/index.html">advanced-tool-patterns</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-development/index.html">tool-development</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/mcp/tool-integration/index.html">tool-integration</a></li></ul></li>
            <li class="alwaysopen " data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/index.html"><input type="checkbox" id="R-section-9c1a65f2d7b3888241dcafa51a0710e7" aria-controls="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" checked><label for="R-section-9c1a65f2d7b3888241dcafa51a0710e7"><i class="fa-fw fas fa-chevron-right"></i><span class="a11y-only">Submenu memory-systems</span></label><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/index.html">memory-systems</a><ul id="R-subsections-9c1a65f2d7b3888241dcafa51a0710e7" class="collapsible-menu">
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/readme/index.html">memory-systems</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/basic-memory/index.html">basic-memory</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/document-ingestion/index.html">document-ingestion</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/knowledge-bases/index.html">knowledge-bases</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/memory-optimization/index.html">memory-optimization</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/rag-implementation/index.html">rag-implementation</a></li>
            <li class="" data-nav-id="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html"><a class="padding" href="/AgenticGoKitDocs/tutorials/memory-systems/vector-databases/index.html">vector-databases</a></li></ul></li></ul></li>
          </ul>
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-shortcuts">
          <ul class="space collapsible-menu">
          </ul>
        </div>
        <div id="R-footer-margin"></div>
        <div class="R-menu-divider default-animation">
          <hr class="padding">
        </div>
        <div class="R-sidebarmenu R-shortcutmenu-footercontrols">
          <ul class="">
          </ul>
        </div>
<div id="R-footer"><p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p></div>
      </div>
    </aside>
    <script src="/AgenticGoKitDocs/js/clipboard/clipboard.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/perfect-scrollbar/perfect-scrollbar.min.js?1753430931" defer></script>
    <script src="/AgenticGoKitDocs/js/theme.js?1753430931" defer></script>
  </body>
</html>
